{
  
    
        "post0": {
            "title": "Next Generation Sequencing (차세대 염기 서열 결정법) 이론",
            "content": "기존의 직접염기서열분석법(direct sequencing)은 분석하고자 하는 부위를 PCR로 증폭해야 하기 때문에 여러 타겟을 분석할 경우 많은 시간과 노력 및 비용이 소요되어 효율성이 낮은 문제점이 있었다. 이러한 단점을 극복하고자 차세대 염기서열분석(next generation sequencing; NGS) 법이 개발되었으며 이것은 DNA 가닥을 각각 하나씩 분석하는 방식으로 기존의 직접 염기서열분석법에 비해 매우 빠르고 저렴하게 염기서열이 가능하다는 장점을 가지고 있다. NGS는 DNA를 일정한 조각(fragment)으로 분절화시키고 장비가 인식할 수 있는 특정 염기서열을 가진 올리고뉴클레오티드(oligonucleotide)를 붙여주는 라이브러리 (library) 제작, 각 라이브러리 DNA 가닥의 염기서열을 장비에서 읽는 단계, 그리고 장비에서 생성된 데이터를 가공하여 알고리즘으로 분석하는 단계로 구성된다. . . . NGS 장비 기술의 발달로 2008년 1명의 유전체를 분석하는 데에 6개월이 걸렸다면, 2017년엔 60명의 유전체를 분석하는 데에 2일이 걸리게 되었고, 그 비용도 낮아졌다. 이는 IT의 발전과 무관하다고 볼 수 없다. . . 개인의 유전체를 분석하는 것이 왜 사업이 될까? 예를 들어 특정 화학물질이나 약물에 대하여 부작용이 발생할 가능성을 유전체 정보를 통해 파악할 수 있다. 한 개인이 자신의 유전체 정보를 가지고 있다면, CYP2C19(약물 대사와 관련된 유전자)의 변이로 인해 Plavix와 같은 혈압 조절제를 복용하면 심각한 부작용이 나타나는 등의 일의 발생을 막을 수 있다. 혹은 CYP1A2(카페인 분해 능력 관련 유전자)의 변이가 있다면, 이로 인해 카페인을 먹은 후 가슴 두근거림 등의 부작용이 발생할 수 있다는 것을 알 수 있다. 이처럼 개인의 유전체 정보를 이용하면 특정 약물에 대한 부작용을 사전에 방지할 수 있다는 이점이 있다. . Sequencing(&#50684;&#44592; &#49436;&#50676; &#44208;&#51221;)&#44284; NGS . chain termination &#48169;&#48277; . Sanger sequencing은 1977년에 Frederick Sanger에 의해 개발된 방법으로, 기본적으로 polymerase chain reaction (PCR) 과정에서 di-deoxynucleotide triphosphates (ddNTPs)에 의해 DNA strand가 합성되지 않는 chain termination의 원리와, 전기영동의 원리를 이용하여 염기서열을 확인하는 방법이다. PCR 과정에서 DNA가 증폭되던 중 우연히 dNTP 대신 ddNTP가 결합된 경우, ddNTP의 3번 탄소에는 수산화기가 없으므로 더 이상 새로운 인산기가 결합될 수 없어 증폭이 중지된다는 이유에서 chain termination이라는 이름이 붙었다. . chain termination&#51032; &#50896;&#47532; . Sanger sequencing을 이해하기 위해서는 우선적으로 PCR 과정 대해 이해할 필요가 있다. DNA 서열 증폭을 위해서는 DNA를 구성하는 기본 단위인 deoxynucleotide triphosphate (dNTP)가 필요하다. 즉, DNA의 복제는 주형 DNA 가닥에 상보적인 dNTP가 결합하면서 이루어진다. DNA 서열에 dNTP가 중합될 때, DNA 서열 마지막 nucleotide 3번 탄소의 수산화기(-OH)와 새로운 dNTP 5번 탄소의 인산기가 반응하여 결합된다. 이 과정에서 dNTP 대신 ddNTP를 이용하면(즉, DNA 복제 과정에서 DNA 가닥이 합성될 때 dNTP 대신 ddNTP가 결합하게 하면) DNA 복제가 중단된다. 즉, Sanger sequencing 원리의 핵심은 ddNTPs에 있다. 그렇게 되면 다양한 길이의 DNA 조각이 발생하게 된다. . . dNTP는 3&#39;-OH가 연결되어 있어 새로운 뉴클레오타이드의 인산과 결합하여 DNA가 복제될 수 있게 한다. 그러나 ddNTP는 dNTP의 3번 탄소에 산소(oxygen)가 존재하지 않는, 즉 수산화기(-OH) 대신 수소(-H)가 결합되어 있는 nucleotide 구조이다. 따라서 다른 뉴클레오타이드의 결합을 방해한다. 즉, DNA 복제가 더이상 일어나지 않게 한다. 이는 DNA가 중합될 때 3번 탄소의 하이드록시기와 인산기가 탈수축합 하는데, 디데옥시뉴클레오타이드(ddNTP)의 경우 탈수축합이 불가능해서 DNA 중합반응이 멈추기 때문이다. . . 1차적으로 ddNTP를 포함한 PCR이 완료된 후에는 염기서열을 크기 순으로, 증폭된 서열을 정렬하여 해당 염기서열의 합성정보가 각 서열 끝에 마지막으로 결합된 ddNTP가 가지고 있던 형광물질을 종류에 따라 읽게 되는 원리이다. 이 방법에 필요한 재료는 염기 서열을 알고자 하는 template DNA 단일 가닥(ssDNA strand), DNA primer, DNA polymerase, 네 개의 dNTP(dATP, dTTP, dGTP, dCTP), 서로 다른 색깔로 형광 표시된 4 종류의, 소량의 ddNTP (디디옥시뉴클레오티드;핵산별로 ddATP (아데닌), ddGTP (구아닌), ddTTP (티민), ddCTP (사이토신))이다. 이들을 이용하여 PCR을 우선 진행한다. ddNTP는 방사성 또는 형광으로 표지되어, 자동 시퀀싱 기계에서 감지된다. 따라서 ddNTP가 합성 중인 DNA 사슬의 끝에 붙게 되면 detection이 가능해진다. ddNTP의 결합은 무작위적으로 일어나게 되므로, 수 많은 증폭과정을 통해 거의 모든 염기서열 위치에서 chain termination이 일어나게 된다. . . . ddNTP를 포함한 PCR이 완료된 후에는, 염기서열을 크기에 따라 작은 순서대로 정렬할 수 있는 전기영동을 이용하여 증폭된 서열을 정렬한다. 크기순으로 정렬된 서열의 순서대로 형광 신호를 인식시키면, 염기서열 순서대로 해당 염기 서열에 해당하는 핵산 정보가 각 서열 끝에 마지막으로 결합된 ddNTP가 가지고 있던 형광물질 종류에 따라 읽게 된다. 생어의 염기서열 분석법 이전에는 DNA를 길이 별로 정렬하는 것을 ‘수동’으로 진행했다. 그렇지만 생어는 이것을 전기영동을 활용함으로써, 자동으로 배열되도록 했다. 전기영동에 아까의 DNA 분자들을 넣으면, 길이 순서대로 내려가게 되고 이것을 감지기가 감지하면서 염기서열을 읽어나가게 된다. . . DNA 염기서열을 알아내기 위하여 겔 상에서 시험할 때, 네 개의 시퀀스에 따른 네 개의 레인별로 별도의 시퀀싱 반응을 위한 샘플로 나누고, 각 샘플에는 dNTP와 DNA polymerase, ddNTP가 추가된다. . . 겔 상에서 검은띠로 나타난 strand는 아래에서 위로 읽어들인다. 즉 위의 사진에서 서열은 TACGAGATATATGGCGTTAATACGATATATTGGAACTTCTATTGC다. . 염기 서열 분석의 초창기에는 다음에 소개할 chemical degradation 방법이 많이 사용되었다. 그러나 chain termination 방식이 더 쉽고 빠르게 읽을 수 있기 때문에 chain termination이 많이 쓰였고, 현재는 대규모 자동 게놈 분석을 위해 NGS 방법이 많이 쓰인다. 다만, Sanger 방식은 더 작은 규모의 프로젝트와 NGS 결과의 검증, 긴 연속 DNA 염기서열 분석(&gt;500 뉴클레오티드)을 위해 아직도 널리 쓰이고 있다. . chemical degradation &#48169;&#48277; . 특정 염기를 자를 수 있는 chemical을 이용하여 DNA 가닥을 잘라내고, 전기영동을 통해 길이 별로 잘려진 말단 부위의 염기서열을 인식하여 서열을 결정하는 원리. . NGS . 생어의 방법의 한계점은 인간게놈프로젝트를 통해 나타나게 된다. 염기서열 분석법으로는 인간의 게놈과 같이 대량의 DNA를 분석하기에는 부족하다는 것이다. 보통 1000 염기 정도를 한번에 분석할 수 있는 생어의 염기서열 분석법과는 달리, NGS를 이용하면 100만에서 10억 염기까지 한번에 분석할 수 있다. 사실 차세대 염기서열 분석법이 아직까지는 정확도 측면 등에서 생어의 방법보다 부족하다. 그럼에도 불구하고 NGS를 사용하는 이유는 앞서 언급했듯이 ‘대량의 DNA’를 읽기 위함이다. 인간게놈프로젝트가 13년에 걸쳐 무려 30조원의 비용이 든 것을 생각하면, 비용과 시간적 측면에서 많은 양의 DNA 분석에 생어의 방법을 사용하기 어렵다는 결론이 나온다. 반면 NGS는 방법마다 조금의 차이는 있지만 비용이 100만원대로 극적으로 줄어들었다. 그만큼 NGS는 대량의 DNA분석에 반드시 필요한 도구이다. . NGS는 genomic 수준의 해독을 통해 세포 내에 존재하는 다양한 현상들을 규명하기 위한 방법이다. 세포 내의 복잡한 현상들을 DNA나 RNA의 해독을 통해 생명 현상을 이해하려는 시도라고 볼 수 있다. NGS는 Sanger에 의해 고안된 chain termination 방법 이후 급격하게 발전을 거듭해왔다. Illumina사의 플랫폼이 현재 가장 dominant하다. . NGS에서는 기종에 따라 약간의 차이는 있지만 기본적으로 DNA 서열에 대한 증폭을 하고 그 후 형광 표식 등을 카메라로 찍어 이미지 처리를 하는 과정을 거쳐 염기를 읽어낸다. . NGS &#54540;&#47019;&#54268; . NGS 장비는 현재 일루미나(Illumina), 써모피셔사이언티픽(Thermo Fisher Scientific), 퍼시픽바이오사이언스 (Pacific Biosciences), 옥스포드나노포어(Oxford Nanopore Technologies) 등의 회사에서 출시된 제품들이 관련 시장을 형성하고 있다. 퍼시픽바이오사이언스, 옥스포드나노포어 등의 3세대 장비들은 2세대 장비의 짧은 분석범위의 단점을 보완한 것으로서 PCR 증폭 과정이 없이 DNA 단일분자를 실시간(real-time)으로 읽어 매우 긴 DNA 가닥의 염기서열을 한번에 읽을 수 있다는 장점이 있으나 개별 염기서열 측면에서 보면 정확도가 높지 않은 단점이 있다. . . . 여러 장비 회사 중 Illumina의 NovaSeq이 현재로서는 가장 최신의 기기인데, 60명의 게놈을 하루만에 해독가능하다. 같은 회사 장비 중 HiSeq X는 하루에 한 명의 게놈만 해독 가능하다는 점에서 60배나 높은 성능을 보인다. . &#47196;&#49800;(Roche)&#51032; 454 &#49884;&#47532;&#51592; . 2008년 NGS로는 최초로 인간 게놈의 시퀀싱 결과를 발표하였다. NGS를 사용하여 4.5개월 만에 완료된 이 결과는 13년이 걸렸던 Human Genome Project와 비교되면서 당시 큰 주목을 받았다. 454는 또한 GS Junior라는 소형 NGS 장비도 2009년 가장 먼저 시장에 내놓았는데, read length는 400bp에 이르며, 10시간의 run time으로 35Mb의 데이터를 생산한다. 454 시리즈에서는 하나의 bead에 하나의 DNA 사슬을 고정한 후에 emPCR로 증폭을 시킨다. 증폭이 끝나면 각 bead에는 수백만 개로 복제된 동일한 DNA 서열이 덮이게 되고, 각 bead는 PicoTiterPlate라는 장치에서 하나의 구멍 (well)에 하나씩 들어가서 시퀀싱에 개시된다. 454의 시퀀싱 기법은 Pyrosequencing chemistry라고 하며 Luciferase가 사용되어 염기의 빛을 측정하여 읽어낸다. . . 454에서는 대신 한 번의 run에서 생산되는 데이터 양이 다른 기종에 비해서 상대적으로 적어서 FLX+ 시스템의 경우에도 700Mb 정도이다. 생물정보학에서는 어떠한 형식으로 데이터가 생성 되는지도 중요한데, NGS 데이터를 분석하기 위한 소프트웨어가 어떤 형식의 데이터를 받아들일 수 있는지를 먼저 확인해야 하기 때문이다. 454 시리즈에서 생성되는 NGS의 데이터 형식은 SFF 파일이다. . 로슈 산하의 454에서는 GS FLX+ system을 기준으로 read length가 600bp 또는 1,000bp 에 이른다는 점을 가장 큰 장점으로 내세운다. 하나의 read에서 읽어내는 염기 길이가 길다는 점은 방대한 수의 그러한 단편을 모아서 순서를 맞추는 어셈블리, 혹은 기존의 reference 서열에 맞추는 resequencing의 mapping 난이도를 낮출 수 있다는 의미를 가진다. . &#51068;&#47336;&#48120;&#45208; (Illumina)&#51032; GA, HiSeq, MiSeq &#49884;&#47532;&#51592; . 1998년 설립된 Solexa는 SBS (Sequence by Synthesis) 라는 새로운 기술을 시퀀싱에 적용하였고, 2007년 일루미나는 Solexa를 합병한 후에 SBS 기반의 다양한 NGS 장비를 발전시켜 왔다. 2012년 현재의 대표적인 기종인 HiSeq 2000의 경우, 2 x 100bp read에서 11일까지의 run time으로 최대 540-600Gb까지 데이터 생산이 가능한 것이 특징이다. 일루미나의 NGS 시리즈는 전반적으로 저렴한 run 가격으로 많은 데이터를 생산하는 특징을 추구해 왔으며, 따라서 대용량의 시퀀싱을 대량으로 처리하는 연구에서 많이 사용되었다. . 일루미나(Illumina)사의 기술은 DNA 가닥을 복제 혹은 합성하면서 각기 다른 형광이 부착된 염기(dATP, dCTP, dTTP, dGTP)와 함께 DNA 중합효소(polymerase)를 넣어 주면 각 DNA의 염기서열에 상보적인 염기가 삽입되면서 각기 다른 형광을 방출하게 되는데 이것을 장비에 부착된 CCD 카메라로 사진을 찍고, 장비는 형광이 발생된 클러스터의 위치를 기억하고 있다가 각 클러스터의 형광 변화를 감지하여 클러스터의 염기서열을 기록하는 기술이다. 출시된 장비로는 iSeq, MiniSeq, MiSeq, NextSeq, HiSeq, NovaSeq 등이 있으며 열거된 순서에 따라 출력(output)이 높아져 대량의 데이터를 생산할 수 있다. . . 일루미나의 NGS 기법에서는 브릿지 증폭이라는 방식으로 슬라이드 위에 DNA 단편을 고정시킨 후에 최대 1,000 분자까지 증폭시켜 같은 서열의 DNA 단편 집단을 형성시키는 게 특징이다. 즉, bead가 아닌 plate 위에서 bridge PCR 과정을 통해 DNA를 증폭시킨 후, 단일 가닥의 template만 확보하여 염기서열을 알아내는 방식이며 이를 solid-state based 방식이라고도 한다. 일루미나에서는 이 집단을 클러스터 (cluster)라고 표현하며, 이 클러스터를 주형으로 네 종류의 형광 표식 염기를 사용한 염기 합성반응인 SBS를 수행한다. . . . 일루미나 시리즈에서는 DNA 서열을 다른 기법들처럼 용액 안에서 증폭시키는 것이 아니라 판 위에 고정시킨 후에 판 위에서 구부러지면서 증폭되어 서열집단을 형성하는 것이 특징이다. 그렇게 형성된 클러스터라는 집단은 집단 별로 시퀀싱이 이루어져 각 read의 염기서열 정보로 전환되고 분석과정으로 넘어간다. 일루미나의 데이터 형식인 FASTQ 파일은 현재 가장 많은 분석 소프트웨어에서 널리 사용되고 있다. . 2011년에는 일루미나도 MiSeq을 발표하여 소형 NGS 장비 시장에 참가했다. MiSeq의 특징은 기존 대용량 시퀀서인 HiSeq의 기법 (chemistry)을 그대로 유지하면서 소형화에 성공하여, 장비 크기와 가격을 줄이고 작업을 더 빠르고 간편하게 만들었다는 점이다. MiSeq은 2 x 150bp에서 최대 24시간의 run time으로 3.7-4.6Gb의 데이터를 생산하며, 향후 2 x 250bp가 되면 35시간 이상의 run time으로 7Gb까지 가능할 예정이다. 2012년에 발표된 HiSeq2500은 HiSeq2000을 업그레이드하여 MiSeq의 신속함을 겸비함으로써 27시간에 120Gb까지 데이터를 생산하는 기능도 추가로 갖추게 된다. . &#46972;&#51060;&#54532; &#53580;&#53356;&#45440;&#47196;&#51648;&#49828; (Life Technologies (ABI))&#51032; SOLiD, 5500 &#49884;&#47532;&#51592; . 원래는 최초의 시퀀서를 등장시킨 어플라이드 바이오시스템즈 (Applied Biosystems / ABI)라는 이름으로 알려져 있지만, 인비트로젠 (Invitrogen)과 합병되어 현재는 라이프 테크놀로지스가 공식 명칭이 되었다. 라이프 테크놀로지스의 SOLiD 시리즈에서는 emulsion PCR 과정 이후의 Ligation을 사용한 시퀀싱이 특징이다. 이 기법에서는 간격을 두면서 두 개씩 염기를 읽는데, primer reset을 통해 독립적으로 다섯 번을 반복하기 때문에, 최종적으로는 각 염기를 두 번씩 중복하여 읽어서 정확도를 높인다. . . 하나의 reed 위에 Primer(n)에서 (n-4)까지 독립적으로 염기들을 다섯 번을 읽어낸다. 이는 그림의 검은 점에 해당되는 위치에 나타나있다. 다섯 번의 독립적인 사이클이 모두 완료되면 Read Position 1번에서 29번까지는 최종적으로 모두 두 개의 검은 점이 위치하게 되는데, 이는 두 번씩 독립적으로 읽힌다는 것을 의미한다. . SOLiD 후속 기종인 5500 시리즈에서는 ECC (Exact Call Chemistry) 기법이 적용되어 여섯 번째 프라이머가 추가되었고 따라서 read 상에서 상당수의 염기를 서로 다른 프라이머로 세 번씩 독립적으로 읽음으로써 정확도를 SOLiD 시리즈의 99.94%에서 99.99%로 향상시켰다. 5500의 다른 특징은 여섯 개의 lane으로 구성된 FlowChip에서 각 lane 별로 서로 다른 시퀀싱을 동시에 수행하는 Pay-Per-Lane sequencing 방식도 가능하기 때문에 시간과 비용을 절약할 수 있다는 점이다. . . 5500 시리즈에서는 정확도를 더 높이기 위해 상당수의 Read Position이 겹쳐지는 프라이머가 추가되어 한 번 더 독립적으로 읽어들여, 내부 검증을 강화시킨다. . SOLiD 시리즈에서는 csfasta 형식으로 데이터가 생성되고, 5500 시리즈에서는 기본적으로 35, 60, 75bp 등의 read length로 XSQ (eXtensible SeQuence)라는 바이너리 파일 형식의 데이터가 생성된다. . &#51228;3&#49464;&#45824; &#49884;&#53248;&#49436;, &#52264;&#52264;&#49464;&#45824; &#49884;&#53248;&#49436; (3rd Generation Seguencer, Next NGS) . 제3세대 시퀀서는 시퀀싱 전의 PCR 증폭 과정이 생략되고, DNA 단일분자를 그대로 시퀀싱 할 수 있다는 점이 차세대 시퀀서와 구분되는 점이다. Single Molecule Real Time (SMRT) 기법이라고도 한다. . 시장에는 Pacific BioSciences사의 PacBio RS 시스템이 나와있는데, 이 시스템의 경우에는 ZMW (Zero-Mode Waveguide)라는 기술이다. 이 기술은 바닥에 고정된 작은 구멍으로 DNA 사슬이 통과하면서, DNA polymerase와 상보적으로 결합하는 염기의 형광을 인식하여 시퀀싱을 수행한다. 시퀀싱이 하루 안에 완료되며 최대 90Mb의 데이터를 생산하는데, read length가 평균 2,500-3,000bp로 매우 길다는 것이 장점이다. . &#48152;&#46020;&#52404; &#49884;&#53248;&#49436; (Semiconductor Sequencer) . 써모피셔사이언티픽(Thermo Fisher Scientific) 사의 장비는 인수하기 전 처음 개발한 회사인 Ion Torrent 장비로 더 널리 알려져 있다. 이 장비는 미세한 비드(bead)에 DNA 라이브러리를 붙여 촘촘하게 짜여진 미세한 구멍(well)에 하나씩 들어가도록 하고 각 구멍 밑에는 전류를 측정할 수 있는 반도체 칩 회로가 설계되어 있어 상보적인 염기가 결합하는 합성 과정에서 방출되는 수소이온(H+)으로 인하여 pH가 낮아지는 것을 반도체칩의 센서가 탐지하고 분석하는 방식이다. 현재 출시된 장비로는 Ion Personal Genome Machine(PGM) 및 Ion S5 System 두 가지 종류가 있다. . . emulsion PCR로 DNA를 증폭하는 것은 다른 NGS 기종과 유사하지만, 다른 기법처럼 빛을 발생시키는 인공염기를 사용해서 빛을 인식하는 시퀀싱 방식이 아닌, 반도체 칩의 작은 구멍(well)에서 각각 DNA 합성이 일어나면서 나타나는 pH 변화를 직접 반도체에서 신호로 잡아내어 수행한다는 점이 특징이다. . . 다른 NGS 장비에서 필요한 카메라와 빛 인식, 이미지 처리 등이 모두 생략되었기 때문에 장비가 작고 저렴해졌으며, 시퀀싱과 분석도 3시간 정도에 완료된다. 따라서 신속한 소규모 시퀀싱이 가장 큰 장점이다. 반도체 칩에서 실제 시퀀싱을 하기 때문에 세 종류의 칩 중에서 하나를 선택하면 데이터 생산량과 비용을 고려한 시퀀싱이 가능하다 (10Mb to &gt; 1Gb). 2012년 현재는 10Gb와 100Gb의 데이터를 생산하는 새로운 반도체 칩에 대응하는 Ion Proton이 발표되었으며, 100Gb에 해당되는 칩을 사용한다면 약 1,000달러의 비용으로 하루 안에 인간 게놈 시퀀싱이 가능하게 될 예정이다. . 개발자인 로스버그 (Rothberg) 박사가 454를 개발했던 장본인이기 때문에 기법이 454와 유사한 부분이 있지만, 기본적으로는 지금까지의 어느 NGS 장비와도 구별되는 반도체 시퀀싱이기 때문에 다른 NGS 시퀀싱 결과에 대한 상호검증에 효과적이며, 새로운 기술이지만 사실은 오랫동안 무어의 법칙에 따라 발전하고 있는 반도체 기술이 그 기반이라는 점은 장점으로 꼽을 수 있다. Ion PGM에서는 평균 100bp와 200bp의 read length로 SFF, FASTQ 형식 데이터를 생산하며, PGM에 부속된 서버에서 reference 서열에 대한 mapping도 수행되기 때문에 그 결과 파일인 BAM 파일도 함께 제공한다. . &#50725;&#49828;&#54252;&#46300; &#45208;&#45432;&#54252;&#50612; (Oxford Nanopore) . 나노포어 라는 것은 직경 나노 (10억분의 1)미터의 극소의 구멍을 DNA 분자가 통과하면서 네 종류의 염기마다 서로 다른 세기의 전류가 흐르게 해서 염기를 읽어내는 기법이다. NGS에서 염기서열을 읽어내기 위해서는 보통 DNA를 증폭하고 빛을 방출하는 인공염기를 사용해 복제할 필요가 있는데 그러한 조작과 시약이 모두 생략되는 셈이다. 참고로, 위에서 설명한 것처럼 제3세대에서는 DNA 증폭이, 반도체 시퀀싱에서는 인공염기가 이미 각각 생략되어 있다. . NGS&#51032; &#50896;&#47532; . NGS도 여러가지가 있는데, 여러 방법들 모두에게서 공통적으로 나타나는 특징이 있다. 첫째로는 DNA 증폭이 필요하다는 점이다. DNA를 조각 내고, 각 조각들을 증폭하여 양을 늘린다. 두번째는, 증폭된 DNA를 어떤 곳에 ‘부착’한다는 점이다. 이 ‘부착’을 위해서, 증폭된 각 조각들은 특별히 만들어진 부착 서열과 결합하게 된다. 이렇게 부착을 통한 분석 방법의 큰 장점은 바로 방향성을 조절할 수 있다는 것이다. 그래서 3’에서 5’ 방향과 5’에서 3’ 방향을 조절하여 양 방향의 DNA를 모두 읽어 낼 수 있다. NGS는 구체적인 방법에 따라서 크게 3가지로 구분할 수 있다. 454 시리즈의 특징인 긴 read는 reference 서열이 없이 read를 서로 조립하는 de novo sequencing 등을 유리하게 하는 것으로 알려져 있다. . NGS&#51032; &#44592;&#49696;&#48324; &#48516;&#47448; . 염기 서열 결정 방법에 따라 first generation, second generation, third generation으로 나눌 수 있다. 기본적으로 모든 시퀀서는 Sanger 방식 기반이었다. 그러나 1세대인 Sanger 방식과 달리 대량의 병렬 데이터 생산이 가능한 시퀀서가 등장했고 이를 차세대 시퀀서 (Next Generation Sequencer, 2nd Generation Sequencer)라고 한다. first generation이 바로 sanger의 방식이다. second generation과 third generation은 NGS에 해당하는데, 이는 해독되어지는 뉴클레오티드의 단위인 read의 길이에 따라 분류된다. Illumina, Thermo Fisher 등이 short read를 해독할 수 있는 기술을 갖고 있다. PacBio와 Oxford Nanopore는 long read를 해독할 수 있는 기술을 갖고 있다. short read를 해독할 수 있는 second generation 방식은 다시 SBL과 SBS 방식으로 나누어진다. SBS 방식은 다시 CRT 방식과 SNA 방식으로 나누어진다. 염기 서열을 결정하기에 앞서, 해독하고자 하는 template DNA에 대한 증폭 과정을 거치게 되는데, 이를 template cluster generation이라고 한다. template cluster generation은 구슬(bead) 방식, 유리판(solid-state) 방식으로 다시 나누어진다. . 최근에는 NGS를 넘어선 3세대 염기서열 분석법 또한 개발되고 있다. 이 3세대 염기서열 분석법은 DNA 증폭 과정을 생략하고 분석할 수 있도록 하는 기술로, 점점 상용화 단계에 접어들고 있다. . Pyrosequencing(&#46608;&#45716; bead-based &#48169;&#49885;) . Pyrosequencing은 DNA 단일가닥을 비드(bead)에 부착하고, DNA 중합효소를 통해 반대쪽 가닥을 합성하면서 염기서열을 읽어나가는 방식이다. Pyrosequencing은 Pyro라는 이름에서 알 수 있듯이, 중합 시 발생하는 피로인산을 통해 염기서열을 알아내는 방식이다. . 구슬같이 생긴 nano 단위의 adopter가 oil 방울(emulsion)에 갇혀있고 이 emulsion 내에서 PCR 반응이 이루어진다. 염기서열 결정을 위해 bead에 붙어있는 adopter와 template의 상보적인 서열을 바탕으로 결합시킨 후 증폭시키면, 단일 가닥의 증폭된 DNA를 확보하게 된다. 해당 기술은 Roche, Thermo Fisher 등이 가지고 있다. . 방식은 다음과 같다. 먼저, dATP를 넣는다. 이때 만약 중합 되어야 할 염기가 아데닌이라면, 피로인산이 나오면서 DNA가 신장될 것이다. 이때 발생한 피로인산은 일련의 화학반응을 거치게 되어 빛을 내고, 이 빛을 감지하여 염기서열을 읽을 수 있는 상태가 된다. 만약 이때 빛이 나오지 않는다면 아데닌이 아니라는 것이고, 반응물을 씻어내고 구아닌, 티민, 사이토신에 대해서 같은 일을 반복하여 빛이 언제 발생하는지 알면 어떤 염기인지 알 수 있게 된다. 이런 Pyrosequencing의 장점으로는 한번에 긴 서열을 읽을 수 있다는 점이다. 그러나 단점은 반응물에 들어가는 비용이 크다는 것, 두번째로는 같은 염기가 6개 이상 반복될 경우 오차가 크게 발생한다는 점이다. . . Sequencing by synthesis . DNA 중합반응을 이용한 염기서열 분석법이다. 이 분석법은 어떤 면에서 생어의 분석법과 상당히 유사하다. 이 분석법에서는 조금 변형된 뉴클레오타이드를 사용하는데, 이 뉴클레오타이드는 DNA 분자에 연결될 때 형광이 발생하며, Teminator cap이라는 부위가 있어서 DNA가 더 이상 연장되지 못하도록 막는다. 이것은 ddNTP와 유사한 특징을 가진다. 다만 차이점은 ddNTP는 절대 연장되지 못하지만, Terminator cap의 경우 효소를 통해 잘라낼 수 있기 때문에 원하는 순간에 다시 DNA 연장을 재개할 수 있다. 이 분석법은 이렇게 변형된 뉴클레오타이드의 특성을 활용하여 염기서열을 알아낸다. 네 종류의 뉴클레오타이드(A, T, G, C)는 각각 다른 형광을 띄고, 그러므로 한 염기가 결합했을 때 발생하는 형광의 종류를 분석하면 어떤 염기가 그 위치에 들어가는지 알 수 있게 된다. . 그 뒤, Teminator cap을 잘라내고 다음 염기를 중합하게 되면, 형광이 또 발생하고 이를 통해 그 다음 염기의 종류를 알아내고, 이 과정을 계속 반복하여 염기서열을 쭉 읽어낼 수 있다. 이 방식의 장점은 위의 Pyrosequencing에서 동일한 염기만 반복되는 경우 오차가 커지는 문제를 해결할 수 있다는 점이다. 그러나 이 방식은 긴 염기서열을 읽을수록 오차가 커지는 문제가 있다. . Sequencing by ligation . 앞선 두 과정에서는 뉴클레오타이드를 DNA 중합효소를 이용하여 단일 가닥에서 이중 가닥으로 합성하는 과정을 사용하는데, 이 방법의 경우 인위적으로 설계된 작은 DNA 조각을 DNA ligase로 연결하는 방식이다. 이 방법의 경우 굉장히 짧은 서열 밖에 읽지 못한다는 단점이 있다. . &#49464; &#48169;&#48277; &#51473; &#49440;&#53469;&#51032; &#44592;&#51456;? . 각각의 장단점이 있는 세가지 방법은 상황과 목적에 따라 다르게 쓰인다. 셋 중에 가장 널리 쓰이는 것은 두번째 방법인 Sequencing by synthesis이나, 읽어야하는 샘플의 크기에 따라 사용하는 방법은 달라진다. . &#47928;&#51228; . &#47928;&#51228; 1 . 그림은 dGTP와 ddGTP를 나타낸 것이다. ㈎와 ㈏에 대한 설명으로 옳은 것만을 에서 있는 대로 고른 것은?&lt;/p&gt; . ㄱ. ㈎는 DNA의 3´말단과 결합한다. . ㄴ. ㈏가 결합하면 DNA 합성이 중지된다. . ㄷ. ㈎의 염기는 C와 상보적 결합을 할 수 있으나, ㈏의 염기는 C와 상보적 결합을 할 수 없다. . 정답: ㄱ, ㄴ . &#47928;&#51228; 2 . 그림은 DNA(주형 가닥)와 DNA 염기 서열 분석에 의해 합성된 가닥들을 나타낸 것이다. 이 자료에 대한 설명으로 옳은 것만을 에서 있는 대로 고른 것은?&lt;/p&gt; . ㄱ. ddNTP 때문에 합성된 가닥들의 길이가 다르다. . ㄴ. 전기 영동시킬 때 DNA 가닥이 길수록 더 멀리 이동한다. . ㄷ. 새로 합성된 DNA의 염기 서열은 주형 가닥의 염기 서열과 동일하다. . 정답: ㄱ . Reference . https://ko.wikipedia.org/wiki/생어_염기서열_분석 | http://study.zum.com/book/14731 | http://www.incodom.kr/Sanger_sequencing | https://www.bio.davidson.edu/courses/molbio/molstudents/01licohen/sequencing.html | http://dwb.unl.edu/Teacher/NSF/C08/C08Links/www.piopio.school.nz/molmed.htm | https://www.ksakosmos.com/post/지식더하기-더-많은-양을-더-빠르게-차세대-염기서열-분석법-ngs | 박근준, &quot;NGS (Next Generation Sequencer) 기법 소개,&quot; KSBMB NEWS, 6월호 | 이승태, 이경아, 심효섭, 원홍희, 김나경, 신새암, &quot;Next Generation Sequencing 기반 유전자 검사의 이해 입문용,&quot; 식품의약품안전처 식품의약품안전평가원 | . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; .",
            "url": "https://tfedohk.github.io/dohk/ngs-concept/",
            "relUrl": "/ngs-concept/",
            "date": " • Nov 9, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "R 기초",
            "content": "SW &#45796;&#50868;&#47196;&#46300; . R: https://cran.r-project.org/bin/windows/base/ | R studio: https://rstudio.com/products/rstudio/download/ | . R studio IDE . . 여러 라인 실행 시, 블록 지정 후 Ctrl+Enter | . R project &#49373;&#49457; . . getwd() . . package &#49444;&#52824; . 맥에서는 자바 설치가 필요하다. . java -version . No Java runtime present, requesting install.라는 메세지를 받으면, 자바가 설치 되지 않은 것이다. . . 추가 정보를 눌러주면 설치 페이지로 이동한다. . . JDK Download를 눌러준 다음, . . macOS Installer에 해당하는 dmg파일을 다운로드 후 설치를 진행한다. . &#49324;&#52825; &#50672;&#49328;: &#45208;&#47672;&#51648;( %% ) . 10%%3 . 1 . &#45436;&#47532; &#50672;&#49328;: OR( | ), AND( &amp; ) . TRUE | TRUE . TRUE . TRUE | FALSE . TRUE . FALSE | FALSE . FALSE . TRUE &amp; TRUE . TRUE . TRUE &amp; FALSE . FALSE . FALSE &amp; FALSE . FALSE . TRUE # 1 . TRUE . FALSE # 0 . FALSE . TRUE + FALSE . 1 . TRUE + TRUE . 2 . &#47928;&#51228; 1 . 다음의 논리 연산에 대한 올바른 결과를 고르시오. . a. 11 != 10 . b. 30 &gt; 50 | 100 &gt; 1000 . TRUE, FALSE . &#48320;&#49688; . &lt;- 를 이용한다. . a &lt;- 1 a . 1 . a = 1 a . 1 . A &lt;- 10 A + 20 . 30 . B &lt;- A + 20 B . 30 . &#48320;&#49688; &#47749;&#47749; &#44508;&#52825; . 대소문자 구분 | 언더라인, dot, 숫자 사용 가능 | . gene.seq = &quot;ATGC&quot; gene.seq Gene.seq = &quot;AGGT&quot; gene.seq == Gene.seq # FALSE gene_seq = &quot;ATGC&quot; gene.seq == gene_seq # TRUE gene_seq_1 = &quot;AGGT&quot; gene_seq_1 == Gene.seq # TRUE . 변수명 시작을 dot로 가능 | . seq = &quot;ATGCTGGC&quot; .seq = &quot;ATGCTGGC&quot; seq == .seq # TRUE . &#45236;&#51109; &#54632;&#49688; . c() . vector 생성. combine의 약자 . c(1, 2, 3) . 1 2 3 . c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) . &quot;one&quot; &quot;two&quot; &quot;three&quot; . c(TRUE, FALSE, TRUE) . TRUE FALSE TRUE . seq(from, to, by) . 연속적인 숫자형 vector 생성 . by의 default값은 1이다. 얼마만큼의 간격으로 증가시킬 것인지 결정한다. . seq(1, 10, 2) . 1 3 5 7 9 . seq(1, 10) . 1 2 3 4 5 6 7 8 9 10 . 1:10 . 1 2 3 4 5 6 7 8 9 10 . seq(from, to, length.out) . length.out 파라미터는 몇 개의 숫자를 만들지를 결정한다. . variable &lt;- seq(0, 1, length.out=20) variable . . rep(object, times/each) . 반복적인 자료형 벡터 생성. 숫자형 데이터, 문자형 데이터 모두 반복시킬 수 있다. times는 반복할 횟수, each는 각 원소를 한 번에 반복할 횟수를 말한다. . rep(1, times=3) . 1 1 1 . rep(1:3, times=3) . 1 2 3 1 2 3 1 2 3 . rep(1:3, each=3) . 1 1 1 2 2 2 3 3 3 . rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), times=5) . &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; . sample(x, size, replace=F) . 무작위적으로 데이터를 생성하는 함수다. . x &lt;- 1:12 x sample(x) # 주어진 범위 내에서 무작위적인 숫자 생성 . . # 중복을 허용하여 무작위 숫자 생성 sample(x, replace=T) . . sample(45, size=6, replace=T) . . &#47928;&#51228; 2 . 10부터 50까지 정수형 벡터를 생성하시오. . 10:50 rep(10:50, 1) seq(10, 50, 1) . 다음 명령어를 실행했을 때의 올바른 출력 결과는? . rep(rep(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), time=2), each=2) . &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; . &#51088;&#51452; &#49324;&#50857;&#46104;&#45716; &#54632;&#49688;&#46308; . sum() . y &lt;- c(2, 4, 6, 8, 10) sum(y) . 30 . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) sum(x+y) . 21 . min() . y &lt;- c(2, 4, 6, 8, 10) min(y) . 2 . x&lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) min(x+y) . 3 . max() . y &lt;- c(2, 4, 6, 8, 10) max(y) . 10 . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) max(x+y) . 11 . mean() . y &lt;- c(2, 4, 6, 8, 10) mean(y) . 6 . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) mean(x+y) . + 연산이 먼저 수행되어, 3개의 요소에 대한 평균을 구하게 됨 . median() . y &lt;- c(2, 4, 6, 8, 10) median(y) . 6 . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) median(x+y) . 7 . log() . log(4, 2) # base가 2인 4의 로그 값 . 2 . y &lt;- c(4, 2) # base가 10인 4, 2 각각에 대한 상용로그 값 log(y) . 1.3862944 0.6931472 . log() 함수에 벡터를 넣으면 벡터의 각 요소에 대한 상용로그값이 나온다. . log2() . log2(4, 2) . Error in log2(4, 2) : 1를 필요로 하는 &#39;log2&#39;에 인자 2가 전달되었습니다 . log2(4) . 2 . y &lt;- c(4) log2(y) . 2 . y &lt;- c(4, 2) log2(y) . 2 1 . sqrt() . sqrt(2) . 1.414214 . y &lt;- c(2, 4, 6) sqrt(y) . 1.414214 2.000000 2.449490 . 벡터를 넣으면 각 요소에 대한 제곱근 결과를 낸다. . sd(), var() . var &lt;- 1:10 mean(var) . 5.5 . sd(var) . 3.02765 . var(var) # R에서는 함수의 이름을 변수이름으로 사용해도 상관없다. . 9.166667 . sort(), order() . var &lt;- c(7,1,4,6,7,21,7) sort(var) # 중복된 항목에 대해 중복 제거는 없음 . 1 4 6 7 7 7 21 . order(var) # 정렬된 항목의 인덱스를 출력 . 2 3 4 1 5 7 6 . sort(var, decreasing=TRUE) . 21 7 7 7 6 4 1 . order(var, decreasing=TRUE) . 6 1 5 7 4 3 2 . range() . x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) range(x) . 1 10 . x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 100) range(x) . 1 100 . length() . length(x) . 10 . rnorm() . x &lt;- rnorm(10) x . [1] 0.78781353 0.97180240 0.21801128 [4] -0.06918889 -0.47719415 0.80736879 [7] 1.33420280 0.25329343 0.08678522 [10] 0.17208155 . length(x) # 데이터의 길이 . [1] 10 . range(x) # 데이터의 범위 . [1] -0.4771941 1.3342028 . sort(x) # 데이터 정렬 . [1] -0.47719415 -0.06918889 0.08678522 [4] 0.17208155 0.21801128 0.25329343 [7] 0.78781353 0.80736879 0.97180240 [10] 1.33420280 . order(x) # 데이터 정렬 index . [1] 5 4 9 10 3 8 1 6 2 7 . &#44592;&#49696;&#53685;&#44228; . sum(x) . [1] 4.084976 . min(x) . [1] -0.4771941 . max(x) . [1] 1.334203 . median(x) . [1] 0.2356524 . mean(x) . [1] 0.4084976 . sd(x) . [1] 0.5486975 . var(x) . [1] 0.3010689 . class() . ## vector 자료형 class(c(1, &quot;one&quot;, TRUE)) . &quot;character&quot; . class(var1) . &quot;numeric&quot; . class(var2) . &quot;character&quot; . class(var3) . &quot;logical&quot; . tolower() . x = &quot;Hello, R ProGramming&quot; lower_x = tolower(x) lower_x . . toupper() . x = &quot;Hello, R ProGramming&quot; upper_x = toupper(x) upper_x . . substr(str, start, stop) . x &lt;- &quot;Hello World&quot; cutted_x &lt;- substr(x, start=7, stop=11) cutted_x . . strsplit(x, split) . x의 자리에는 스칼라, 벡터, 행렬, 리스트, 데이터프레임 등이 올 수 있다. split에는 구분하고자 하는 구분자를 넣어준다. strplit() 함수는 최종적으로 리스트로 결과를 반환한다. . x &lt;- &quot;Hello World&quot; cut &lt;- strsplit(x, &quot; &quot;) cut cut[1] cut[[1]][1] # 리스트를 호출할 땐, 항상 대괄호를 두 번 써야하는 것 같다. cut[[1]][2] . . paste() . 구분자를 기준으로 하나의 문장으로 결합한다. 구분자가 주어지지 않을 경우 공백이 기본으로 사용된다. . x &lt;- c(&quot;Hello&quot;, &quot;World&quot;, &quot;This&quot;, &quot;is&quot;, &quot;R&quot;, &quot;Programming&quot;) paste(x) . . paste0() . paste0(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) . . &#47928;&#51088;&#50676; &#44208;&#54633; . x = c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) y = paste(x[1], x[2]) y . . y = paste(x[1], x[2], sep=&quot;-&quot;) y . . y = paste(x[1], x[2], sep=&quot;,&quot;) y . . y = paste(x, collapse=&quot;,&quot;) y . . grep() . 찾으려는 값이 어느 인자에 있는지를 알려준다. . x = c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) grep(&quot;a&quot;, x) # &quot;a&quot;는 변수 x의 세 번째 인자인 &quot;Programming&quot;에 있다. . . x = c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) grep(&quot;a|e&quot;, x) . . x = c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) grep(&quot;p&quot;, x, ignore.case=T) # 대소문자에 상관없이 찾으려면 ignore.case=T로 한다. . . replace() . x = seq(1, 10, by=1) y = replace(x, x&gt;5, 10) # 5보다 큰 값들은 10으로 교체한다. y . . which() . y = c(T, T, F, T) y which(y) # TRUE에 해당하는 곳의 위치를 알려준다. . . &#51665;&#54633; &#50672;&#49328; . x = seq(2, 8, by=1) y = seq(5, 10, by=1) x y union(x, y) intersect(x, y) setdiff(x, y) # x-y. 즉 y에서 교집합에 해당하는 원소들을 뺀 결과 setdiff(y, x) # y-x a = c(&quot;TP53&quot;, &quot;APOE&quot;, &quot;BRCA1&quot;, &quot;BRCA2&quot;, &quot;MDK1&quot;, &quot;CTNNB1&quot;) b = c(&quot;TP53&quot;, &quot;MDK1&quot;, &quot;ARID1A&quot;, &quot;CTNNB1&quot;, &quot;TLR2&quot;) union(a, b) intersect(a, b) setdiff(a, b) # a-b setdiff(b, a) # b-a . . unique() . 주어진 데이터 내에서 중복되지 않은 데이터를 출력 . x = c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;c&quot;, &quot;e&quot;, &quot;f&quot;) x unique(x) . . match() . x = c(1,2,3,4,5) y = c(2,5,7,8,9) match(x, y) # x를 기준으로 y와 동일한 원소의 위치를 알려준다. match(y, x, nomatch = 0) # 일치하지 않는 항목에 대해서는 NA 대신 0로 채운다. . . is.element() . x = seq(1:5) y = c(2,5,7,8,9) is.element(x, y) # x를 기준으로, x의 각 원소가 y에 있는지를 각각에 대해 검사한 후, T/F 결과를 낸다. . . apply() . 행렬이나 데이터프레임에서 사용 가능 . x = matrix(1:50, nrow=10, ncol=5) colnames(x) = rep(paste(&quot;sample&quot;, 1:5, sep=&quot;&quot;)) rownames(x) = rep(paste(&quot;gene&quot;, 1:10, sep=&quot;&quot;)) x apply(x, 1, mean) # 행(=1)에 대한 평균값 apply(x, 2, mean) # 열(=2)에 대한 평균값 apply(x, 2, sum) #행(=1)에 대한 합계 . . rowMeans(x) colMeans(x) colSums(x) . . &#47928;&#51228; 3 . 다음 중 다른 출력 결과를 보이는 것은? . paste(c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;), sep=&quot; &quot;) paste(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;) paste(c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;), collapse=&quot; &quot;) paste(&quot;Hello&quot;, &quot;R&quot;, &quot;Programming&quot;, sep=&quot; &quot;) . 다음 코드 실행 결과, 마지막으로 출력되는 결과는? . x = c(10, 12, 7, 11, 6, 8, 9, 3, 4, 1, 2, 5) x[5] = 27 y = sort(x) z = order(y) z . 다음 명령어를 실행했을 때 출력되는 결과는? . x = c(10, 12, 7, 11, 6, 8, 9, 3, 4, 1, 2, 5) x[5] = 27 y = sort(x) z = order(y) z . 다음 명령어를 실행했을 때 출력되는 결과와 같은 결과를 출력하기 위한 명령어는? . x = matrix(1:50, nrow=5, ncol=10) colnames(x) = rep(paste(&quot;Group&quot;, LETTERS[1:10], sep=&quot;&quot;)) rownames(x) = rep(paste(&quot;Treat&quot;, 1:5, sep=&quot;&quot;)) apply(x, 1, mean) # 답 rowMeans(x) . &#51088;&#47308;&#54805; . &#44592;&#48376; &#51088;&#47308;&#54805; . R의 자료형은 크게 세 가지로 구분 가능하다; 숫자(Numeric), 문자(Character), 논리형(Logical). Numeric 자료형에는 정수와 실수가 모두 포함되며, Character 자료형을 쓸 땐 큰 따옴표나 작은 따옴표를 반드시 표기해야 한다. 논리형은 TRUE 또는 T, FALSE 또는 F로만 표기할 수 있다. . # R에서 주석은 #으로 표기 1 100 1000 &quot;abc&quot; &#39;abc&#39; abc # -&gt; 정의되지 않은 변수일 경우엔 오류 발생 TRUE FALSE T F 1, 100, 1000 # -&gt; 오류. 동일한 타입의 자료형은 한 줄에 하나씩만 가능 . &#44536; &#50808; &#51088;&#47308;&#54805; . Vector, Matrix, Data Frame, List, Factor | . &#51088;&#47308;&#54805;: &#48289;&#53552;(vector) . vector 자료형을 생성하는 방법: c()함수 이용. c: combine의 약어 . vector의 생성은 (), 호출은 [] . vector &#49373;&#49457; . c(1, 2, 3) . 1 2 3 . c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) . &quot;one&quot; &quot;two&quot; &quot;three&quot; . c(TRUE, FALSE, TRUE) . TRUE FALSE TRUE . vector&#47484; &#48320;&#49688;&#50640; &#51200;&#51109; . var1 &lt;- c(1, 2, 3) var2 &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) var3 &lt;- c(TRUE, FALSE, TRUE) . var1 . 1 2 3 . var2 . &quot;one&quot; &quot;two&quot; &quot;three&quot; . var3 . TRUE FALSE TRUE . &#50668;&#47084; &#51088;&#47308;&#54805;&#51060; &#49438;&#51060;&#47732; &#47924;&#51312;&#44148; character&#47196; &#51064;&#49885;&#54620;&#45796;. . c(1, &quot;one&quot;, TRUE) . &quot;1&quot; &quot;one&quot; &quot;TRUE&quot; . &#48289;&#53552; &#44036; &#50672;&#44208; . x &lt;- c(1,2,3) x . 1 2 3 . y &lt;- c(4,5,6,7) y . 4 5 6 7 . z &lt;- c(x, y) z 1 2 3 4 5 6 7 . &#48289;&#53552; &#44050; &#54840;&#52636; . []을 사용한다. 벡터의 요소는 **1**부터 시작함. 0번 인덱스는 자료형을 나타낸다. . var &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) var[0] . character(0) . var[1] . &quot;a&quot; . var[2] . &quot;b&quot; . var[3] . &quot;c&quot; . &#51312;&#44148;&#48512; &#44050; &#54840;&#52636; . var &lt;- 1:10 var . 1 2 3 4 5 6 7 8 9 10 . var &gt; 5 . FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE . var[var &gt; 5] . 6 7 8 9 10 . var[var&lt;3|var&gt;7] . 1 2 8 9 10 . var[var&gt;3&amp;var&lt;7] . 4 5 6 . &gt; 연산자 자체는 Logical 자료형의 형태로 결과를 출력한다. []와 함께 &gt; 연산자를 함께 사용하면, 값 자체에 대한 조건에 맞는 결과를 출력한다. . &#51064;&#45937;&#49905; &#50672;&#49328; . 파이썬과는 다르게 인덱싱 연산에서 차이가 있다. 파이썬은 from(included), to(excluded)인 반면, R은 from과 to 모두 included다. 또한 -기호에도 차이가 있는데, 파이썬에서는 뒤에서부터 호출하게 하는 연산자라면, R에서는 제외시키는 연산자다. . var &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) var[1:2] . &quot;a&quot; &quot;b&quot; . var[1:3] . &quot;a&quot; &quot;b&quot; &quot;c&quot; . var[c(1,3)] . &quot;a&quot; &quot;c&quot; . var[-1] . &quot;b&quot; &quot;c&quot; . var[-c(1,3)] . &quot;b&quot; . &#48289;&#53552; &#50672;&#49328; . 숫자형 벡터끼리는 벡터 내 각 요소 별로 연산이 가능하다. . &#48289;&#53552; &#45236; &#50672;&#49328; . var &lt;- c(1, 3, 5, 7, 9) var . 1 3 5 7 9 . var + 2 . 3 5 7 9 11 . var - 2 . -1 1 3 5 7 . var * 2 . 2 6 10 14 18 . var / 2 . 0.5 1.5 2.5 3.5 4.5 . (var + 2)*4 . 12 20 28 36 44 . &#48289;&#53552; &#44036; &#50672;&#49328; . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6) x . 1 3 5 . y . 2 4 6 . x+y . 3 7 11 . x-y . -1 -1 -1 . x*y . 2 12 30 . x/y . 0.5000000 0.7500000 0.8333333 . 벡터의 길이가 다를 경우 연산은 불가능하다. . x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 6, 8, 10) x+y 3 7 11 9 13 경고메시지(들): In x + y : 두 객체의 길이가 서로 배수관계에 있지 않습니다 . &#51088;&#47308;&#54805;: &#47532;&#49828;&#53944;(list) . 서로 다른 길이의 벡터 또는 서로 다른 데이터 구조들을 모아놓은 집합이다. 행렬은 같은 데이터 타입만 허용했었으나, 리스트는 데이터프레임과 동일하게 여러 자료형을 허용한다. R 자료형 중에서 가장 유연한 자료형이라고 할 수 있다. . 리스트 자료형을 만들 땐 함수 list()를 이용한다. . # 서로 다른 타입의 자료형의 벡터들을 만든다. a&lt;-c(1,2,3) b&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) c&lt;-c(TRUE,FALSE) # list() 함수를 이용하여 각 벡터를 리스트화하여 변수에 저장한다. # 만들 때 벡터가 담고 있는 데이터에 대한 정보를 직접 기술해 줄 수도 있다. list1 &lt;- list(a, b, c) list1 list2 &lt;- list(id=a, name=b, positive=c) list2 # 리스트에서 값의 추출은 다음과 같이 한다. # 호출 시, 인덱스 번호로 호출할 수도 있고, 리스트를 만들 때 기술했던 정보를 이용해 호출할 수도 있다. list2[[1]] list2[[3]] list2[[&quot;name&quot;]] list2(달러표시)name class(list1[1]) class(list2[1]) . . 인덱싱 연산도 가능하다. . list1[c(1,3)] # 리스트의 첫 번째와 세 번째를 출력한다. . . [[1]]과 [[2]] 에 속지 말 것. 리스트의 번호가 아니다. . x = seq(5) y = c(&quot;one&quot;, &quot;two&quot;) z = matrix(1:10, nrow=2, ncol=5) list.all = list(x, y, z) list.all list.all[[1]] list.all[[1]][1] list.all[[2]] list.all[[3]][[1,3]] names(list.all) = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # 리스트는 굉장히 유연하고 다양한 타입의 데이터를 닮을 수 있기 때문에 이렇게 이름을 지정해주는 게 좋다. list.all(달러표시)A . . &#51088;&#47308;&#54805;: &#54057;&#53552;(Factor) . 팩터는 벡터와 유사하다. 다만 level 값을 가지며, 범주형 데이터에 주로 사용된다. . 범주형 데이터: Male/Female, up/down/left/right, A/B/C/D | . level 값에 벗어나는 데이터가 입력되면 NA 값으로 처리된다. . 값의 추출은 벡터와 동일하게 []를 쓴다. . 먼저, 벡터를 만들어 보자. . tool &lt;- c(&quot;C&quot;, &quot;Python&quot;, &quot;Java&quot;) tool . . 이 벡터를 팩터로 변환하기 위해서는 factor() 함수를 이용한다. . factor_var &lt;- factor(tool) factor_var class(factor_var) . . level의 순서를 직접 다음과 같이 직접 지정해 줄 수 있다. . factor_var &lt;- factor(tool, level=(&quot;R&quot;, &quot;Python&quot;, &quot;JAVA&quot;)) factor_var . . 자료형을 순서대로 숫자로 변환하고 싶다면, as.numeric() 함수를 사용한다. . tool &lt;- as.numeric(factor_var) tool . &#51088;&#47308;&#54805; . &#51088;&#47308;&#54805;: &#54665;&#47148;(matrix) . 행렬은 동일한 자료형의 집합이며, 2차원의 데이터 구조를 말한다. . . &#54665;&#47148; &#49373;&#49457; . matrix()&#47196; &#54665;&#47148; &#49373;&#49457; . matrix(1:9, nrow=3, ncol=3) # 행과 열의 개수를 지정해주어야 한다. . . 열부터 값이 채워지는 것을 확인할 수 있다. 즉, byrow 파라미터의 default값은 FALSE다. 따라서 이를 TRUE로 설정하면 행부터 값이 채워지는 것을 확인할 수 있다. . . &#48289;&#53552;&#47196; &#54665;&#47148; &#49373;&#49457;: cbind(), rbind() . cbind는 column bind의 약자이며, rbind는 row bind의 약자이다. . x &lt;- c(1,2,3) y &lt;- c(4,5,6) z &lt;- c(7,8,9) . mat1 &lt;- cbind(x,y,z) mat1 . . mat2 &lt;- rbind(x,y,z) mat2 . . cbind(mat1, c(10, 11, 12)) . . rbind(mat2, c(10, 11, 12)) . . rbind(mat1, mat2) . . &#54665;&#47148;&#51032; column&#44284; row&#51032; &#51060;&#47492; &#54869;&#51064; &#48143; &#48320;&#44221; . column&#51032; &#51060;&#47492;&#44284; row&#51032; &#51060;&#47492; &#54869;&#51064; . column은 보통 R에는 &#39;변수&#39;로 보는 경향이 있다. . colnames(mat1) rownames(mat1) . column&#51032; &#51060;&#47492;&#44284; row&#51032; &#51060;&#47492; &#48320;&#44221; . colnames(mat1)&lt;-c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) rownames(mat1) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) mat1 colnames(mat1) rownames(mat1) . . . &#54665;&#47148;&#50640;&#49436; &#44050;&#51032; &#52628;&#52636; . 벡터에서와 마찬가지로 []를 사용하되, ,를 사용하여 행과 열을 구분한다. . mat1 mat1[1,3] mat1[2,2] mat1[1,] mat1[,2] . . 행렬값 호출은 인덱스 또는 행이나 열의 이름을 직접 기술하여 호출 가능하다. . mat1[1,3] mat1[&quot;row1&quot;, &quot;col3&quot;] . . mat1[&quot;row3&quot;,c(&quot;col1&quot;,&quot;col3&quot;)] . . &#54665;&#47148; &#50672;&#49328; . &#54665;&#47148; &#45236; &#50672;&#49328; . mat1 mat1+2 mat1-2 mat1*2 mat1/2 . . &#54665;&#47148;&#45180;&#47532; &#50672;&#49328; . mat2 &lt;- cbind(c(10,3,9), c(3,4,1), c(2,5,7)) mat2 mat1 mat1 + mat2 mat1 - mat2 mat1 / mat2 mat1 * mat2 . . cbind(), rbind() . vec1 = c(1:5) vec2 = c(6:10) vec3 = c(11:15) vec1 vec2 vec3 mat1 = cbind(vec1, vec2, vec3) mat1 dim(mat1) class(mat1) mat2 = rbind(vec1, vec2, vec3) mat2 . . rownames(), colnames() . rownames(mat1) = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) colnames(mat1) = c(&quot;col01&quot;, &quot;col02&quot;, &quot;col03&quot;) mat1 colnames(mat2) = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) mat2 . . matrix&#50640;&#49436; colnames&#50752; rownames &#51648;&#51221;&#54616;&#44592; . x = matrix(1:25, nrow=5, ncol=5) x colnames(x)=rep(paste(&quot;sample&quot;, 1:5, sep=&quot;_&quot;)) rownames(x)=rep(paste(&quot;gene&quot;, 1:5, sep=&quot;_&quot;)) x x[,4] # 4열만 출력 x[2,] # 2행만 출력 x[2:3, 1:4] . &#51088;&#47308;&#54805;: &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;(DataFrame) . 외관상으로는 행렬과 유사하다. 다만, 서로 다른 자료형 벡터로 구성할 수 있다는 점이 차이점이다. . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51032; &#49373;&#49457; . data.frame() &#54632;&#49688; &#51060;&#50857; . 먼저, 서로 다른 자료형의 벡터들을 만든다. . vec1 &lt;- c(1,4,7) vec2 &lt;- c(&quot;one&quot;,&quot;four&quot;,&quot;seven&quot;) vec3 &lt;- c(TRUE,TRUE,FALSE) . 이 벡터들을 data.frame() 함수를 이용하여 데이터프레임 자료형으로 만들 수 있다. . df &lt;- data.frame(vec1, vec2, vec3) # 벡터들을 파라미터로 넘기면 끝이다. . 결과물을 보면, 마치 cbind() 한 것과 같이 나온다. . df . . &#47928;&#51228; . 다음의 데이터프레임 df로부터 컬럼 col1, col2, col3의 값이 3개의 컬럼에서 모두 5 이상인 행을 추출하시오. . . name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) col1 = c(10, 1, 10, 5) col2 = c(1, 5, 9, 9) col3 = c(2, 8, 1, 8) df = data.frame(name, col1, col2, col3) df rowname = c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;) rownames(df) = rowname df df[col1&gt;=5 &amp; col2&gt;=5 &amp; col3&gt;=5,] . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#50640;&#49436; &#44050; &#52628;&#52636; &#48143; column, row&#51060;&#47492; &#51312;&#54924;/&#48320;&#44221; . 행렬과 동일하다. . &#50676;(column) &#52628;&#52636; . vec1 &lt;- c(1,4,7) vec2 &lt;- c(&quot;one&quot;,&quot;four&quot;,&quot;seven&quot;) vec3 &lt;- c(TRUE,TRUE,FALSE) df &lt;- data.frame(vec1, vec2, vec3) df[,1] df[,2] df[,&quot;vec3&quot;] . . &#53945;&#51221; column&#50640; &#45824;&#54620; &#44050; &#52628;&#52636; . df df(달러표시)vec2 df(달러표시)vec2[2:3] . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#48143; &#45936;&#51060;&#53552; &#44061;&#52404; &#53456;&#49353; &#49892;&#49845; . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51032; &#49373;&#49457; . 50&#44060;&#51032; &#48156;&#54788;&#47049;&#50640; &#45824;&#54620; 2&#52264;&#50896; &#45936;&#51060;&#53552; &#49373;&#49457; . 유전자 데이터를 임의로 생성 . gene=paste0(&quot;gene&quot;, 1:50) gene . paste0() 함수는 문자열과 문자열을 공백없이 연결시키는 함수다. 예를 들어, &quot;gene&quot;과 &quot;1&quot;을 붙여 gene1이 되는 방식이다. paste() 함수도 있다. . . 5&#44060; &#49368;&#54540; &#51060;&#47492; &#48289;&#53552; &#49373;&#49457; . sample=paste0(&quot;sample&quot;, 1:5) sample . . 250&#44060; &#51221;&#44508;&#48516;&#54252; &#45212;&#49688;&#47196; &#54665;&#47148;&#51012; &#49373;&#49457;&#54620;&#45796;. &#50676;&#51008; &#50976;&#51204;&#51088; &#49688;, &#54665;&#51008; &#49368;&#54540;&#51032; &#49688; &#51060;&#45796;. . expression = matrix(rnorm(250), nrow = 50, ncol=5) expression . . &#50676; &#51060;&#47492;&#51012; sample &#48289;&#53552;&#47196; &#51648;&#51221;&#54620;&#45796;. . colnames(expression) = sample . &#54665; &#51060;&#47492;&#51012; gene &#48289;&#53552;&#47196; &#51648;&#51221;&#54620;&#45796;. . rownames(expression) = gene . &#44208;&#44284;&#47932;&#51012; &#52636;&#47141;&#54644;&#48376;&#45796;. . expression . . &#48289;&#53552;&#50752; &#54665;&#47148;&#51012; &#48537;&#50668; &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51004;&#47196; &#49373;&#49457;&#54620;&#45796;. . exam.df = data.frame(gene, expression) exam.df . . &#45936;&#51060;&#53552; &#44061;&#52404; &#53456;&#49353; . dim(), ndim(), nrow(), ncol(), length(): &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51032; &#52264;&#50896; &#48143; &#44396;&#51312; &#54028;&#50501;&#54616;&#44592; . dim(exam.df) . [1] 50 6 . dim() 함수의 결과는 str() 함수로 파악이 전부 가능한 정보다. 여기서 str은 string이 아니라 structure다. . 데이터 객체의 차원만 알고 싶거나 아니면 데이터 객체의 차원을 벡터로 해서 indexing해서 쓸 일이 있을 때 이 함수를 사용한다. . ndim(exam.df) . [1] 50 6 . nrow(exam.df) . [1] 50 . ncol(exam.df) . [1] 5 . length(exam.df) . [1] 6 . length() 함수는 column의 개수(변수의 개수)를 출력한다. 해당 column의 obs(observataion)의 개수를 보고자 할 땐 다음과 같이 (달러표시)를 쓴다. 벡터 자료형에서도 length를 이용하여 그 길이를 파악했었다. . length(exam.df(달러표시)gene) . [1] 50 . head()&#50752; tail() . head()함수 (또는 tail() 함수)는 1차원 또는 2차원의 행렬 또는 데이터프레임의 첫 6줄 (또는 끝 6줄;디폴트값)을 출력하는 함수다. 관측치가 수백만, 수천만 건인 경우는 상위 혹은 하위 몇 개만 미리보기를 할 수 있게 해준다. . head(exam.df) . . exam.df[1:6,] # 동일한 코드 . 출력하기를 원하는 행의 개수를 파라미터로 지정할 수 있다. . head(exam.df, n = 10) . . tail(exam.df, n = 10) . . &#54665;&#47148; &#46608;&#45716; &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51032; &#44396;&#51312; &#54028;&#50501;&#54616;&#44592; . R 데이터 객체를 신규로 생성했거나, 외부에서 불러왔거나, 아니면 R 패키지에 내장되어 있는 데이터 셋을 활용한다고 했을 때 데이터 객체의 현황, 특성에 대해서 파악하는 것이 필요하다. . str(객체) : 데이터 구조, 변수 개수, 변수 명, 관찰치 개수, 관찰치의 미리보기 등 . str(exam.df) . . class(obj) : &#45936;&#51060;&#53552; &#44061;&#52404; &#44396;&#49457;&#50836;&#49548;&#51032; &#49549;&#49457; &#54869;&#51064; . class(exam.df) . [1] &quot;data.frame&quot; . sapply(obj, func): object&#50640; function&#51012; &#51201;&#50857; . sapply(exam.df, class) . . names(): &#45936;&#51060;&#53552; &#44061;&#52404; &#44396;&#49457;&#50836;&#49548; &#51060;&#47492; . 데이터 객체의 변수명을 알고 싶고, indexing해서 사용하고 싶으면 names() 함수를 사용한다. . names(exam.df) . [1] &quot;gene&quot; &quot;sample1&quot; &quot;sample2&quot; &quot;sample3&quot; &quot;sample4&quot; &quot;sample5&quot; . summary(), stat.desc(), describe(): &#50672;&#49549;&#54805; &#48320;&#49688;&#51032; &#50836;&#50557; &#53685;&#44228; . summary() . base package의 summary() 함수는 중심화 경향과 퍼짐정도에 대해서 quick 하게 볼 수 있는 통계량들을 제공한다. . summary(exam.df) . . stat.desc() 함수나 describe() 함수는 별도의 패키지를 설치해야 쓸 수 있다. . stat.desc() . 패키지 설치는 다음과 같이 진행한다. . install.packages(&quot;pastecs&quot;) . 설치한 패키지를 불러오는 방법은 다음과 같다. . library(pastecs) . stat.desc(exam.df) . . stat.desc() 함수의 옵션 별로 제공하는 통계량은 아래와 같다. . basic = TRUE : 관측치 개수, null 개수, NA 개수, 최소값, 최대값, 범위, 합 | desc = TRUE : 중앙값, 평균, 분산, 표준편차, 변이계수 | norm = TRUE : 왜도, 첨도, 정규성 검정통계량, 정규성 검정 P-value | p = 0.90 : 신뢰계수 90% (유의수준 10%) 값 =&gt; 90% 신뢰구간은 평균 +- CI.mean.0.9 값 | . stat.desc() 함수에서 IQR, quantile은 제공되지 않는다. . describe() . describe() 함수에 대해서도 다음과 같이 작업할 수 있다. . install.packages(&quot;psych&quot;) library(psych) describe(exam.df) . . describe() 함수는 summary() 보다는 많고 stat.desc() 보다는 적은 기술통계량(관측값 개수(n), 평균(mean), 표준편차(sd), 중앙값(median), 절삭평균(10% 절삭평균), 중위값절대편차(from 중위값) (MAD, median absolute deviation), 최소값(min), 최대값(max), 범위(range), 왜도(skew), 첨도(kurtosis), 표준오차(SE, standard error))을 보여준다. . 중위값 절대 편차 (MAD, median absolute deviation) = median(|X - median(X)|) * 1.4826 1.4826은 scaling factor (또는 normalizing constant) 이며, 정규적인 자료에서 scaling factor를 곱해주면 표준편차와 비슷해진다. | . &#50672;&#49549;&#54805; &#48320;&#49688;&#51032; &#44536;&#47353;&#48324; &#50836;&#50557; &#53685;&#44228; . 종류: tapply(var, factor, summary), aggregate(), summaryBy(), describe.by() . tapply(variable, factor, summary) . 연속형 데이터셋을 이용하여 통계를 내기 위하여 MASS 패키지를 설치하고 Cars93 데이터셋을 불러온다. . install.packages(&quot;MASS&quot;) library(MASS) str(Cars93) with(Cars93, tapply(Price, Type, summary)) . . tapply() 함수를 사용하면, 특정 variable을 요인(factor)별로 summary() 함수를 적용한 통계적으로 파악할 수 있다. 위의 예는 Cars93 데이터셋에 대한 Type별 Price에 대한 summary 요약 통계다. . rowSums(matrix &#51088;&#47308;&#54805;), colSums(matrix &#51088;&#47308;&#54805;) . 숫자형 자료형으로 이루어진 자료에 대해서만 가능한 연산이다. . expression class(expression) rowSums(expression) colSums(expression) . . 그 외의 자료형에 대해 해당 함수를 적용하면 에러가 뜬다. 만약 다음과 같이 gene column에 문자열이 들어가 있다고 해보자. . exam.df . . 그럼 다음과 같은 에러를 마주한다. . . 이 때, gene column을 제거하면 숫자로만 이루어진 데이터이므로, 이를 제거해보자. . rowSums(exam.df[,-1]) # 첫 번째 열을 제거(-)하겠다. rowMeans(exam.df[,-1]) . . . rowMeans(matrix &#51088;&#47308;&#54805;), colMeans(matrix &#51088;&#47308;&#54805;) . rowMeans(expression) colMeans(expression) . . rowMeans()를 통해 얻은 결과물 중 0보다 큰 값을 갖는 행을 찾으려면, 크기 연산자를 사용한다. . rowMeans(expression) &gt; 0 . . 위 조건에 맞는 행만 추출하여 새로운 변수에 저장하기 위해 다음가 같이 한다. . exam.df2 = exam.df[rowMeans(expression) &gt; 0 , ] exam.df2 . ,를 기준으로 왼쪽은 행, 오른쪽은 열이므로 열은 제외시키려는 조건이 없음을 의미한다. . . nrow()를 통해 총 몇 개의 행이 이에 해당하는지 살필 수 있다. . nrow(exam.df2) . 26 . 이들 중 어떤 gene이 그러한지 살펴보기 위해 다음과 같이 (달러표시)와 column이름을 이용하여 알아낼 수 있다. . gene2 = exam.df2(달러표시)gene . . subset(data.frame, conditions) . subset() 함수를 이용해도 원하는 조건의 행을 추출할 수 있다. subset() 함수의 첫번째 파라미터로는 데이터프레임이 온다. 행렬 자료형은 올 수 없다. 두번째 파라미터로는 한 개 이상의 조건이 온다. 조건으로 명시할 column의 이름은 (달러표시)를 이용하여 기술해도 되고 그냥 column의 이름만 기술해도 된다. . 실습에서 하려는 것은 다음의 데이터에서 0보다 큰 값을 추출하는 것이다. . exam.df(달러표시)sample1 . . subset() 함수를 사용하여 조건에 맞는 행을 추출할 수 있다. . filtered.exam.df &lt;- subset(exam.df, exam.df(달러표시)sample1&gt;0) filtered.exam.df filtered.exam.df &lt;- subset(exam.df, sample1&gt;0) filtered.exam.df . . . 여러 조건을 줄 수도 있다. . . 조건에 의해 뽑힌 행에 해당하는 유전자가 어떤 것인지 알아보기 위해 다음의 코드를 실행한다. . filtered.exam.df(달러표시)gene . . names = rep(c(paste(&quot;C&quot;, 1:5, sep=&quot;&quot;), paste(&quot;R&quot;, 1:5, sep=&quot;&quot;))) names value = seq(5, 50, by=5) value batch = rep(paste(&quot;batch&quot;, 1:10, sep=&quot;&quot;)) batch df = data.frame(names, value, batch) dim(df) df . . &#54632;&#49688; . 함수는 어떤 값을 넣었을 때, 지정된 프로세스에 따라 인풋을 처리한 결과를 내는 것을 말한다. 주로 반복적인 처리가 필요할 경우 함수로 만들어 사용하게 된다. R에는 내장 함수 외에 사용자 정의 함수도 가능하다. . . f_01 = function(x) { return(x) } f_01(1) . [1] 1 . f_02 = function(x) { output = x+50 return(output) } f_02(20) . [1] 70 . x = matrix(1:25, nrow=5, ncol=5) colnames(x) = rep(paste(&quot;sample&quot;, 1:5, sep=&quot;&quot;)) rownames(x) = rep(paste(&quot;gene&quot;, 1:5, sep=&quot;&quot;)) x x[,2] stat_f(x[,2]) x[4,] stat_f(x[4,]) . . res = apply(x, 2, stat_f) # 2: 열 res . . &#48152;&#48373;&#47928; . for(var in seq) { expression } . for(i in 1:5) { print(rep(i,i)) } . . for(year in 2015:2020) { print(paste(&quot;The year is&quot;, year)) } . . x = c(1:10) for(i in x){ y = 2*i+3 print(y) } . . for(i in 2:5){ for(j in 1:5){ cat(i, &quot;*&quot;, j, &quot;=&quot;, i*j, &quot; n&quot;) } } . . &#48152;&#48373;&#47928; &#50696;&#51228; &#53076;&#46300; . for(time in 1:6){ for(minute in seq(10, 25, length.out=10)){ cat(&quot;It is&quot;, time, &quot;hour&quot;, minute, &quot;minute&quot;, &quot; n&quot;) } } . &#51312;&#44148;&#47928; . x = 4 if(x&gt;0) print(sqrt(x)) #2 x = -0.2 if(x&lt;0) print(1+x) else print(x) # 0.8 x = 0.5 if(x&lt;0) print(1+x) else print(x) # 0.5 ifelse(x&lt;0, 1+x, x) . . gender = c(rep(&quot;male&quot;, 30), rep(&quot;female&quot;, 20)) gender ifelse(gender==&quot;male&quot;, 0, 1) . . File Read &amp; Write . 데이터 분석 작업을 수행할 땐 외부에서 데이터를 불러와 작업하는 경우가 많다. 주로 csv파일이나 xlsx파일을 불러오게 된다. . File Read . 파일을 읽을 때 주로 사용할 함수는 read.delim(), read.table, read.csv()이다. 이들 함수들은 기본적으로 세 개의 파라미터를 갖는다. 첫 번째 파라미터인 file은 파일 경로다. 두 번째 파라미터인 header는 첫 번째 행을 헤더로 처리할 것인지를 결정하는 파라미터이며, 마지막으로 sep파라미터는 구분자에 대한 정보를 주는 것으로서 &quot; t&quot;는 tab을, &quot; &quot;은 공백을 의미한다. . &#49892;&#49845; &#53076;&#46300; 1 . # read.delim(), read.table() ex_tab=read.delim(file = &quot;extdata/example_tab.txt&quot;, header = T, sep = &quot; t&quot;) head(ex_tab) ex_tab2=read.table(file = &quot;extdata/example_tab.txt&quot;, header = T, sep = &quot; t&quot;) head(ex_tab2) head(read.delim(file = &quot;extdata/example_tab.txt&quot;)) # read.csv() ex_csv=read.csv(file = &quot;extdata/example.csv&quot;, header = T) head(ex_csv) . . &#49892;&#49845; &#53076;&#46300; 2 . 엑셀 파일에 해당하는 파일을 읽는 함수는 read.xlsx()다. 해당 파일을 읽을 땐, 파일 내에 여러 개의 시트가 있을 수 있으므로, 시트의 번호를 기입해주어야 한다는 점에 주의한다. . # read.xlsx() read.xlsx() library(xlsx) ex_xlsx=read.xlsx(file = &quot;extdata/example.xlsx&quot;, sheetIndex = 1) . . File Write . 파일을 쓸 때 주로 사용하는 함수는 write.table(), write.csv()이다. 파라미터는 6개이며, 파일로 저장할 변수의 이름, 확장자를 포함한 파일의 경로와 이름을 지정하는 file, 문자열에 쌍따옴표를 포함할지 여부를 논리값으로 지정하는 quote, 구분자(&quot; t&quot;, &quot; &quot;)를 지정하는 seq, 행 이름을 파일에 기록할지를 논리값으로 지정하는 row.names, 열 이름을 파일에 기록할지를 논리값으로 지정하는 col.names가 있다. . &#49892;&#49845; &#53076;&#46300; 1 . # write.table() head(ex_csv) class(ex_csv) write.table(x = ex_csv, file = &quot;output/ex.txt&quot;) write.table(x = ex_csv, file = &quot;output/ex.txt&quot;, sep = &quot; t&quot;, quote = F) write.table(x = ex_csv, file = &quot;output/ex.txt&quot;, sep = &quot; t&quot;, quote = F, row.names = F) # write.csv() write.csv(x = ex_csv, file = &quot;output/ex.csv&quot;, quote = F, row.names = F) . . output 폴더에 파일이 생성된 것을 확인할 수 있다. . . &#49892;&#49845; &#53076;&#46300; 2 . 엑셀 파일에 해당하는 파일을 쓰는 함수는 write.xlsx()다. . # write.xlsx() write.xlsx(x = ex_csv, file = &quot;output/ex.xlsx&quot;, row.names = F) ex_tab2=read.table(file = &quot;extdata/example_tab.txt&quot;, header = T, sep = &quot; t&quot;, skip = 10) head(ex_tab2) . . 마찬가지로 xlsx 파일이 output 폴더에 생성되었다. . . R data &#51200;&#51109; &#48143; &#48520;&#47084;&#50724;&#44592; . .rda 또는 .RData 확장자를 가진 파일이 R data이며, 해당 확장자를 가진 파일은 R에서만 열 수 있게 되어있다. R data의 장점은 텍스트 파일에 비해 로딩시간이 짧고 이차원 데이터 뿐만 아니라 모든 변수에 대한 저장과 불러오기가 가능하다는 점이다. 주요 함수로는 save(), load()가 있다. . &#49892;&#49845; &#53076;&#46300; . # save() save(ex_csv, file = &quot;data/ex.rda&quot;) # load(), data() load(file = &quot;data/ex.rda&quot;) . . data 폴더에 .rda 확장자를 가진 R data가 생성된 것을 확인할 수 있다. . 만약 프로젝트 내에 data 폴더가 있다면 data() 함수를 통해 손쉽게 파일을 불러올 수 있다. 이는 R이 data 폴더를 자동으로 인식하기 때문에 가능하다. . &#49892;&#49845; &#53076;&#46300; . data(ex) . R plotting(&#49884;&#44033;&#54868;) . R basic graphics . R basic graphics는 R에서 기본적으로 제공되는 그래픽 패키지이다. 아래 그림과 같은 종류의 그래프들을 그릴 수 있다. . scatter plot . scatter plot은 두 변수에 대한 상관관계를 나타낼 때 주로 사용된다. 그래프를 그릴 때 사용되는 함수는 plot()이며, 상관관계를 나타낼 때 사용되는 함수는 cor()다. . 실습코드 . # scatter plot : plot() plot(x=2, y=1) plot(c(2,5), c(1,10)) # iris head(iris) plot(x = iris(달러표시)Sepal.Length, y = iris(달러표시)Sepal.Width) plot(x = iris(달러표시)Petal.Length, y = iris(달러표시)Petal.Width) cor(x = iris(달러표시)Sepal.Length, y = iris(달러표시)Sepal.Width) cor(x = iris(달러표시)Petal.Length, y = iris(달러표시)Petal.Width) . . . . . . line plot . line plot은 scatter plot의 각 점을 선으로 이어서 표현한 그래프라고 할 수 있다. 주로 시계열 데이터에서 시간의 흐름에 따른 변화를 시각적으로 표현해줄 때 사용한다. plot() 함수에 type 인자를 주어 표현 가능하다. . &#49892;&#49845; &#53076;&#46300; 1 . # line plot: plot( type = &#39;l&#39;) plot(c(2,5), c(1,10), type=&#39;l&#39;) plot(c(2,5), c(1,10), type=&#39;o&#39;) head(pressure) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, type=&#39;l&#39;) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, type=&#39;o&#39;) . . . . . . . . 산점도 포인트의 크기를 조절하고자 할 땐, cex 파라미터를 이용하며, 색을 바꾸고 싶을 땐 col 파라미터를 이용한다. . &#49892;&#49845; &#53076;&#46300; 2 . plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=2) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=0.5) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;red&#39;) . . . . . histogram . histogram은 연속적인 숫자형 데이터를 이용해 도수 분포를 표현하는 그래프이다. 내가 가진 데이터의 전체적인 분포나 경향을 확인하고자 할 때 사용한다. hist() 함수를 사용한다. . &#49892;&#49845; &#53076;&#46300; . # Histogram: hist() hist(iris(달러표시)Sepal.Length) hist(iris(달러표시)Sepal.Width) hist(iris(달러표시)Sepal.Length, breaks=20) x &lt;- matrix(rnorm(1000), nrow=100) class(x) hist(x) . . . . . . box plot . box plot은 주로 금융 데이터와 같은 시계열 데이터에서 주로 사용되는데, 연속형 자료에 대한 min, max, Q1, Q2, Q3의 다섯 가지 정보에 대한 요약된 정보를 상자와 선, 점으로 표현하는 그래프이다. . . 박스의 크기는 Q1, Q3값에 따라 결정되며, 가운데의 굵은 선은 median으로서 Q2값에 해당한다. 상자의 위 아래로 min, max에서 +-1.5IQR 처리된 값이 표현되며, 데이터의 이상치값은 별도로 점으로 찍힌다. . R에서 box plot을 그릴 수 있는 자료형은 숫자형 벡터, 행렬, 데이터프레임이 해당한다. 사용하는 함수는 boxplot()이다. . &#49892;&#49845; &#53076;&#46300; 1 . # Boxplot boxplot(iris(달러표시)Sepal.Length) boxplot(iris(달러표시)Sepal.Length, iris(달러표시)Sepal.Width, iris(달러표시)Petal.Length, iris(달러표시)Petal.Width) boxplot(iris[,1:4]) . . . . . &#49892;&#49845; &#53076;&#46300; 2 . 범주별로 box plot을 표현할 수도 있다. boxplot() 함수에 ~ 표시를 이용해 사용 가능하다. . # Boxplot: ~ Formula table(iris(달러표시)Species) boxplot(iris(달러표시)Petal.Length~iris(달러표시)Species) boxplot(Petal.Length~Species, data=iris) . . . . bar plot . bar plot은 범주형 데이터에 사용하며, 카테고리별로 빈도수나 백분율을 기둥의 높이로 표현하는 그래프다. barplot() 함수를 사용한다. . &#49892;&#49845; &#53076;&#46300; 1 . # Barplot head(BOD) ?BOD barplot(BOD(달러표시)demand) barplot(BOD(달러표시)demand, names.arg = BOD(달러표시)Time) # head(mtcars) dim(mtcars) cyl_freq=table(mtcars(달러표시)cyl) barplot(cyl_freq) cyl_gear_freq=table(mtcars(달러표시)cyl, mtcars(달러표시)gear) barplot(cyl_gear_freq) barplot(cyl_gear_freq, beside = T) . . . . . . . 위 그래프 만으로는 x축과 y축에 대한 정보를 알 수 없다. 각 축에 대한 라벨링 작업을 수행할 수 있다. 또한 추가적으로 x축, y축의 범위를 나타낼 수 있다. . &#49892;&#49845; &#53076;&#46300; 2 . # graphic parameter barplot(cyl_gear_freq, beside = T, xlab = &quot;Gears&quot;, ylab = &quot;Cylinder&quot;) barplot(cyl_gear_freq, beside = T, xlab = &quot;Gears&quot;, ylab = &quot;Cylinder&quot;, ylim = c(0, 20)) . . . . 그래프에 대한 더 다양한 작업이 가능한데, x축의 값에 대한 각도를 바꾸는 las 파라미터를 사용한다. . &#49892;&#49845; &#53076;&#46300; 3 . barplot(cyl_gear_freq, beside = T, xlab = &quot;Gears&quot;, ylab = &quot;Cylinder&quot;, ylim = c(0, 20), las=2) . . 패널의 배열 및 여백을 조절할 수 있는 par() 함수가 있다. 여러 파라미터가 있으므로 다양한 옵션을 줄 수 있다. 이 노트에서는 mfrow 파라미터를 통해 그래프의 구획을 나눠주겠다. . &#49892;&#49845; &#53076;&#46300; 4 . par(mfrow=c(2,2)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;red&#39;) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;blue&#39;) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;green&#39;) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) . . par() 함수를 한 번 사용하게 되면, 다음 그래프에도 영향을 주게 되므로 이를 초기화하는 작업이 필요하다. 이 땐, graphics.off() 함수 또는 dev.off() 함수를 사용한다. . &#49892;&#49845; &#53076;&#46300; 5 . graphics.off() dev.off() . par() 함수의 옵션 중 여백(마진)을 조절할 수 있는 mar 파라미터가 있다. . &#49892;&#49845; &#53076;&#46300; 6 . par(mar=c(0,0,0,0)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) par(mar=c(5,0,0,0)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) par(mar=c(5,5,0,0)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) par(mar=c(5,5,5,0)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) par(mar=c(5,5,5,5)) plot(x = pressure(달러표시)temperature, y = pressure(달러표시)pressure, cex=1, col=&#39;pink&#39;) . . . . . . &#49353; &#51648;&#51221; . R에서는 657개의 색을 지정해서 사용할 수 있다. . colors() . . color set . 그래프에 컬러 셋을 자동으로 설정하게 할 수 있다. 사용 가능한 컬러셋은 다음과 같이 알아낼 수 있다. . library(&quot;RColorBrewer&quot;) display.brewer.all() . . 실제 그래프에 컬러셋을 적용한 코드는 다음과 같다. . display.brewer.pal(n = 8, name= &quot;RdBu&quot;) brewer.pal(n = 8, name=&quot;RdBu&quot;) # color code값 추출 barplot(c(2,5,7), col=brewer.pal(n=3, name=&quot;RdBu&quot;)) # 그래프에 color 적용 . . . . ggplot . ggplot&#51004;&#47196; &#44536;&#47548; &#44536;&#47532;&#44592; . ggplot을 사용하여 그래프를 그리기 위해서는 ggplot() 함수와 함께 +를 이용하여 그래프 형태와 테마, 색깔, 그룹 지정 등에 해당하는 옵션들을 추가하면 된다. 단, 기본 입력 데이터가 데이터프레임이어야 한다. ggplot() 함수의 파라미터는 다음과 같다. . ggplot(data=data.frame, aes(x=x축 데이터 컬럼의 이름), y=y축 데이터 컬럼의 이름)) + geom_xx() + ... . 축의 이름은 실제 축의 이름을 입력해야 한다. . ggplot() 함수만으로는 plotting이 되지 않으며, +를 이용해 어떤 그래프를 그릴지에 대한 추가적인 정보를 입력해야 한다. 입력할 수 있는 정보는 다음과 같다. . geom_point() | geom_line() | geom_boxplot() | geon_bar() | . 실습 코드 . library(ggplot2) # geom_point ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width)) + geom_point(size=3, color=&#39;red&#39;) # geom_line ggplot(data = pressure, aes(x = temperature, y= pressure)) + geom_line() + geom_point() # geom_boxplot() ggplot(data = iris, aes(x=Species, y=Petal.Length, fill=Species))+geom_boxplot() # geom_bar() ggplot(data = mtcars, aes(x=factor(cyl))) + geom_bar() # factor: 범주형 데이터 . . . . . &#51649;&#51217; &#47564;&#46304; &#45936;&#51060;&#53552;&#47484; &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#54868; &#54616;&#50668; &#44536;&#47000;&#54532; &#44536;&#47532;&#44592; . &#49892;&#49845; &#53076;&#46300; . df=data.frame(table(mtcars(달러표시)cyl)) df ggplot(data = df, aes(x = Var1, y=Freq)) + geom_bar(stat = &#39;identity&#39;) ggplot(data = df, aes(x = Var1, y=Freq)) + geom_bar(stat = &#39;identity&#39;, fill=&#39;blue&#39;, width=0.5) + ylab(&quot;Frequency&quot;) + xlab(&quot;Cylinders&quot;) . . . gg &lt;- ggplot(data=iris, aes(x = Petal.Length, y = Petal.Width))+geom_point(aes(color=Species, shape=Species), size=3) gg gg + theme_bw() gg + theme_classic() gg + theme_dark() gg + theme(text = element_text(size = 15, face = &#39;bold&#39;)) gg + theme(axis.title.x = element_text(size = 15, face = &#39;bold&#39;)) gg + theme(axis.text.x = element_text(size = 15, face = &#39;bold&#39;)) gg + theme(legend.position = &#39;top&#39;) . . . . . . . &#47928;&#51228; . R 기본내장 데이터인 iris 데이터를 이용해 다음의 boxplot을 그리시오. . . boxplot(Sepal.Length~Species, data=iris, xlab=&quot;Species&quot;, ylab=&quot;Sepal Length&quot;) boxplot(iris(달러표시)Sepal.Length~iris(달러표시)Species, xlab=&quot;Species&quot;, ylab=&quot;Sepal Length&quot;) . Reference . K-genome | https://rfriend.tistory.com/20 | https://rfriend.tistory.com/124 | https://rfriend.tistory.com/125 | https://jjoyling.tistory.com/31 | .",
            "url": "https://tfedohk.github.io/dohk/r-basic-concept-and-code/",
            "relUrl": "/r-basic-concept-and-code/",
            "date": " • Nov 6, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "R Statistical Test(모수 검정 vs 비모수 검정)",
            "content": "single sample t-test . 해당 노트는 R에서 빈번하게 사용되는 통계 기법 등에 대해 다루는 노트다. 통계는 크게 모수 검정(parametric test)와 비모수 검정(non-parametic test)로 나눌 수 있다. R이 가정하는 것은 모집단이 정규분포를 따른다는 것이다. 정규분포를 따른다는 것은 평균이 0, 분산이 1인 경우를 말한다. . 모집단이 정규 분포를 따르는 경우도 있지만 따르지 않는 경우도 있다. 모집단이 정규 분포를 따르는 경우를 모수 검정, 모집단이 정규 분포를 따르지 않는 경우를 비모수 검정이라고 한다. . 비모수 검정은 표본수가 적거나 모집단이 정규분포임을 가정하기 어려운 경우, 측정 자료의 수준이 이산형 등의 categorical인 경우에 사용된다. . 비교 그룹이 두 가지인 경우, 모수 검정으로는 paired t-test, independent (student) t-test를 통해 두 집단 간의 평균을 비교한다. 비모수 검정(즉, 정규 분포를 따르지 않는 경우)에서는 Mann-Whiteney U-test, Wilcoxon rank sum test, Crank Sum 비교, median 등을 사용된다. 특히, mean이 아닌 중간값(median)을 사용한다. . 그룹이 세 개 이상인 경우의 비교에서, 모수 검정에서는 One-way ANOVA를 대표적으로 사용한다. 비모수 검정에서는 Kruskal-Willis test를 사용한다. . 통계에서는 정규성을 따르는지 여부가 굉장히 중요하다. 내가 다루고자 하는 데이터가 정규성이 있는지 없는지 검증하는 과정이 내가 쓰고 있는 통계 기법에 대한 신뢰성을 보장해준다. 따라서 정규성 검증이 우선적으로 수행되어야 한다. 정규성 검증 방법으로 Q-Q plot 그리기, Shapiro-Wilk test(샤피로 윌크 검정), Kolmogorov-Smirnov test(콜모고로프-스미노트 검정)이 있다. 이 세 가지 방법으로 정규성을 따르는지 따진다. 각 테스트에서 p값이 0.05보다 커야 정규성을 따르는 것으로 판단할 수 있다. . Q-Q plot: Qunatile-Quantile plot . 실제 데이터값과 이론적 데이터값의 분포를 비교했을 때 어느 정도 일치하는지를 Plot으로, 즉 시각적으로 확인하는 방법이다. 대각선의 치우친 정도에 따라 정규성을 판단하게 된다. 따라서 해석이 주관적일 수 있다는 단점이 있다. 시각적인 방법 외에 p값을 판단하기 위한 통계적인 기법으로 Shapiro-Wilk test(샤피로 윌크 검정), Kolmogorov-Smirnov test(콜모고로프-스미노트 검정)이 있다. . qqnorm() . 정규분포의 Q-Q plot을 그리는 함수. 1Q와 3Q를 지나는 선을 그리는 함수다. 정규분포일 경우 직선을 띈다. . qqplot() . 두 개의 자료가 같은 분포에서 추출되었는지를 검증한다. 같은 분포를 따를 경우 y=x 그래프로 나온다. . &#49892;&#49845; &#53076;&#46300; . set.seed(1234) x&lt;-sample(x=1:200, size=30, replace=F) qqnorm(x) # normal Q-Q plot 생성 qqline(x, col=2) # 대각선 추가 . . 오른쪽 대각선으로 직선의 모양을 띄고 있으므로 정규분포를 따른다고 추정할 수 있으며, 모수 추정법을 시도해 볼 수 있다. . SW-test: Shapiro-Wilk test(&#49380;&#54588;&#47196; &#50956;&#53356; &#44160;&#51221;) . p &gt; 0.05일 경우 정규성을 띈다고 가정할 수 있다. . &#49892;&#49845; &#53076;&#46300; . set.seed(1234) x&lt;-sample(x=1:200, size=30, replace=F) shapiro.test(x) . p값이 0.9122로, 0.05보다 크므로 정규분포를 따른다고 가정할 수 있고 따라서 모수 추정법을 쓸 수 있다. . KS-test: Kolmogorov-Smirnov test(&#53084;&#47784;&#44256;&#47196;&#54532;-&#49828;&#48120;&#45432;&#53944; &#44160;&#51221;) . Empirical Distribution Function(EDF)에 기반한 검정 방법. 자료의 평균과 표준편차, 히스토그램을 표준정규분포와 비교하여 적합도를 검정하며, p &gt; 0.05일 경우 정규성을 띈다고 가정할 수 있다. . &#49892;&#49845; &#53076;&#46300; . ks.test() . set.seed(1234) x&lt;-sample(x=1:200, size=30, replace=F) ks.test(x, &quot;pnorm&quot;, mean=mean(x), sd=sd(x)) . . p값이 0.9952로, 0.05보다 크므로 정규분포를 따른다고 가정할 수 있고 따라서 모수 추정법을 쓸 수 있다. . lillie.test() . # install.packages(&quot;nortest&quot;) library(nortest) set.seed(1234) x&lt;-sample(x=1:200, size=30, replace=F) lillie.test(x) . . p값이 0.961로, 0.05보다 크므로 정규분포를 따른다고 가정할 수 있고 따라서 모수 추정법을 쓸 수 있다. . . Paired t-test . 두 집단 간의 대응 표본에 대한 t-검정을 말한다. 표본의 각 케이스마다 대응되는 두 개의 관측치가 있다는 관점에서 single sample t-test와는 차이가 있다. . 각 환자가 주어지고, 동일한 집단에 속한 각 환자의 약물을 처리 전과 후를 비교하고자 할 때, 약물에 대한 효과를 보기 위해 검정하는 경우가 그 예다. . 즉, 약물 처리 전과 후 두 그룹에 대한 t-test를 수행하기 위한 방법이다. 모수 검정이므로 우선 정규성이 만족되어야 하며, 두 집단간 분산이 등분산을 이루어야 한다. 이 두 조건을 만족하면 paired t-test를 사용할 수 있다. . &#46321;&#48516;&#49328;&#49457; test: bartlett test . &#49892;&#49845; &#53076;&#46300; . before = c(0.430, 0.266, 0.567, 0.531, 0.707, 0.716, 0.651, 0.589, 0.469, 0.723) after = c(0.415, 0.238, 0.390, 0.410, 0.605, 0.609, 0.632, 0.523, 0.411, 0.612) data = data.frame(before = before, after = after) dim(data) data . . var.test(data(달러표시)before, data(달러표시)after) . . p-value값이 0.7441로 나온다. 0.05보다 큰 값이므로 두 집단의 등분산성을 인정할 수 있다. . t-test . 두 집단이 등분산을 이루고 있으므로 두 집단 간이 정규분포를 따르는지를 따지기 위한 t-test를 수행해야 한다. . . t-test() 함수에서 요구하는 파라미터는 위와 같다. 만약 y를 기술하지 않으면 single sample에 대한 t-test가 된다. . &#49892;&#49845; &#53076;&#46300; . t.test(data(달러표시)before, data(달러표시)after, paired=T) . . mean of the differences는 두 집단 간 평균의 차이를 의미한다. . &#46021;&#47549;&#54364;&#48376; t-test (independent sample t-test &#46608;&#45716; Student sample t-test) . 비교하려는 집단은 서로 독립적인 집단에서 추출된 샘플이며, 이 두 집단의 샘플에 대한 평균의 차이를 통계적으로 검정한다. 즉, 모집단이 서로 다르다. 그러므로 상관성이 서로 없을 가능성이 크다. 따라서 두 집단의 평균의 차이를 검증해야 한다. . R에 내장된 데이터셋을 살피기 위해 data()를 입력한다. . data . . 이들 중 iris를 사용할 예정이다. . &#49892;&#54744; &#53076;&#46300; . # iris dim(iris) head(iris) data = iris[c(1:100), c(&quot;Species&quot;, &quot;Sepal.Length&quot;)] # 종과 꽃잎의 길이만 비교하겠다. head(data) colnames(data) = c(&quot;species&quot;, &quot;sepal&quot;) # bartlett test bartlett.test(sepal~species, data=data) # p-value가 적으므로 분산이 이질적이라고 할 수 있다. # t-test t.test(sepal~species, var.eqaul=F, data=data) . . p 값이 차이가 있기 때문에 두 집단 즉 Species(종)과 sepal.Length(꽃잎의 길이)간에는 확연한 차이가 있다고 판단할 수 있다. . Wilcox-test: &#46160; &#47784;&#51665;&#45800;&#51032; &#51473;&#49900; &#52264;&#51060;&#50640; &#45824;&#54620; &#48708;&#47784;&#49688;&#44160;&#51221; . 독립표본 t-test (independent sample t-test 또는 Student sample t-test)이 정규성을 충족하는 두 집단 간의 평균의 차이를 이용하여 비교하는 검정법이었다. 만약 비교하려는 두 집단이 정규성을 충족하지 못하는 경우이거나 그 분포의 형태를 알 수 없을 경우엔 정규성을 충족하지 못함을 가정하여 비모수 검정을 사용한다. 이 때 wilcox-test를 수행하게 된다. 즉 모집단이 정규성 가정을 충족하지 못하거나, 모집단의 분포 형태를 모르는 경우에 사용된다. 두 모집단의 중심(median)의 차이에 대한 비모수 검정이며, 다른 말로는 wilcoxon rank sum test, Mann-Whiteney U-test라고도 한다. . &#49892;&#54744; &#53076;&#46300; 1 . ## 정규성을 충족하지 못하는 두 모집단의 중심 차이에 대한 비모수검정 ## Wilcox rank sum test, Mann-Whiteney U-test ## Dataset library(MASS) #str(Cars93) #head(Cars93) wilcox.test(Price ~ Origin, data=Cars93, alternative = c(&quot;two.sided&quot;), mu = 0, conf.int = FALSE, conf.level = 0.95) . . p 값이 0.6724로 0.05보다 크므로 두 집단 간에는 차이가 없다고 할 수 있다. . &#49892;&#54744; &#53076;&#46300; 2 . ## paired 2 sample : Wilcoxon signed rank test # 정규성을 따르지 않는 10명의 환자의 치료제에 복용에 따른 혈중 타겟 단백질 농도 비교시 before = c(51.4, 52.0, 45.5, 54.5, 52.3, 50.9, 52.7, 50.3, 53.8, 53.1) after = c(50.1, 51.5, 45.9, 53.1, 51.8, 50.3, 52.0, 49.9, 52.5, 53.0) # wilcox signed rank test wilcox.test(before, after, alternative = c(&quot;greater&quot;), paired = TRUE, conf.level = 0.95) . . p가 0.05보다 충분히 작은 값인 0.006172이므로 두 집단 간에 차이가 있다고 판단할 수 있다. . &#51068;&#50896;&#48516;&#49328; &#48516;&#49437;: one-way ANOVA . 모두 검정 중 정규성을 충족하나, 비교하려는 집단이 세 개 이상인 경우에 해당한다. 두 집단일 경우 평균이나 중간값을 비교했다. 그러나 집단이 세 개 이상인 경우에는 집단 내에서의 분포가 얼마나 차이가 있는지 분산을 비교해야 한다. A집단 내의 분산, B집단 내의 분산이 다르다면 두 집단은 다르다고 판단할 수 있는 원리다. 즉 세 개의 집단에 대한 분산을 비교한다. . &#49892;&#49845; &#53076;&#46300; . ## One-way ANOVA :One-way ANOVA : aov(), oneway.test # 정규성을 충족하는 독립된 세 집단 이상의 평균을 비교하고자 할 때 사용하는 분석 방법 ## Are there any daily outcome differences among temperature conditions? # group 1 : temperature condition 1 # group 2 : temperature condition 2 # group 3 : temperature condition 3 # daily outcome by tmep condition (group 1/2/3) outcome01=c(50.5, 52.1, 51.9, 52.4, 50.6, 51.4, 51.2, 52.2, 51.5, 50.8) outcome02=c(47.5, 47.7, 46.6, 47.1, 47.2, 47.8, 45.2, 47.4, 45.0, 47.9) outcome03=c(46.0, 47.1, 45.6, 47.1, 47.2, 46.4, 45.9, 47.1, 44.9, 46.2) outcome=c(outcome01, outcome02, outcome03) group=c(rep(&quot;G1&quot;, 10),rep(&quot;G2&quot;, 10), rep(&quot;G3&quot;, 10)) ## 데이터 프레임으로 결합 group_outcome=data.frame(outcome, group) head(group_outcome) # descriptive statistics by group tapply(outcome, group, summary) . . tapply() 함수는 테이블 형태의 데이터에 적용할 수 있는 apply 함수다. | . 정규성을 충족하고 있다. 이제, 등분산성을 검증해야 한다. . ## Bartlett test (등분산성 검증) bartlett.test(outcome ~ group, data = group_outcome) . . p값이 0.4368로 충분히 크다. 등분산성을 이루고 있다고 할 수 있다. . 정규성과 등분산성이 모두 충족되므로 모수 검정을 실시할 수 있게 된다. . ## one-way ANOVA aov(outcome ~group, data=group_outcome) summary(aov(outcome ~group, data=group_outcome)) . . 그룹간 Residuals가 주어지고, 그것에 대한 통계처리된 값들이 나온다. p값이 1.2e-13으로 작게 나온다. 즉 세 그룹은 서로 다르다고 할 수 있다. ANOVA의 단점은 어느 그룹과 어느 그룹이 차이가 있는지는 보여주지 못한다는 단점이 있다. . Kruskal-Willis &#44160;&#51221; . 세 집단을 비교하는 방법으로 정규성을 충족하지 않는 집단에 대한 비모수 검정 방법에 해당한다. 비모수 검정은 평균이 아닌 중간값을 비교하듯, 이 방법도 크기순으로 정렬한 후 가장 작은 값부터 순위를 메겨, 그룹별 순위합을 구하는 방법이다. 그룹 간에 순위합에 차이가 없다면 순위합도 비슷하다고 할 수 있고, 크기 차이가 많이 난다면 순위합도 차이가 많이 날 것이라는 기본적인 가정하에 나온 기법이다. . 데이터에 대한 등분산 검증을 먼저 실시하게 된다. 정규성을 띌 경우 bartlett-test를 실시하지만, 여기서는 정규성을 띄지 않으므로 levene test를 실시한다. . &#49892;&#49845; &#53076;&#46300; . ## 정규성을 충족하지 않는 K개의 독립진단에 대한 비모수 검정 ## Kruskal-Willis 검정 value1 &lt;- c(98,95,76,95,83,99,82,75,88) value2 &lt;- c(95,71,80,81,77,70,80,72,81) value3 &lt;- c(77,79,91,84,80,93,87,81,83) category &lt;- c(rep(&quot;A&quot;,9),rep(&quot;B&quot;,9),rep(&quot;C&quot;,9)) data &lt;- data.frame(value=c(value1,value2,value3), category) head(data) ## 등분산 검증 (levene.test) ## levene test는 barlettetest 보다 정규성을 띠지 않는 경우에 보다 민감 #install.packages(&quot;lawstat&quot;) library(lawstat) levene.test(data(달러표시)value,data(달러표시)category) ## Kruskal-Willis kruskal.test(value~category, data=data) . . 등분산을 띄고(P-value: 0.2023 &gt; 0.05), Kruskal-Wallis test에서 나온 P-value가 0.05793으로 0.05보다 크므로 세 집단에는 통계적으로 차이가 없다고 볼 수 있다. . &#47928;&#51228; . 다음은 A집단과 B집단의 키를 측정한 결과이다. A와 B 그룹 사이에 신장 차이가 있는지 판단하기 위해 사용되는 R 통계방법을 모두 고르시오. . A = c(171.2, 190.1, 184.3, 179.6, 183.2, 174.1, 186.7, 187.2, 187.2, 179.5) B = c(175.3, 176.1, 173.2, 176.7, 181.3, 178.6, 180.2, 172.6, 180.9, 172.1) . [ ] t.test(A~B) | [ ] var.test(A, B) | [ ] aov(A, B) | [ ] wilcox.test(A~B) | [ ] t.test(A, B) | . A = c(171.2, 190.1, 184.3, 179.6, 183.2, 174.1, 186.7, 187.2, 187.2, 179.5) B = c(175.3, 176.1, 173.2, 176.7, 181.3, 178.6, 180.2, 172.6, 180.9, 172.1) data = data.frame(A = A, B = B) dim(data) data var.test(data(달러표시)A, data(달러표시)B) t.test(data(달러표시)A, data(달러표시)B) . 또는 . A = c(171.2, 190.1, 184.3, 179.6, 183.2, 174.1, 186.7, 187.2, 187.2, 179.5) B = c(175.3, 176.1, 173.2, 176.7, 181.3, 178.6, 180.2, 172.6, 180.9, 172.1) var.test(A, B) t.test(A~B) . Reference . https://m.blog.naver.com/PostView.nhn?blogId=dic1224&amp;logNo=80209540135&amp;proxyReferer=https:%2F%2Fwww.google.com%2F | .",
            "url": "https://tfedohk.github.io/dohk/r-statistical-test/",
            "relUrl": "/r-statistical-test/",
            "date": " • Nov 6, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "용매의 cut off, pH에 따른 최대흡광파장 알아보기",
            "content": "&#49892;&#54744;1: cut off &#54028;&#51109;&#45824; &#52769;&#51221;&#54616;&#44592; . 자외선 파장대에 해당하는 190nm~500nm 사이의 파장대에서 용매의 cut off 파장 알아보는 실험이다. 자외선은 사람의 육안에는 보이지 않는 10에서 400nm의 파장 영역을 가진다. . 용매의 종류는 다음과 같다. . H2O | dimethylsulfoxide(DMSO) | aceton | EtOH | acetonitrile | MeOH | Hexane → 물에 섞이지 않음 | CH2Cl2 → 물에 섞이지 않음 | . &#49892;&#54744; &#44208;&#44284; . spectrophotometer &#55137;&#44305;&#46020; &#52769;&#51221; &#44208;&#44284; . UV-vis Analysis &#44536;&#47000;&#54532; . &#49892;&#54744;2: pH &#48320;&#54868;&#50640; &#46384;&#47480; &#55137;&#49688;&#54028;&#51109;&#51032; &#48320;&#54868; . pH에 따라 흡수가능한 흡광 파장대가 달라지는 것을 알아보는 실험이다. 흡광도를 측정한 후 UV-vis로 최대 흡수파장인 λmax를 알아낸다. . 사용한 용매의 종류는 두 가지로 다음과 같다. . methyl orange | BPB(Bromo Phenol Blue) | . 산도 조절을 위해 사용한 용액은 다음과 같다. . 0.1N HCl | 0.1N NaOH | D.W. | . &#49892;&#54744; &#44208;&#44284; . spectrophotometer &#55137;&#44305;&#46020; &#52769;&#51221; &#44208;&#44284; . UV-vis Analysis &#44536;&#47000;&#54532; . methyl orange의 pH에 따른 흡광파장대의 변화를 나타낸다. . BPB의 pH에 따른 흡광파장대의 변화를 나타낸다. . Reference . https://ko.wikipedia.org/wiki/자외선 | .",
            "url": "https://tfedohk.github.io/dohk/2020-09-28-cut-off-ph-lambda-max/",
            "relUrl": "/2020-09-28-cut-off-ph-lambda-max/",
            "date": " • Sep 28, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "희석, 흡광도 측정, 검량선 작성",
            "content": "고농도의 표준용액을 희석하여 검량선을 만들 수 있다. KMnO4와 같은 물질이 있다고 가정해보자. 이 때 Mn에 대한 정량적 표준용액을 만들기 위해서는 필수적으로 원하는 성분인 Mn의 정량을 위해 농도를 계산해야 한다. 이번 실험 노트에서는 표준용액을 만들기 위한 농도를 계산하는 법과 함께, 희석한 용액을 spectrophotometer를 이용하여 흡광도를 측정하고, 검량선을 작성하는 것에 대해 다루고자 한다. . parts-per notation . &#48177;&#48516;&#50984;(parts per hundred) . 용액 100mL에 대한 성분의 무게(g): W/V % | 기체 100mL에 대한 성분의 무게(g): W/V % | 용액 100mL에 대한 성분의 용량(mL): V/V % | 기체 100mL에 대한 성분의 용량(mL): V/V % | 용액 100g에 대한 성분의 용량(mL): V/W % | 용액 100g에 대한 성분의 무게(g): W/V % | . &#52380;&#48516;&#50984;(parts per thousand: ppt): g/L, g/kg . &#48177;&#47564;&#48516;&#50984;(parts per million: ppm): mg/L, mg/kg . 주로 대기나 해수, 지각 등에 존재하는 미량 성분의 농도를 나타낼 때 사용된다. | mg은 10^(-3), L는 10^3이므로, 1/10(6)이 된다. | kg단위는 액체에서는 L단위와 같다. | . &#49901;&#50613;&#48516;&#50984;(parts per billion: ppb): &#956;g/L, &#956;g/kg . &#55137;&#44305;&#44228;&#49688; . 흡광도 A는 다음과 같이 정의된다. . . 우리는 흡광도를 측정했다. b는 cell의 길이이고, c는 농도일 때, 흡광계수 ε을 알아낼 수 있다. 흡광계수는 같은 물질이면 같은 값을 갖는 것이 정상이다. 흡광계수 ε을 구하려면, . . 위 수식을 이용한다. 이 노트에서 b는 1, c는 10으로 고정한다. . &#44592;&#44592; &#49324;&#50857;&#48277; . &#48516;&#44305;&#44305;&#46020;&#44228;(spectrophotometer) . 기기: humancorp사의 X-ma 3000PC SPECTROPHOTOMETER | . 전원ON → warming up 20min → warm up 종료 후 → ESC 버튼 → 준비 완료 소리 울림 . . 값을 안정적으로 읽어들이기 위해선 램프의 안정화가 필요하다. 램프 안정화에 20분 정도 걸리므로 분광광도계를 사용하기 전에 미리 켜놓는 것이 좋다. | 해당 기기는 오른쪽 위의 D2, W가 표시되어 있다. 둘 다 램프의 상태를 의미한다. D2는 자외선(UV)을 발생시키는 램프, W는 가시광선을 발생시키는 램프다. 내부에는 램프, 모노크로메이터(파장선택부), 미러, 디텍터, 시료를 놓는 곳 등으로 이루어져 있다. 우리가 파장을 설정하면, 램프에서 발생된 빛이 설정된 파장에 맞춰 시료를 통과하도록 미러가 조정된다. | . 여러 모드가 있다. . basic mode: 원하는 파장을 설정하여, 일정한 파장에서 흡광도를 분석하는 것 | quantitative mode: 정량분석시 사용. 미지농도를 산출해준다. | wavelength scan: 시료가 어느 파장에서 가장 잘 감지되는지를 찾을 때 사용한다. USB 꽂은 후, 기기에 USB가 인식되면 해당 기능을 통해 데스크탑에서 UV-vis Analyst 프로그램을 통해 가장 높은 파장(λmax)을 보이는 지점을 알 수 있다. 그 지점에 해당하는 파장을 이용하여 흡광도를 측정해야 한다. | . . &#55137;&#44305;&#46020; &#48516;&#49437; . basic mode → Enter 버튼 → 기기가 자동으로 Blanking부터 시작함. 만약 Blank를 넣지 않은 상태라면, Blank → 기기 내부에 삽입 → 0Abs 버튼: +-0.000 Abs가 뜨면 완료. | 만약 다른 파장으로 변경한다면, blanking을 다시 해야 한다. gotoλ 버튼 → 설정 하려는 파장의 숫자 입력 → Enter 버튼 → 설정 완료 후, 0Abs 버튼 | . &#54028;&#51109; &#48516;&#49437; . wavelength mode → Enter 버튼 → 장파, 단파 설정을 위해 setup 위치의 버튼 → 원하는 파장, scan step, scan speed 입력: 1000, 190, 1(default), MEDIUM(default) → USB 삽입 → USB 삽입 아이콘 확인 → 파장을 파악하려는 시료 투입 → Start → 측정 완료 후 USB 저장을 위해, save 버튼 → 파일 이름 입력 → UV-vis Analyst 프로그램 → File → Open → 파일 확장자 .wav로 변경 → 파일 선택 → View → Peaks → Settings → Display Range Setup → x축 range 설정 | WL: wave length. WL이 900으로 설정된 후, 190까지 읽어나가면서 그래프를 그린다. | 셀의 종류에 따라서 민감하게 반응하는 파장이 다르다. 셀마다 재질이 다르기 때문이다. | . &#49892;&#54744; &#44284;&#51221; . KMnO4 시약 → Mn 용액 만들기 Mn 용액의 농도: 500mg/L (500ppm) | . | 중간농도 용액 만들기 100ppm | . | 중간농도 용액 → 100mL 부피플라스크에 희석 용액 만들기 1.0ppm, 5.0ppm, 10.0ppm, 20.0ppm 20mL kMnO4 + D.W. 80mL | 10mL kMnO4 + D.W. 90mL | 5mL kMnO4 + D.W. 95mL | 1mL kMnO4 + D.W. 99mL | . | 희석 용액은 내림차순으로 제조해야 함 | . | . . 20mg/L 용액 → 셀 → spectrophotometer &amp; USB → UV-Vis Analyst 프로그램: 파장대 파악 515nm로 나왔음 UV-vis wav 파일 | . | . | . spectrophotomoter로 흡광도 측정 및 검량선 작성 D.W. → spectrophotometer: blanking | 농도의 오름차순으로 흡광도를 측정하였음 | 셀 세척 시, 1) 털지 말기 2) 정방향으로 들지 말기 → 책상 위에 휴지를 놓고 탁탁 치기: 휴지로 셀 겉면을 문지르면 분진으로 인해 흡광도에 영향을 줄 수 있다. | . | . &#44208;&#44284; . &#55137;&#44305;&#46020; &#52769;&#51221; &#44208;&#44284; . &#55137;&#44305;&#44228;&#49688; &#49328;&#52636; &#44208;&#44284; . &#44160;&#47049;&#49440; . &#44160;&#47049;&#49440; &#51089;&#49457; &#53076;&#46300;(python) . 엑셀로 작성 시, 삽입 → 차트 → 분산형을 선택한다. | . import numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.metrics import r2_score import math . . def plot_working_curve(time, DATA, member, legend, x_label, y_label, x_posision, y_position_1, y_position_2): DATA_np = np.array(DATA) slope, y_intercept = np.polyfit(time,DATA_np,1) # m*x + b, m과 b를 return poly1d_fn = np.poly1d([slope, y_intercept]) f1 = plt.figure(figsize=(15, 17)) plt.title(&quot;Serial Dilution-&quot;+member) plt.rc(&#39;font&#39;, size=20) plt.rc(&#39;xtick&#39;, labelsize=20) plt.rc(&#39;ytick&#39;, labelsize=20) y1 = np.array(slope)*time + np.array(y_intercept) R_squared_value = r2_score(y1, DATA) plt.subplot(3,1,1) plt.plot(time, DATA, color=&#39;black&#39;, marker=&#39;o&#39;, linestyle=&#39; &#39;, linewidth=2, markersize=12, alpha=.5, label=&quot;1st&quot;) plt.plot(time,DATA_np, &#39;ko&#39;, time, poly1d_fn(time), &#39;-k&#39;) ##### SAMPLE ##### # sample A(1.0, 5.0, 10.0, 20.0) plt.text(x_posision, y_position_1, &quot;R squred value: {:1.4f}&quot;.format(R_squared_value), fontsize=13) plt.text(x_posision, y_position_2, &quot;y={:1.4f}x+({:1.4f})&quot;.format(slope, y_intercept), fontsize=13) # sample B(0.2, 0.4, 0.8) # plt.text(0.7, 0.08, &quot;R squred value: {:1.4f}&quot;.format(R_squared_value), fontsize=13) # plt.text(0.7, 0.07, &quot;y={:1.4f}x+({:1.4f})&quot;.format(slope, y_intercept), fontsize=13) ################## plt.grid(True, lw = 2, ls = &#39;--&#39;, c = &#39;.85&#39;) plt.xlabel(x_label) plt.ylabel(y_label) plt.legend(fontsize=&#39;medium&#39;) # txt=&quot;Figure 2. caption {}.&quot;.format(member) # plt.text(5, 0.15, txt, ha=&#39;center&#39;, size=17) plt.xlabel(x_label) plt.ylabel(y_label) plt.grid(True, lw = 2, ls = &#39;--&#39;, c = &#39;.85&#39;) return slope, y_intercept . . def plot_graph(member, x_axis_scale, DATA_set, dilution_times, x_posision, y_position_1, y_position_2): slope, y_intercept = plot_working_curve(time=x_axis_scale, DATA=DATA_set[0], member=member, legend=&quot;BSA(buffer: D.W.)&quot;, x_label=&quot;sample(mg/L)&quot;, # sample A(1.0, 5.0, 10.0, 20.0) # x_label=&quot;sample(μg/L)&quot;, # sample B(0.2, 0.4, 0.8) y_label=&quot;O.D. (515nm)&quot;, x_posision = x_posision, y_position_1 = y_position_1, y_position_2 = y_position_2) . . &#44160;&#47049;&#49440; &#51089;&#49457; &#44208;&#44284; . if __name__ == &quot;__main__&quot;: member = &quot;Kwon DoHyung&quot; # sample A(1.0, 5.0, 10.0, 20.0) x_axis_scale = [0.1, 5.0, 10.0, 20.0] DATA_set = [[0.122,0.682,1.328,2.482]] dilution_times = 4 x_posision = 17 y_position_1 = 1.5 y_position_2 = 1.25 plot_graph(member, x_axis_scale, DATA_set, dilution_times, x_posision, y_position_1, y_position_2) . R^2값이 0.9996으로 나왔다. R^2값은 0.99이상이 나오면 이상적이라고 할 수 있으므로 20.0 → 10.0 → 5.0 → 1.0 으로 적절히 희석되었다고 할 수 있다. . 10ppm 용액 → 50mL 부피플라스크에 희석 용액 만들기 0.2ppm, 0.4ppm, 0.8ppm 1mL kMnO4 + D.W. 9mL | 2mL kMnO4 + D.W. 8mL | 4mL kMnO4 + D.W. 6mL | . | 농도의 오름차순으로 흡광도를 측정하였음 | D.W. → spectrophotometer: blanking | 농도의 오름차순으로 흡광도를 측정하였음 | . | . . spectrophotomoter로 흡광도 측정 및 검량선 작성 | . &#44208;&#44284; . &#55137;&#44305;&#46020; &#52769;&#51221; &#44208;&#44284; . &#55137;&#44305;&#44228;&#49688; &#49328;&#52636; &#44208;&#44284; . &#44160;&#47049;&#49440; &#51089;&#49457; &#44208;&#44284; . if __name__ == &quot;__main__&quot;: member = &quot;Kwon Do Hhyung&quot; # sample B(0.2, 0.4, 0.8) x_axis_scale = [0.2, 0.4, 0.8] DATA_set = [[0.02,0.047,0.099]] dilution_times = 3 x_posision = 0.7 y_position_1 = 0.08 y_position_2 = 0.07 plot_graph(member, x_axis_scale, DATA_set, dilution_times, x_posision, y_position_1, y_position_2) . R^2값이 0.9999로 나왔다. 0.2 → 0.4 → 0.8로 적절히 희석되었다고 할 수 있다. . &#49892;&#54744; &#49324;&#51652; . Reference . https://ko.wikipedia.org/wiki/Ppm | .",
            "url": "https://tfedohk.github.io/dohk/serial-dilution-and-plot-working-curve/",
            "relUrl": "/serial-dilution-and-plot-working-curve/",
            "date": " • Sep 22, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "NGS 관련 소프트웨어 설치",
            "content": "이 노트는 NGS 설치 메뉴얼이다. 설치하고자 하는 SW는 다음과 같다. 각 파일을 다운로드 할 수 있는 링크도 함께 달았다. . bwa: 다운로드 또는 latest version | samtools: 다운로드 또는 latest version | picard: 다운로드 또는 latest version | gatk: 다운로드 또는 latest version | trimmomatic: 다운로드 또는 latest version | . &#49444;&#52824;&#50640; &#50526;&#49436; . 모든 과정은 터미널에서 이루어진다. 모든 설치 파일은 /home/user 폴더에 있다고 가정한다. . BWA . &#49444;&#52824; &#47749;&#47161;&#50612; . sudo tar -xvf bwa-0.7.17.tar.bz2 cd bwa-0.7.17 sudo make /.bwa # 결과 확인 pwd #path 복사 sudo vi ~/.bashrc # 맨 아래로 이동 후, i를 눌러 insert 모드로 변경 한 다음, 아래의 내용 추가 export PATH=(달러표시)PATH:[복사한 path 붙여넣기. 괄호는 제거]:(달러표시)PATH # esc-&gt;:wq-&gt;엔터 source ~/.bashrc bwa # 결과 확인 cd .. rm bwa-0.7.17.tar.bz2 . &#44208;&#44284; &#54868;&#47732; . SAMtools . &#49444;&#52824; &#47749;&#47161;&#50612; . tar -xvjf samtools-1.10.tar.bz2 cd samtools-1.10/ sudo apt-get install libncurses5-dev libncursesw5-dev -y # [option 1] sudo apt-get install libbz2-1.0 libbz2-dev libbz2-ocaml libbz2-ocaml-dev -y # [option 2] apt-get install -y liblzma-dev -y # [option 3] sudo apt-get install libcurl4-openssl-dev # [option 4] sudo make ./samtools # 결과 확인 pwd # path 복사 sudo vi ~/.bashrc # 맨 아래로 이동 후, i를 눌러 insert 모드로 변경 한 다음, 아래의 내용 추가 export PATH=(달러표시)PATH:[복사한 path 붙여넣기. 괄호는 제거]:(달러표시)PATH # esc-&gt;:wq-&gt;엔터 source ~/.bashrc samtools cd .. rm samtools-1.10.tar.bz2 . 그냥 sudo make만 진행했을 때 다음의 오류가 발생한다. 따라서 option으로 주석을 단 부분들을 먼저 설치하고 진행하는 것을 추천한다. . curses.h &#50640;&#47084; . bzlib.h &#50640;&#47084; . lzma.h &#50640;&#47084; . curl/curl.h &#50640;&#47084; . &#44208;&#44284; &#54868;&#47732; . Picard . &#49444;&#52824; &#47749;&#47161;&#50612; . picard는 java 기반의 프로그램이다. picard 뿐만 아니라 NGS와 관련된 다른 SW들도 다수가 jar의 JVM 실행파일들이다. 따라서 java의 버전을 확인하여 java가 설치되어 있지 않다면 설치해주어야 한다. . java installation . java -version sudo apt install default-jre -y . picard . java -jar picard.jar # 결과 확인 pwd # path 복사 sudo vi ~/.bashrc # 맨 아래로 이동 후, i를 눌러 insert 모드로 변경 한 다음, 아래의 내용 추가 export PICARD=[복사한 path 붙여넣기. 괄호는 제거]/picard.jar # esc-&gt;:wq-&gt;엔터 source ~/.bashrc java -jar (달러표시)PICARD # 결과 확인 cd .. . &#44208;&#44284; &#54868;&#47732; . GATK . &#49444;&#52824; &#47749;&#47161;&#50612; . unzip gatk-4.1.8.1.zip cd gatk-4.1.8.1/ ./gatk # 결과 확인 java -jar gatk-package-4.1.8.1-local.jar # 결과 확인 pwd # path 복사 sudo vi ~/.bashrc # 맨 아래로 이동 후, i를 눌러 insert 모드로 변경 한 다음, 아래의 내용 추가 export GATK=[복사한 path 붙여넣기. 괄호는 제거]/gatk-package-4.1.8.1-local.jar export PATH=(달러표시)PATH:[복사한 path 붙여넣기. 괄호는 제거]:(달러표시)PATH # esc-&gt;:wq-&gt;엔터 source ~/.bashrc gatk # 결과 확인 java -jar (달러표시)GATK # 결과 확인 . &#44208;&#44284; &#54868;&#47732; . GATK를 실행하는 방법은 두 가지다. 하나는 gatk를 그냥 치면 sh 스크립트가 실행되어 프로그램이 실행되고, 다른 하나는 jar를 이용해 자바 프로그램으로 실행하는 것이다. 두 가지 결과가 모두 아래에 나와있다. . &#49892;&#54665; &#48169;&#48277;1: gatk &#49892;&#54665; . &#49892;&#54665; &#48169;&#48277;2: gatk jar&#49892;&#54665; . Trimmomatic . &#49444;&#52824; &#47749;&#47161;&#50612; . unzip Trimmomatic-0.39.zip cd Trimmomatic-0.39/ ./trimmomatic-0.39.jar # 결과 확인 pwd # path 복사 sudo vi ~/.bashrc export Trimmomatic=/home/dohk/GoogleDrive/workspace_BIO/NGS_installation/Trimmomatic-0.39/trimmomatic-0.39.jar export PATH=(달러표시)PATH:/home/dohk/GoogleDrive/workspace_BIO/NGS_installation/Trimmomatic-0.39:(달러표시)PATH source ~/.bashrc java -jar (달러표시)Trimmomatic cd .. rm Trimmomatic-0.39.zip . &#44208;&#44284; &#54868;&#47732; . fastQC . &#49444;&#52824; &#47749;&#47161;&#50612; . sudo apt update sudo apt install fastqc . &#50640;&#47084; &#45432;&#53944; . python&#51012; &#52286;&#51012; &#49688; &#50630;&#45796;&#45716; &#50640;&#47084;&#44032; &#46896; &#46412; . 우분투에서 작업 시, python은 기본적으로 설치된다. 터미널에서 python 명령어를 쳤을 때 python이 실행되지 않는다면, 다음과 같이 해결한다. 먼저, cd /usr/bin을 실행한 후, p까지 입력한 후, TAB키를 계속 누르면 python 관련된 파일 목록이 뜬다. 이곳에 python이 없다면, python3.x 등 다른 python이 있을 것이다. 이를 python만 쳐도 실행되도록 다음과 같이 명령창에 입력한다. 여기서는 python3.8버전이 있다고 가정한다. . ln -s /usr/bin/python3.8 /usr/bin/python . 다시 python을 입력하여 제대로 실행되는지 확인한다. . Reference . https://gatk.broadinstitute.org/hc/en-us/articles/360041320571--How-to-Install-all-software-packages-required-to-follow-the-GATK-Best-Practices | https://oooooohi.tistory.com/entry/Linux-not-in-gzip-format-%EC%97%90%EB%9F%AC-tar | https://anow.tistory.com/110 | https://ubuntuforums.org/showthread.php?t=1921721 | https://stackoverflow.com/questions/11471690/curl-h-no-such-file-or-directory/11471743 | https://stackoverflow.com/questions/22738077/backports-lzma-lzmamodule-c11518-fatal-error-lzma-h-no-such-file-or-direct | http://www.usadellab.org/cms/?page=trimmomatic | https://www.howtoinstall.me/ubuntu/18-04/fastqc/ | .",
            "url": "https://tfedohk.github.io/dohk/ngs-sw-installation/",
            "relUrl": "/ngs-sw-installation/",
            "date": " • Sep 22, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "단백질의 발현과 정제",
            "content": "이전 실험 노트에서는 gene cloning을 수행하여 E.coli/DH5α(이하 DH5a)에 도입되었던 프라스미드 vector를 E.coli/BL21(DE3)(이하 BL21)에 재도입하는 과정을 다루었었다. 이렇게 transformation된 균주를 배양하여, 단백질의 발현, 정제, 마지막으로 정량하는 방법에 대해 알아보자. . &#45800;&#48177;&#51656; &#48156;&#54788; . BL21&#51060; &#50416;&#51060;&#45716; &#51060;&#50976; . DH5a는 단백질 발현을 유도할 수 있는 시스템이 존재하지 않는다. 반면, BL21은 단백질 발현을 유도시킬 수 있는 시스템이 존재한다. 유전자는 mRNA로 전사(transcript)되며, mRNA는 Amino Acid를 만드는데 관여한다. 유전자에서 mRNA로 전사될 때 RNA Polymerase가 결합하는 부위인 promoter가 있는데, BL21은 T7 RNA Polymerase가 붙을 수 있으므로, DNA→RNA로의 전환이 이루어진다. 또한, mRNA→단백질이 되기 위해서는 RBS(Ribosome Binding Site)가 존재해야 하는데, BL21은 RBS가 존재하므로 단백질을 만들어낼 수 있는 시스템을 갖추고 있다고 볼 수 있다. RBS가 존재하면, 가장 먼저 나타나는 ATG 서열에서부터 아미노산을 붙여나가기 시작하여 최종적으로 단백질이 만들어진다. 또한 BL21은 DH5a보다 더 빠른 growth rate을 가진다. . &#45800;&#48177;&#51656; &#51221;&#51228; . 단백질 정제란 복합 혼합물 (complex mixture)로부터 단일 타입의 단백질을 분리하는 일련의 과정들이다. 단백질 정제는 관심 있는 단백질의 기능, 구조 그리고 상호작용을 분석하기 위해서 필수적이다. . 단백질 정제와 단백질 분리는 동일한 표현이다. 우리는 단백질 정제의 방법으로 Affinity chromatography를 사용하며, 그 다음으로 FPLC를 다룬다. . Affinity Chromatography . Affinity chromatography는 단백질과 특정 물질(ligand)과의 친화성(affinity)을 이용한 대표적인 흡착 chromatography다. 무엇에 대한 친화성일까? 금속 이온 중 니켈에 대한 친화성이다. 따라서, 단백질 자체에 금속에 친화성을 갖는 성질이 있다면 단백질을 정제할 수 있게 된다. 히스티딘 잔기(His-tag)가 바로 그 역할을 하는데, His은 금속(Ni, Mn, Mg, Co, Fe 등)과 특이적 결합을 이룬다. 특이적 결합의 다른 예는 항체와 항원, cytokine 및 hormone과 receptor, 효소와 기질 및 inhibitor 등이 있다. His을 붙이기 위해서는 target gene을 vector에 끼워넣는 단계에서부터 고려해야 한다. target gene의 앞 부분에 His을 붙인 후, 원하는 vector에 이를 끼워넣은 후, 배양하여 단백질을 발현시키면 His 부위부터 단백질이 생성되기 때문에 금속에 친화성을 갖는 단백질이 된다. 단백질을 분리해 낸 후엔 washing 과정을 거치는데 이 과정에서는 Imidazole이 쓰인다. Imidazole은 His과 구조적으로 유사하다. 때문에 이미다졸은 His과 경쟁하여 His이 금속으로부터 떨어져나가게 유도한다. 결론적으로 원하는 단백질만 남는다. 금속으로는 니켈이 가장 많이 쓰인다. 이러한 방법을 Affinity Chromatography라고 한다. . . 이 실험 노트에서 사용된 레진은 Thermo scientific사의 레진이며, 니켈로 인해 푸른색을 띄는 것을 볼 수 있다. 이 니켈 이온을 함유하는 구슬이 His-tag과 결합하여 단백질을 붙잡아 놓으면, 단백질 이외의 다른 물질들이나 다른 단백질을 걸러낼 수 있게 된다. . . 단백질만 남게 되면, His을 대체할 수 있는 이미다졸(Imidazole)을 이용하여 다시 단백질을 뽑아낼 수 있다. . &#51060;&#48120;&#45796;&#51320;(Imidazole) . 이미다졸은 물에 용해되어 약 알칼리성을 띄는 흰색 또는 무색의 고체이다. 인접하지 않은 질소 원자를 갖는 방향족 헤테로고리 화합물이다. . . Affinity chromatography는 다른 chromatography에 비해 정제효율과 회수율이 높으며, 한 번에 많은 시료를 처리할 수 있다는 장점이 있다. 따라서, 단백질의 정제에 있어서 우선 affinity chromatography를 사용하는 것을 고려한다. . &#51060;&#50808;&#51032; chromatography . 단백질은 분자량, 전하(등전점), 소수성, 생리활성(화학적 반응성) 등이 서로 제각각이다. fig. Gel filteration chromatography의 개략도 . Cell Lysis . 특정 미생물은 세포 밖으로 단백질을 배출한다. 이럴 경우에는 단백질이 세포 밖에 있으므로 세포만 제거하면 된다. 그러나 BL21은 세포 내에서 단백질이 생성되므로 세포를 파쇄하여 단백질을 얻어야 한다. 이를 Cell Lysis(또는 Lysis)라 한다. 아래의 위키피디아의 영어 정의가 조금 더 명확하여 인용한다. . Lysis is the breaking down of the membrane of a cell, often by viral, enzymic, or osmotic(삼투) mechanisms that compromise its integrity(온전한 상태). . 위 표현을 빌리자면 셀의 membrane을 제거하여 온전한 상태를 깨는 것이다. 파쇄 된 세포는 원심분리를 거치게 되는데, 원심분리의 결과는 불용성 물질과 가용성 물질로 분류할 수 있다. . &#45824;&#51109;&#44512;&#50640;&#49436; &#45800;&#48177;&#51656;&#51032; &#48516;&#54252; . target gene+vector가 삽입된 대장균(DH5α/BL21)은 자신이 살아남기 위해 필요한 단백질 이외의 단백질들(곧 우리가 원하는 단백질들)을 세포 밖으로 배출한다. 그러나 자신에게 필요한 단백질들은 세포 내부에 둔다. 위 그림에서는 Cytoplasm으로 표시되어 있다. 세포 외부로 배출하는 단백질은 수용성 단백질, 세포 내부의 단백질은 불용성 단백질이다. 때로는 outer membrance와 inner membrance 사이에 단백질이 존재하기도 한다. 이 영역을 Periplasm이라 부른다. . &#48520;&#50857;&#49457; &#47932;&#51656;(insoluble particles) . 불용성 물질은 침전물을 말한다. 불용성 단백질은 물이 아닌 염, urea(8M) 또는 gaunidine HCl(6M)에 녹는다. . &#44032;&#50857;&#49457; &#47932;&#51656;(soluble particles) . 가용성 물질은 상등액을 말한다. 주로 세포막 내의 세포질들이 이에 해당한다. . Cell Lysis&#47484; &#54616;&#45716; &#49464; &#44032;&#51648; &#48169;&#48277; . 초음파(ultrasonic) 현탁액에 초음파를 주사하는 방식이다. | . | 고압 세포보다 작은 구멍을 뚫은 후, 압력을 가하여 세포가 쪼개지지 않고서는 구멍을 통과할 수 없게 만든 방법이다. 기기는 French Press와 Microfludizer가 있다. French Press 한 번에 깰 수 있는 셀의 양이 적다. | . | Microfludizer 현탁액이 몇 백 mL는 있어야 효과적이다. | . | . | . | 효소 및 화학물질 화학물질로는 urea(요소), guanidine HCl 등이 쓰이며, 효소로는 리소자임(lysozyme) 등이 쓰인다. 리소자임(lysozyme) 동물에 의해 생성되는 항균성 효소이다. 몸속으로 침투한 세균의 용해를 일으켜서 세균세포벽의 온전성을 위태롭게 만든다. 리소자임은 눈물, 침, 모유, 점액을 포함한 분비물에 풍부하다. 또, 대식세포와 호중성 과립구(PMN)의 세포질 과립부에도 존재한다. 상당한 양의 리소자임은 달걀의 흰자에서 볼 수 있다. | . | . | . | . 세포벽을 파괴하면 세포막이 나온다. 세포막은 지질 이중층으로 이루어져 있다. 따라서 세포막은 세포막 외부의 농도를 높이는 식의 삼투압 차이를 이용하여 손쉽게 깰 수 있다. 이를 &quot;cleared lysate(용해물)&quot;라 한다. . open column방법과 FPLC 방법 . &#45800;&#48177;&#51656; &#51221;&#47049; . 단백질 정량은 발현된 단백질의 양을 계산하는 것을 말한다. 발현된 단백질의 양을 계산하기 위해서는 단백질의 농도를 구해야한다. 이를 위해서는 target gene에 의해 생성되는 아미노산 조성을 통해 시스테인(Cysteine)의 개수와 이에 따른 흡광도를 알아야 한다. . EcoCyc: target gene&#51032; sequence&#47484; &#50508;&#50500;&#45240;&#45796;. . EcoCyc 사이트에서 target gene의 서열을 알아낼 수 있다. . target gene은 현재 rihB이다. . . rihB를 입력한 후 Gene Search를 클릭한다. . . Get Nucleotide Sequence를 클릭한다. . . atg로 시작하여 taa/tag/tga로 끝나는 부분까지가 target gene이며, 이를 복사한다. . atgGAAAAGA GAAAAATTAT TCTGGATTGT GATCCGGGTC ATGATGATGC TATTGCTATA ATGATGGCGG CGAAACATCC GGCAATAGAT TTATTAGGCA TCACTATTGT AGCGGGTAAT CAGACGCTTG ATAAAACATT AATTAATGGC CTGAATGTTT GCCAGAAACT GGAGATTAAT GTTCCGGTTT ATGCGGGGAT GCCGCAGCCC ATTATGCGTC AACAAATCGT TGCCGATAAT ATTCACGGTG AAACCGGACT GGATGGCCCG GTATTCGAGC CGCTGACCCG CCAGGCAGAA AGCACTCATG CGGTGAAATA TATCATTGAT ACCCTGATGG CAAGCGATGG CGATATCACT CTGGTGCCGG TTGGTCCGCT TTCAAATATC GCGGTGGCAA TGCGTATGCA ACCCGCGATC CTGCCCAAAA TCCGTGAAAT TGTGCTAATG GGCGGCGCTT ACGGTACAGG CAACTTCACG CCATCTGCCG AGTTCAACAT CTTTGCCGAC CCGGAAGCCG CACGCGTAGT GTTCACCTCC GGCGTTCCAT TAGTGATGAT GGGCCTCGAT CTCACCAACC AGACCGTTTG CACCCCGGAC GTGATTGCTC GGATGGAAAG GGCAGGCGGC CCCGCCGGAG AGCTGTTCAG CGACATCATG AACTTCACTC TCAAAACGCA GTTCGAAAAC TACGGCCTTG CTGGCGGCCC GGTGCACGAC GCCACCTGCA TCGGTTATCT GATTAACCCT GATGGCATTA AAACCCAGGA GATGTACGTC GAAGTGGACG TCAACAGTGG CCCTTGCTAT GGGCGTACCG TCTGCGACGA GCTGGGCGTT CTTGGCAAGC CCGCCAATAC CAAAGTCGGC ATCACTATTG ATACAGACTG GTTCTGGGGA TTAGTCGAAG AGTGCGTGCG CGGCTACATC AAAACCCATt aa . ExPASy: &#45800;&#48177;&#51656;&#50640; &#45824;&#54620; &#51221;&#48372;&#47484; &#50619;&#45716;&#45796;. . ExPASy 사이트에 접속한 후, . proteomics에 들어가서 translate을 클릭한다. . . 복사한 서열을 붙여넣는다. . . pET28 vector를 제한효소로 절단하여 target gene을 끼워넣는 것이기 때문에, pET28 vector의 제한효소 NcoI~NheI까지의 서열을 target gene의 앞에 붙여넣는다. . NcoI~NheI까지의 서열은 다음과 같다. . ATGGGCAGCAGCCATCATCATCATCATCACAGCAGCGGCCTGGTGCCGCGCGGCAGCCATATGGCTAGC . NcoI~NheI까지의 서열을 target gene앞에 붙인 최종 서열은 다음과 같다. . ATGGGCAGCAGCCATCATCATCATCATCACAGCAGCGGCCTGGTGCCGCGCGGCAGCCATATGGCTAGC atgGAAAAGA GAAAAATTAT TCTGGATTGT GATCCGGGTC ATGATGATGC TATTGCTATA ATGATGGCGG CGAAACATCC GGCAATAGAT TTATTAGGCA TCACTATTGT AGCGGGTAAT CAGACGCTTG ATAAAACATT AATTAATGGC CTGAATGTTT GCCAGAAACT GGAGATTAAT GTTCCGGTTT ATGCGGGGAT GCCGCAGCCC ATTATGCGTC AACAAATCGT TGCCGATAAT ATTCACGGTG AAACCGGACT GGATGGCCCG GTATTCGAGC CGCTGACCCG CCAGGCAGAA AGCACTCATG CGGTGAAATA TATCATTGAT ACCCTGATGG CAAGCGATGG CGATATCACT CTGGTGCCGG TTGGTCCGCT TTCAAATATC GCGGTGGCAA TGCGTATGCA ACCCGCGATC CTGCCCAAAA TCCGTGAAAT TGTGCTAATG GGCGGCGCTT ACGGTACAGG CAACTTCACG CCATCTGCCG AGTTCAACAT CTTTGCCGAC CCGGAAGCCG CACGCGTAGT GTTCACCTCC GGCGTTCCAT TAGTGATGAT GGGCCTCGAT CTCACCAACC AGACCGTTTG CACCCCGGAC GTGATTGCTC GGATGGAAAG GGCAGGCGGC CCCGCCGGAG AGCTGTTCAG CGACATCATG AACTTCACTC TCAAAACGCA GTTCGAAAAC TACGGCCTTG CTGGCGGCCC GGTGCACGAC GCCACCTGCA TCGGTTATCT GATTAACCCT GATGGCATTA AAACCCAGGA GATGTACGTC GAAGTGGACG TCAACAGTGG CCCTTGCTAT GGGCGTACCG TCTGCGACGA GCTGGGCGTT CTTGGCAAGC CCGCCAATAC CAAAGTCGGC ATCACTATTG ATACAGACTG GTTCTGGGGA TTAGTCGAAG AGTGCGTGCG CGGCTACATC AAAACCCATt aa . 이 서열대로 아미노산이 생성되며, 단백질이 생성된다. . . translate을 누른다. . . 결과물의 M을 누른다. . . Sequence analysis tools에서 ProtParam을 클릭한다. 별도의 창이 뜰 것이다. . . &#45800;&#48177;&#51656;&#51032; &#50577; &#44396;&#54616;&#44592; . 단백질 정제 후의 흡광도를 구한 후, 이 값을 0.643으로 나누면 단백질의 농도가 나온다. 농도X부피 = 단백질의 양이므로, 이를 통해 단백질의 양을 계산할 수 있다. . &#49892;&#54744; &#44284;&#51221; &#48143; &#44208;&#44284; . &#44512;&#51452; &#48176;&#50577; . &#50529;&#52404; &#44512;&#51452; &#48176;&#50577; . LB-Broth 100mL + Kanamycin 100μl → LB+Kan 항생제 접종은 전체 부피의 0.1%. 단위만 낮추면 된다. | . | LB+Kan 8mL → cap tube | BL21 glycerol stock 100μl → LB+Kan cap tube 8mL: 접종 균주 접종은 전체 부피의 1%., 따라서 80μl를 접종하는 것이 정석. 더 많은 용량을 넣은 이유는 glycerol과 BL21이 1:1 비율로 섞여 있다는 점을 고려하였기 때문 | . | incubator → 37°C → overnight | overnight → LB+Kan 8mL 중 5mL → LB+Kan 100mL → shaking incubator → 37°C, 2hr → 단백질 발현 유도 단계와 pre SDS-PAGE 단계로 이동 | . &#44256;&#52404; &#44512;&#51452; &#48176;&#50577; . 고체 배지에서 배양된 균주: 단백질 정제와 RT-PCR 에서 사용할 예정 . NaCl 5g/1L, Yeast Extract 5g/1L, Trypton 10g/1L, Agar 6g/1L | clean bench → pour → 식히기 → incubator → overnight | BL21 glycerol stock, DH5a glycerol stock → streaking | . . rihB+DH5a/pET28 균주에 대한 streaking을 다소 서툴게 한 것 같다. 액체 균주 상태일 때 pipetting을 충분히 수행한 후 inoculation loop에 충분히 적신 후에 streaking을 해야겠다. . &#49884;&#50557;, &#48260;&#54140; &#51228;&#51312; . Equilibrium Buffer(Suspension Buffer) . 5M NaCl 50mL + D.W. 440mL | 20mM Tris-HCl(pH 8.0) 10mL | . Washing Buffer . 5M NaCl 25mL + D.@. 215mL | 20mM Imidazole 5mL | 20mM Tris-HCl(pH 8.0) 5mL | . Elution Buffer . 5M NaCl 25mL + D.W. 170mL | 20mM Imidazole 50mL | 20mM Tris-HCl(pH 8.0) 5mL | . . &#44536; &#50808; &#49884;&#50557; &#51228;&#51312; . BPB: Bromophenol blue . &#45800;&#48177;&#51656; &#48156;&#54788; &#50976;&#46020; . 2hr 배양된 액체 균주 100mL + IPTG 1mM/mL → 1mL → EP tube: zero time: 단백질 발현 유도 시작 IPTG: 1M/1mL. 접종해야 할 농도는 1mM/1μl, culture된 LB+Kan은 100mL. → IPTG 100μl 접종 | IPTG를 넣은 후 3시간~5시간이 지나면 saturation된다. | . | shaking incubator → 37°C, every 1hr: 시간대 별 단백질 발현 확인 단계로 이동 | . &#49884;&#44036;&#45824; &#48324; &#45800;&#48177;&#51656; &#48156;&#54788; &#54869;&#51064; . 매 시간, 1mL 샘플링 → 4°C: 보관 필요한 샘플: zero time, 1hr, 2hr, 3hr, 4hr, 5hr | . | spectrophotometer X: 샘플의 OD값(흡광도)이 이상적이라 가정함 | sample 6개 → centrifuge → 12000rpm, 5min → 상등액 discard: LB-Kan 배지 제거가 목적 | D.W. 100μl → 각 sample 6개 → vortexing | 각 sample 6개 + 2X SDS-PAGE buffer 100μl → pipetting | Heat-block → 95°C, 10min | centrifuge → 12000rpm, 1min | . pre SDS-PAGE . 2hr 배양된 액체 균주 100mL 중 시간대 별 단백질 발현에 사용된 후의 남은 액체 균주 → 50mL conical tube → centrifuge → 3500rpm, 20min → 상등액 discard → loop: cell down | pellet → -4°C: 보관: Harvest | suspension buffer(equilibrium buffer) 25mL → pellet → pipetting pellet : buffer = 1 : 20으로 맞추어야 하지만, 해당 실험에서는 25mL의 buffer를 넣는다. | . | 초음파(ultrasonic) 파쇄, 10min | . 보통 probe가 용액 표면으로부터 0.5~1cm정도 잠기게 해야한다. 또한, 시간이 지남에 따라 probe의 위치를 재조정 할 필요가 있을 수 있으므로 초음파 파쇄기 앞에서는 대기해야 한다. . . 초음파 파쇄기의 계기판에 위 사진의 빨간색처럼 실시간으로 probe의 위치 정보가 나온다. 위 사진과 같은 수준이면 probe를 조금 더 용액에 잠기게 해야 한다. 이럴 경우, 초음파가 발생되지 않는 30초 동안에 위치를 조정한다. . . centrifuge → 20000rpm, 30min | . . 상등액(clear lysate 또는 License) 회수 → 4°C: 보관 추후 FPLC에서 사용될 예정 | . | . Analysis of SDS-PAGE: &#45800;&#48177;&#51656; &#48156;&#54788; &#54869;&#51064; . running gel &#51228;&#51089; . 0.75M Tris(pH 8.8) 3.75mL | 30% Acryl-bis 3mL | 10% SDS 75μl | D.W. 0.65mL | 25% APS 25μl | TEMED 6μl → 굳으므로 슬릿에 분주하기 직전에 넣을 것 | . stacking gel &#51228;&#51089; . 0.25M Tris(pH 6.8) 1.45mL | 30% Acryl-bis 0.375mL | 10% SDS 37.5μl | D.W. 1.45mL | 25% APS 15μl | TEMED 5μl → 굳으므로 슬릿에 분주하기 직전에 넣을 것 | . [→티슈에 물을 묻힌 후 랩으로 감싸 보관하여 gel의 건조 방지] . Sample 6개 → centrifuge → 13000rpm, 5min → 상등액 discard | EP tube(pellet) + 멸균수 100μl → pipetting | 2X SDS PAGE sample buffer 100μl → EP tube → pipetting | Loading Buffer 들어간 남은 시료 → -4°C: 보관 | Heat-block → 95°C, 10min | centrifuge → 12000rpm, 1min [→ -20°C: 보관] | 다음의 조건으로 loading size marker는 뚜껑에 pre-stained, tube면에 PM001 0.5mL EZ(TM) Prestained Protein Ladder Marker라고 쓰여진 마커를 사용 | . | . . . SDS-PAGE gel running 조건: 100V, 약 1 시간 | . . . gel → destaining solution → 5min waiting → discard → staining solution 1hr waiting → destaining 10min → destaining 10min → ...:염색약 빼는 과정 | . &#44208;&#44284; &#54644;&#49437; . Fig. Analysis of SDS-PAGE. size marker: protein size marker; zero time: Un-induced with IPTG; 1hr, 2hr, 3hr, 4hr, and 5hr: induced with IPTG. . gene cloning된 BL21(rihB+pET28)이 IPTG에 의해 발현한 단백질의 분자량은 33,748Da이다. 또한 미생물은 본인이 살아가는데에 필요한 단백질을 스스로 생산한다. 이 단백질의 분자량이 2,470.69Da이다. 두 분자량의 합 36,218.69Da이 SDS 아크릴아마이드 겔에서 올바르게 보여지고 있다. . &#45800;&#48177;&#51656; &#51221;&#51228; . 정제에서 washing은 매우 중요한 과정이다. 처음엔 이미다졸(Imidazole)이 없는 버퍼인 Equilibrium buffer (또는 Suspension Buffer)로 washing을 수행한다. 그 다음엔 Imidazole을 서서히 높이면서 단백질이 안 나올 때 까지 washing을 수행한다. 정제 후에는 SDS-PAGE를 다시 수행하여 해당 사이즈 마커 부근에서 단백질이 뜨는지 재차 확인하는 과정을 거친다. (다른 단백질들은 뜨면 안 된다.) . 배양액 50μl → Ep tube 1: 정제 전 | Equilibrium(Suspension) Buffer 충분한 양 → open column → discard: 세척 | 배양액 10μl → open column → 50ml conical tube 1 | Suspension buffer 5ml → open column → conical tube 1 → 50μl → EP tube 2: 정제 후 | Washing buffer 10ml → open column → 50ml conical tube 2 | Washing buffer 5ml → open column → 50ml conical tube 2 → 50μl → EP tube 3: washing | Elution buffer 3ml → open column → 50ml conical tube 3 → 50μl → EP tube 4: Elution 1 | Elution buffer 3ml → open column → 50ml conical tube 4 → 50μl → EP tube 5: Elution 2 | Elution buffer 3ml → open column → 50ml conical tube 5 → 50μl → EP tube 6: Elution 3 | Elution buffer 3ml → open column → 50ml conical tube 6 → 50μl → EP tube 7: Elution 4 | Elution 6ml → open column → discard | Suspension buffer 30ml → open column → discard | Suspension buffer 6ml → open column: 보관 | EP tube(Elution 1, Elution 2, Elution 3, Elution 4) 냉장 보관: FPLC에서 사용할 예정 | . Analysis of SDS-PAGE: &#45800;&#48177;&#51656; &#51221;&#51228; &#54869;&#51064; . running gel &#51228;&#51089; . 0.75M Tris(pH 8.8) 3.75mL | 30% Acryl-bis 3mL | 10% SDS 75μl | D.W. 0.65mL | 25% APS 25μl | TEMED 6μl → 굳으므로 슬릿에 분주하기 직전에 넣을 것 | . stacking gel &#51228;&#51089; . 0.25M Tris(pH 6.8) 1.45mL | 30% Acryl-bis 0.375mL | 10% SDS 37.5μl | D.W. 1.45mL | 25% APS 15μl | TEMED 5μl → 굳으므로 슬릿에 분주하기 직전에 넣을 것 | . [→티슈에 물을 묻힌 후 랩으로 감싸 보관하여 gel의 건조 방지] . Sample 6개 → centrifuge → 13000rpm, 5min → 상등액 discard | EP tube(pellet) + 멸균수 100μl → pipetting | 2X SDS PAGE sample buffer 100μl → EP tube → pipetting | Loading Buffer 들어간 남은 시료 → -4°C: 보관 | Heat-block → 95°C, 10min | centrifuge → 12000rpm, 1min [→ -20°C: 보관] | 다음의 조건으로 loading | . . SDS-PAGE gel running 조건: 100V, 약 1 시간 | gel → destaining solution → 5min waiting → discard → staining solution 1hr waiting → destaining 10min → destaining 10min → ...:염색약 빼는 과정 | . &#44208;&#44284; &#54644;&#49437; . Fig. Analysis of SDS-PAGE. size marker: protein size marker; BP: Before Purification; AP: flow thorugh After Purification; W: after washing solution; Elu1, Elu2, Elu3, Elu4: after Elution buffer. . 정제하지 않은 상태에서 보였던 여러 발현 단백질들이 정제하는 과정을 거친 후엔 보이지 않으며, 35kDa 부근에서 원하는 단백질이 남아있는 것을 확인할 수 있다. 이는 rihB+pET28에 의해 발현된 단백질에 His-tag이 붙어 있었던 덕분으로, 레진에 의해 다른 불순물들이 빠져나갈 때 빠져나가지 않고 이미다졸에 의해 분리되어 빠져 나왔기 때문이다. 분자량은 36,218.59Da이므로, 단백질이 올바르게 정제되었음을 알 수 있다. . 겔이 오른쪽 위로 휘어진 이유로 사진 상에 보여지는 밴드들이 오른쪽 위로 점점 올라가는 것처럼 보이지만, 모두 같은 선상에 있는 밴드들이다. . FPLC . Reference . https://en.wikipedia.org/wiki/Lysis | https://ko.wikipedia.org/wiki/리소자임 | https://www.bio-rad.com/ko-kr/applications-technologies/introduction-affinity-chromatography?ID=MWHAVG4VY | https://www.thermofisher.com/kr/ko/home/life-science/protein-biology/protein-biology-learning-center/protein-biology-resource-library/pierce-protein-methods/overview-affinity-purification.html | https://www.nanoprobes.com/products/Ni-NTA-Nanogold-His-tag-labeling-and-detection.html | .",
            "url": "https://tfedohk.github.io/dohk/expression-and-purification-of-protein/",
            "relUrl": "/expression-and-purification-of-protein/",
            "date": " • Sep 16, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "액체와 고체의 밀도 측정 및 정밀도(precision), 정확도(accuracy) 구하기",
            "content": "어떤 물질의 물리적 성질은 위키피디아에 의하면 다음과 같다. . 물리적 성질 위치, 전기장, 끓는점, 녹는점, 팽창, 이동, 질량, 압력, 색, 밀도, 부피, 길이, 강도, 온도, 비중, 열전도율, 비열, 선팽창계수, 자성, 전기전도율, 열전도율 | . | . 이 노트에 기술되는 실험은 어떤 용매의 물리적 성질 중 밀도를 측정하고 이에 대한 정확도와 정밀도를 구하는 것이 목적이다. . &#49892;&#54744;1: &#48128;&#46020; &#52769;&#51221; . 어떤 물질의 정체를 모를 땐 밀도를 재면 알 수 있다. 아르키메데스의 원리(부력의 원리)와 같다. . 부력의 원리 물체의 부분(혹은 전체)이 유체에 잠기면 그 물체가 차지하는 부피에 상응하는 물의 무게 만큼의 힘이 물체에 가해진다는 원리 | 각 물질들은 고유한 밀도를 가지고 있다. | 어떤 두 물질의 부피가 같다면, 위 수식에 의해 밀도가 클수록 질량이 크다. | 순금처럼 일반적으로 사각형인 물질은 측정이 용이하지만 금관같은 모양이 복잡한 물질은 부피 측정이 어렵다. 하지만 같은 질량일지라도, 다른 물질이라면 밀도가 다르므로 부피가 다를 것이고 같은 물질이면 부피가 같아야 한다. | . | . 사용할 용매는 아이소프로판올(isopropyl alcohol), 다이메틸 설폭사이드(Dimethyl sulfoxide;DMSO), 에탄올(EtOH)이다. . 주어진 용매의 밀도를 측정하기 위해 10mL 파이펫을 이용해 용매를 aspiration한 후, 밸런스와 50mL 비이커를 이용하여 무게를 잴 것이다. . TD와 TC개념 TC는 to contain을, TD는 to deliver를 의미한다. TC가 표시된 파이펫(또는 용기)의 경우, 파이펫(또는 용기)에 담기는 액체의 양이 파이펫에 표시된 눈금과 정학히 일치한다는 것을 의미한다. 반면 TD로 표시된 파이펫(또는 용기)의 경우, 옮기려는 액체의 양이 파이펫에 표시된 눈금과 일치함을 의미한다. 이는 TC에 쓰이는 재질과 TD에 쓰이는 재질의 차이이며, TD로 표시된 파이펫을 이용하여 액체를 옮기고자 할 땐 방울 몇 개가 큰 영향을 주지 않음을 의미한다. | . | . &#49892;&#54744; &#44284;&#51221; . 50mL 비이커의 무게를 0점으로 설정한다. | 10mL 파이펫을 이용하여 용매 10mL를 뽑는다. | 50mL 비이커에 이를 넣고 무게를 측정하고 기록한다. | 하나의 미지시료에 대하여 4번을 반복하고 평균을 구하여 이론밀도와 비교한다. | . &#49892;&#54744; &#44208;&#44284; . 분산(std)은 엑셀의 STDEV.P 함수를 이용하였다. 엑셀에는 분산을 구하는 세 개의 함수(stdev.p, stdev.s, stdev)가 있다. 이 중, stdev는 사용이 지양되며, stdev.p는 제시한 자료가 샘플의 전부일 때, 제시한 자료가 전체의 일부일 경우에는 stedev.s를 사용한다. | . | 측정은 10mL 파이펫을 이용했으나, 밀도값을 구하기 위해서는 단위 보정이 필요하다. 따라서 측정값과 함께 밀도값을 기록하였다. | . &#49892;&#54744; &#44208;&#44284; &#54644;&#49437; . 실험1의 결과에 대한 해석은 실험2를 진행해야 의미가 있지만, 눈대중으로 보아도 평균값과 이론밀도가 유사한 것을 확인할 수 있다. . &#49892;&#54744;2: &#48516;&#49437;&#53685;&#44228;&#44050; &#49328;&#52636; . 실험1에서 구한 밀도값을 통해 정밀도(precision)과 정확도(accuracy)를 구할 수 있다. . &#51221;&#48128;&#46020;(precision) . 정밀도는 반복시험을 통해 얻은 결과를 상대표준편차(Relative Standard Deviation; RSD)로 나타내는 것을 말한다. 측정한 횟수 n에 대한 평균값에 대한 표준편차의 비율로 정의된다. 위 수식에 따르면 편차가 작을수록 정밀도가 낮아지는 것을 확인할 수 있으며, 정밀도는 낮은 값을 가질수록 좋다고 할 수 있다. . &#51221;&#54869;&#46020;(accuracy) . 정확도는 시험분석 결과가 얼마나 참값에 근접하는지를 나타낸다. 동일한 매질의 인증시료를 확보할 수 있는 경우, 표준절차서(Standard Operational Procedure; SOP)에 따라 인증표준물질을 분석한 결과값(Cm)과 인증값(Cc)과의 상대적 백분율로 구할 수 있다. 즉, 참값(Cc)에 대한 반복시험을 통해 얻은 측정값의 평균값(Cm)의 비율로 정의된다. 정확도는 그 값이 높을수록 좋다. . 정리하자면, 정밀도는 평균으로 표준편차를 나눈 비율을, 정확도는 이론밀도로 평균을 나눈 비율을 의미한다. . &#49892;&#54744; &#44208;&#44284; . 실험자의 편향에 의한 오차 발생 정밀도와 정확도는 사람마다 파이펫의 눈금보다 위, 또는 아래로 측량하는 기준이 다르기 때문에 그 값이 달라질 수 있다. 즉, 실험하는 사람에게 편향된 결과가 나올 수 있다. | . | 기계적인 편중에 의한 오차 발생 . 파이펫이나 저울이 교정되어 있지 않다면 실험자가 정확히 측량했어도 정확한 값이 아닐 수도 있다. | . | 파일: https://drive.google.com/file/d/1rAUFbQ-FKUEno8itYewEiL1rPG8NTxTy/view?usp=sharing . | . &#49892;&#54744; &#44208;&#44284; &#54644;&#49437; . 정밀도가 모두 1% 미만으로 나왔다. 이는 정밀하게 측정되었음을 의미한다. . 정확도는 다소 아쉬운데, 95% 미만으로 떨어지지는 않았다. 실험자의 편향에 의한 오차 또는 기계적인 편중에 의한 오차 둘 중 기계적인 편중에 의한 오차라고 추정되어 진다. 실험을 할 당시, 클래스의 많은 사람들이 돌아가면서 실험을 했는데 저울의 밸런스가 그 사이에 달라졌을 가능성이 있다. 실험자의 편향에 의한 오차의 가능성도 존재하는데, 각 사람이 용매를 하나씩 맡아서 측량했기 때문에 제각각의 결과가 나올 수 있다고 보여진다. . Reference . https://ko.wikipedia.org/wiki/물리적_성질 | https://blog.naver.com/miseos/220911830468 | https://www.westlab.com.au/blog/2017/07/19/what-is-the-difference-between-td-and-tc-pipettes | .",
            "url": "https://tfedohk.github.io/dohk/Chemistry-experiment_note-measurement_of_density_precision_acc/",
            "relUrl": "/Chemistry-experiment_note-measurement_of_density_precision_acc/",
            "date": " • Sep 15, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "흡광도(absorbance)",
            "content": "분석을 위해서는 분석의 대상이 되는 물질이 흡광이 되어야 한다. 같은 Fe라고 해도 무엇과 결합했는가에 따라 흡광도가 다르다. . &#44160;&#47049;&#48277; . 검량법이란, 어떤 미지물질의 농도를 측정할 때 비례성을 이용해 미지농도를 산출하는 것을 말한다. 대표적으로 검량성 작성법(Calibration curve method), 표준물 첨가법(Standard addition method), 내부표준법(Internal standard method)이 있다. . &#44160;&#47049;&#49440; &#51089;&#49457;&#48277;(Calibration curve method) . 일반적으로 가장 많이 사용되는 방법이다. 표준용액을 만들어 흡광도를 측정하여 검정곡선을 만든 후, 미지시료의 흡광도를 측량하여 3~5개의 농도값을 통해 역으로 미지시료의 농도를 산출하는 방법이다. 검량선을 만들기 위해서는 최소 세 개의 농도의 표준용액 스펙트럼을 측정해야 한다. 이상적인 상황은 측정된 모든 표준값이 일직선 위에 놓이는 것이지만, 실제로는 다소 분산된 경향을 보인다. . 검량선을 결정할 때 보통 최소자승법 등의 통계적 방법을 적용한다. 이때 R^2 상관계수값을 구하게 되는데, 이 값이 1에 근접해야 한다. 적어도 0.99이상은 나와야 한다. . &#54364;&#51456;&#47932; &#52392;&#44032;&#48277;(Standard addition method) . 미지시료에 미지시료 이외의 물질이 섞여있을 경우, 이미 알고 있는 표준 분석물질을 미지시료에 넣어 분석 후, 미지시료 중의 분석물질의 양을 알아내는 방법이다. 대부분의 시료가 화학적, 물리적으로 방해되는 성분들을 함께 포함하고 있다. 표준물 첨가법은 이에 대한 대안이다. . &#45236;&#48512;&#54364;&#51456;&#48277;(Internal standard method) . 실험에 따라 많은 시료를 한 번에 돌릴 때, 시약의 성질(pH 등)이 변할 수 있다. 시간에 따라 달라질 수 있는 이러한 경우에 내부표준법을 사용한다. . &#55137;&#44305;&#46020;&#50640; &#50689;&#54693;&#51012; &#48120;&#52824;&#45716; &#50836;&#49548; . &#50857;&#47588; . 흡광도를 알아내기 위해서는 UV visible 기계를 사용한다. 대표적으로 spectrophotometer가 있다. 위의 예시는 같은 아세톤이라 하더라도 물과 섞였을 때의 아세톤과 hexane과 섞였을 때의 아세톤의 흡광도가 다름을 보여준다. 기본적으로 카본 구조는 발색이 가능하며, 아세톤은 구조적으로 자외선 영역(10에서 400나노미터의 파장 영역)에서 강하게 흡광을 하는 성질을 가진다. . | 아세톤은 비공유전자쌍을 가졌다. 따라서 아세톤은 물분자와 수소결합을 할 수 있다. 아세톤이 물과 섞였을 때의 흡광도와 hexane과 섞였을 때의 흡광도가 다른 이유는 주변 이웃 용매들의 결합 참여 유무에 따라, 패턴이 달라지기 때문이다. 물과 섞이는 경우엔 수소결합으로 인해 파장이 변하는 경우다. . | 어떤 물질을 분석한다고 할 때, λmax(제일 높은 파장)를 보면 그게 어떤 물질인지를 살펴볼 수 있는데, 이때 같은 물질이라 하더라도 어떤 물질과 섞였는지에 따라 파장이 달라진다. 따라서 UV visible 방법을 사용할 땐 이러한 점을 고려해야 한다. . | 이는 모두 용매의 극성, 용매의 농도, pH, 시료의 온도 등 용매의 특성으로 인한 흡광도의 변화다. . | . &#45824;&#54364;&#51201;&#51064; &#50857;&#47588; . 용매로 쓰이는 물질로는 대표적으로 아래의 표와 같이 D.W., Hexane, 에탄올, 메탄올, Cyclohexane, Chloroform, DMSO(Dimethylsulfoxide), 아세톤 등이 있다. . &#54620;&#44228;&#54028;&#51109;(cut off) . 한계 파장(cut off)이란, 흡광이 일어나는 부분이다. 용매에는 각자 자신의 한계파장(cut off)을 가진다. 이 한계파장 이상의 파장을 가지게 되면 흡광이 가능하다. 카페인을 분석하려고 할 때, 아세톤을 넣으면 흡광되지 않는데, 카페인은 270nm부근에서 흡광이 가능한데, 331nm부근이 한계파장인 아세톤에 흡광 가능한 파장이 묻혀서 흡광이 되지 않는다. 그러므로 아세톤을 용매로 사용하는 것은 부적절하다고 볼 수 있다. 따라서 한계파장을 반드시 알아야 시료에 대한 분석이 가능하다. . &#48708;&#44277;&#50976; &#51204;&#51088;&#50640; &#51032;&#54620; &#45824;&#52404; &#54952;&#44284; . case: butylphenol . 페놀은 방향족에 hydroxyl group(-OH기)이 붙은 것이다. 페놀에서 수소가 빠져나가면 음이온의 상태가 되는데, 수소이온의 탈주로 인해 수소이온의 농도가 높아져 pH에 변화가 생긴다. 따라서 흡광도가 높아지게 된다. 보라색 그래프가 해당 파장의 모습을 보여주고 있다. . . case: aniline . aniline과 anilium salt의 경우도 마찬가지라고 할 수 있다. . . 물 속에서의 이온 상태는 화학 구조가 바뀐 것이 아닌 수소 이온이 붙고 떨어지는 상태의 변화이다. 따라서 이로 인한 흡광도 변화가 발생할 수 있다. . &#960; Conjugation &#54952;&#44284; . 이중결합의 개수에 따라서도 흡광의 양과 패턴이 달라진다. 이중결합은 흡광을 잘하는 구조다. . &#54872;&#44221;&#48516;&#49437;&#50640;&#49436;&#51032; &#55137;&#44305;&#46020; &#52769;&#51221; . 인, 질산, 아질산 등의 무기물도 UV 측정이 가능하지만, 그 자체로는 잘 측정 되지 않는다. 이들은 이온인데, 이온은 무색이다. 따라서 이온을 발색시약(염료)과 반응을 시켜야 한다. 즉, 발색시료를 담은 후, 표준용액을 제조하고 미지시료를 만들어 발색에 들어간다. 이렇게 하면 미지시료가 특정 파장을 띄게 되어 흡광이 가능하게 된다. 먹는 물과 공기, 중금속 여부, 박테리아, 대장균 등 많은 것들이 이렇게 검사된다. . &#55137;&#44305;&#46020; &#52769;&#51221;&#51032; &#50696; . &#48268;&#44992; &#50976;&#53685;&#44592;&#54620; . 벌꿀은 변하지 않으므로 유통기한이 없다. 그럼에도 유통기한이 정해져 있다. 이는 fructose의 변하는 정도를 기준으로 한 것이다. 벌꿀은 시간이 지남에 따라 HMF라는 물질을 생성해낸다. HMF는 유독한 물질은 아니다. 다만, 온도가 높거나, 오래되면 HMF가 증가되는데, 이를 UV로 검출한다. HMF는 위 그림에서와 같이 산소가 많고 이중 결합이 있어서 흡광이 잘 된다. 290nm부근에서 흡광이 가장 높은데, 벌꿀1이 벌꿀2보다 해당 부근에서의 흡광도가 높으므로 벌꿀1이 더 오래된 벌꿀인 것을 알 수 있다. . &#50976;&#49324;&#49437;&#50976; &#49324;&#44256; . 해당 사고는 유사석유 때문에 발생한 것. 자동차는 휘발유에 적합하게 설계되어 있는데, 유사석유는 자동차 부품을 망가지게 한다. 또한 가스 성분도 달라지므로 위험하다. 이 사고는 판매점이 본사가 제공한 석유가 아닌 유사석유를 판매하여 발생하였으므로 본사가 암행어사처럼 불시에 판매점을 검사하는 방식을 쓰는데, 이때 UV 검사가 시행된다. 표준용액과 미지시료를 검사하는 것. 즉, 본사의 것과 판매장에서의 것을 검사한다. 흡광도가 다르면 희석되었거나 다른 물질이라는 것이 드러나게 된다. . Reference . https://ko.wikipedia.org/wiki/자외선 | https://m.blog.naver.com/PostView.nhn?blogId=nanomate&amp;logNo=110161377030&amp;proxyReferer=https:%2F%2Fwww.google.com%2F | .",
            "url": "https://tfedohk.github.io/dohk/Chemistry-absorbance/",
            "relUrl": "/Chemistry-absorbance/",
            "date": " • Sep 15, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "NGS Application-Variant Calling",
            "content": "Introduction . NGS 기계를 통해 얻은 raw data는 기본적으로 리눅스 시스템에서 처리된다. 이때 사용되는 툴킷은 대표적으로 broad institute에서 만든 GATK가 있다. 이번 노트에서는 NGS의 여러 응용(Application) 중 Variant calling에 대해 다룬다. 본 자료는 cornell university의 workshop자료를 기반으로 한다. . Variant Calling . &#51221;&#51032; . variant는 유전적변이를 의미한다. (네이버 사전) variant call은 genome 혹은 transcriptome에서 reference genome과 뉴클레오타이드 서열에 차이가 있는지를 살펴보는 것을 말한다. 즉, reference genome의 시퀀스와 대상 genome 시퀀스 상의 변화를 찾아낸다. 즉, SNP를 찾아낸다. . SNP란 인구 집단에서 1% 이상의 빈도로 존재하는 2개 이상의 대립 염기서열이 발생하는 위치를 말한다. 각 샘플의 Read data (D)로부터 샘플의 Genotype (T)을 알아내려면 Genotype이 나올 확률을 Bayesian rule을 이용하여 계산하게 된다. SNP 외에 염기서열 상의 insertion, deletion 등의 mutation도 찾아낸다. . Individual 1은 시퀀스를 하려는 특정한 사람의 DNA. 혹은 정상세포에서 얻은 DNA, Individual 2는 또 다른 사람의 DNA, Individual 3는 암 환자에게서 추출한 세포에서 얻은 DNA라고 가정해보자. 이렇게 서로 다른 세포에서 얻은 두 genome의 차이를 살펴, 암을 유발하는 사이트를 알아내려는 것이 목적이다. 보통 휴먼지놈은 30억 bp다. 이를 통째로 시퀀싱 하지 못하므로, 잘게 잘라낸다. 이를 통해 작은 read들을 NGS를 통해 얻어내고 그 결과들을 이어붙여 원래의 whole genome 시퀀스를 확보한다. 그 후에 상호 간의 시퀀스를 비교한다. 이러한 과정들은 사람이 직접 할 수 없으므로 프로그램에 맡긴다. NGS 기계에서 최종적으로 나오는 output은 FASTQ 포맷의 파일이며 그 예는 다음과 같다. FASTQ에 대해서는 후반부에 다룬다. . 이런 류의 파일을 모은 후, FASTQ 파일에 있는 데이터들에 대한 align을 수행하게 된다. 중첩된 것들은 따라가면서 전체 시퀀스를 어우르게 된다. . reference genome sequence는 휴먼 지놈 프로젝트를 통해 밝혀진, 이미 알려진 genome sequence다. 사람에 대한 reference sequence는 이미 존재하므로 이를 기반으로 FASTQ 파일로부터 align된 시퀀스들을 reference sequence로 맵핑한다. 이 과정에서 GATK가 사용된다. . GATK . NGS 기계를 통해 얻은 raw data는 GATK 툴킷으로 주로 처리된다. GATK 외에 SAMtools, glfTools, Atlas2가 있다. GATK는 Bayesian 모델을 이용하고, 알고리즘은 MapReduce를 이용하여 분산 처리가 가능하다는 장점이 있다. GATK는 java program으로 짜여져 있다. 휴먼 지놈 프로젝트는 2000년대에 완성되었다. 그 후, 1000 명에 대한 genome sequencing 즉, 1000 genome project가 진행되었고 현재는 종료된 상태다. 이때 발생한 패키지가 GATK다. 자바로 짜여진 프로그램이며, command-line의 툴이기 때문에 명령창에서 명령어를 입력해야 사용할 수 있다. 추가적으로 명령어 뒤의 옵션에 따라 다음의 일을 수행할 수 있다. . NGS data processing | variant discovery | variant filtering | genotyping | evaluation(평가 기능) | parallel processing on HPC clusters(병렬 처리 기능) 병렬 처리 일반적인 소프트웨어는 하나의 CPU에 하나의 코어를 점유한다. 즉, 싱글 코어를 사용한다. 그러나 병렬 처리를 한다는 것은 여러 코어(또는 여러 쓰레드)를 점유하여 빠르게 처리하는 것을 말한다. 즉, 계산할 데이터를 나누어 각 CPU 코어에 계산을 맡긴다. 이때 CPU 내의 여러 코어를 사용할 수도 있고, 쓰레드를 사용할 수도 있다. | GATK 실행 시, 명령 옵션을 통해 쓰레드 수를 지정할 수 있다. | 그러나 단순히 쓰레드 수를 늘린다고 속도가 높아지는 것은 아니다. 즉, 쓰레드 수에 따라 선형적인 성능을 보장하지 않는다. 이는 오버헤드가 발생하기 때문이다. 일을 나누어주는 것 자체가 일이며, 분산시킨 작업의 결과를 취합하는 것 또한 CPU에겐 부담이다. 따라서 여러 코어, 여러 쓰레드를 쓰는 것이 선형적인 성능을 보장하지 않는다. 일반적으로 8~10개 정도가 적당하다. | . | . | . GATK에 대한 BEST practice는 다음의 사이트에서 참고할 수 있다; https://gatk.broadinstitute.org/hc/en-us . NGS data Analysis Pipeline . NGS 데이터를 처리하기 위한 일련의 과정을 파이프라인으로 정의할 수 있다. 각 과정에서는 서로 다른 소프트웨어가 쓰일 수 있으며 어떤 소프트웨어의 output이 검증 과정을 거친 후 다른 소프트웨어의 input이 된다. 즉, input으로 raw data를 주면 자동으로 다음 단계들을 알아서 실행하여 최종적으로 원하는 output이 나오도록 설계하는 것을 파이프라인이라고 한다. 일련의 작업들을 알아서 수행하는 매크로와도 같은 개념이다. 이렇게 파이프라인 만드는 것이 BI 회사들이 주로 하는 일이다. 파이썬, 쉘 스크립트 등을 이용하여 이러한 파이프라인을 구축할 수 있다. . A. Data Cleanup . . 먼저, NGS 기계로부터 raw reads를 받는다. 이 데이터는 fastq 포맷의 파일이다. | 그 다음엔 해당 파일 내의 데이터를 전처리한다. 불필요한 부분을 잘라내고, 필요한 부분만을 추려내는 과정이다 (실제 사용 예는 하단에 있음). 이렇게 처리된 데이터의 quality를 검증한 후, BWA 소프트웨어를 이용하여 Reference mapping을 수행한다. | Alignment(또는 Mapping)가 완료된 후에는 sorting을 수행한다. sorting이 필요한 이유는 인덱싱 작업을 하기 위해서다. 데이터베이스 상에서 인덱싱 된 데이터일 경우 빠르게 검색 가능하기 때문이다. 이때 picard 소프트웨어가 쓰인다. 이는 다음 작업인 duplicate를 제거하는 작업을 빠르게 한다. | . | duplicate를 체크하고, 제거한다. 과정 4까지는 Non-GATK 즉, GATK가 쓰이지 않는다. 과정 5, 6은 GATK가 쓰인다. | . | 그 후 indel(insertion-deletion) realignment 처리 후, | base recalibration을 수행 과정 6까지 끝나고 난 output: analysis-ready reads. | 이로써 Variant Discovery를 위한 기본적인 준비는 끝이 났다. | . | pair of FASTQ files . 위 그림은 각 샘플에 대한 작업을 의미한다. 모든 과정에서, 샘플은 하나가 아닌 여러 샘플을 동시에 처리하는 경우가 대부분이다. 사람마다 genome은 다른데 reference sequence는 딱 하나다. 즉, 질병에 의한 variaion 뿐만 아니라 사람 간의 variation도 존재한다. 우리의 목적이 무엇이냐에 따라 다르겠으나, (어떠한 genotype이 어떠한 phenotype을 나타내는지에 관심이 있는 경우도 있다.) 주로 질병 치료, 진단 등이 목적이 된다 (돈이 되기 때문). 즉, 정상과 비정상간의 variant calling이 주 목적이다. 이때 사람 간의 variation은 무시해야 하므로, 통계적 유의미성 확보를 위해 굉장히 많은 샘플을 이용해야 한다. 따라서 몇 백~몇 천 명의 샘플이 필요하다. 따라서 각 샘플은 동일한 파이프라인을 거치게 된다. . B. Variant Discovery . 처리한 것들을 묶어서 variant calling을 수행한다. 이를 통해 샘플 간 정상과 비정상간의 SNP를 알 수 있다 (몇 번 크로모솜의 어느 site에서 변이가 일어났는지, indel(insertion, deletion)이 일어났는지 등). Data Cleanup, Variant Discovery 과정까지가 bioinformatics의 영역이라고 할 수 있다. . C. Evaluation . Evaluation 단계는 연구자들 또는 의사들의 영역이라고 할 수 있다. 즉, 결과물로 나온 SNP가 의미가 있는 SNP인지 의미가 없는 SNP인지에 대한 판단을 수행한다. 예를 들어, 특정 역할을 하는 단백질, 이를 테면 kinase(신호 전달 체계의 핵심 역할을 하는 단백질)가 있다고 해보자. 이 단백질에 뮤테이션이 발생하여 SNP로 드러나면 해당 SNP가 단백질의 구조에 어떠한 영향을 얼마나 주는지에 대해 판단해야 한다. 즉, 뉴클레오타이드 A가 T로 변화되었고, 이로 인해 아미노산이 Lue에서 Glu으로 바뀌었다면, 해당 단백질의 activity에 영향이 있는가, 없는가를 판단해야 한다. 이를 통해 &quot;해당 SNP에 의한 특정 단백질의 활성화로 인해 암이 발생할 확률이 있다.&quot;는 식으로 시나리오를 짜볼 수 있겠다. 그러나, SNP는 한두 개 정도가 나오는 게 아니다. 정상 세포와 비정상(암) 세포 간 SNP, indel은 굉장히 많이 발생한다. 이로 인해 false positive들이 상당히 많이 발생할 수 있다. 이 false positive를 가려내는 것이 관건이다. 또한, SNP를 발견하여 단백질의 activity를 알아보기 위해서는 실제로 mutation을 도입한 후 클로닝하여 단백질 발현을 통해 activity 테스트를 해야한다. SNP가 한, 두 개 발생하는 것이 아니기 때문에 이 모든 경우를 전부 테스트 할 수는 없다는 한계가 있다. 따라서, 이 부분에 인공지능이 개입할 여지가 있으며 실제로 인공지능을 도입하려는 시도들이 많이 이루어지는 추세다. 인공지능을 통해 정상 세포가 암 세포로 전이될 확률 등을 알아낼 수 있다면, 의사들과 연구자들의 빠른 의사결정에 도움을 줄 수 있을 것이다. . FASTQ . FASTQ는 NGS 기계의 output으로 주어지는 데이터 파일이다. 이 파일의 생김새는 아래와 같다. FASTA 포맷과 다른 점은 &gt;기호 대신 @기호가 쓰인다는 점, :으로 필드가 나누어지는 점, 해당 시퀀스에 대한 인포메이션의 형식(FASTQ는 몇 번째 read고 어떤 플랫폼으로 시퀀싱 된 것인지에 대한 정보를 담고 있다.), 그리고 단 네 줄로만 이루어진다는 점이다. 또한, FASTA 포맷은 첫번째 줄의 시퀀스에 대한 설명 이후 뉴클레오타이드 또는 아미노산 서열만이 나열되는 데에 비해 FASTQ 포맷은 두 번째 줄에 실제 NGS를 통해 나온 서열이 위치하며, 네번째 줄에 정확도를 나타내기 위한 데이터가 나열된다. +는 optional이며, 부가적인 다른 인포메이션을 적을 수 있다. . accuracy . A라고 시퀀싱 된 것을 얼마나 신뢰할 수 있을까? 네 번째 줄을 보면 C로 표기된 것을 볼 수 있다. 이는 정확도를 나타내는 지표이다. 네 번째 줄의 각 알파벳을 아스키 코드로 바꾼 후 -33을 더하면 phred quality score가 나오게 된다. . 아스키 코드 American Standard Code Information Interchange | 영어 알파벳 a-z, 외 특수 기호들에 대하여 컴퓨터가 인식 가능하도록 숫자로 바뀐, 코드화 된 것을 말함 | A: 65, B: 66, C: 67, ... | . | . 네 번째 줄의 B를 예로 들자. B의 아스키 코드는 66이다. phred quality score는 -33을 한 값인 -33. 이때 quality score가 30이면 accuracy는 9가 3개인 99.9%를 의미한다 (40이면 99.99%, 50이면 99.999%). -33이므로, 99.9% 이상을 의미한다. 당연하게도 아스키 코드 값이 높아질수록 quality score가 높아진다고 이해할 수 있다. . paired-end (PE) reads . Illumina NGS 플랫폼에서 만들어진 read는 paired-end (PE) 형태이다. 즉, 하나의 서열을 양 옆에서 읽어들이는 방식이다. 이 때의 서열은 다음과 같다. forward(left) 방향으로 읽은 서열엔 1, backward(right) 방향으로 읽은 서열엔 2가 마킹된 것을 볼 수 있다. 상황과 목적에 따라 1로 마킹된 것들만 묶어서 하나의 파일로, 2로 마킹된 것들만 묶어서 하나의 파일로, 또는 1과 2 둘다 모두 들어있는 파일로 만들어 활용할 수 있다. . Data Cleanup: trimmomatic.jar . data cleanup 단계에서 raw data를 cleanup하라는 명령이다. trimmomatic.jar라는 자바 프로그램을 이용하며 역시 커맨드 라인에서 수행된다. . Reference . https://biohpc.cornell.edu/lab/doc/Variant_workshop_Part1.pdf | https://3months.tistory.com/234 | http://www.incodom.kr/GATK/VariantCalling | .",
            "url": "https://tfedohk.github.io/dohk/NGS-Variant-Calling/",
            "relUrl": "/NGS-Variant-Calling/",
            "date": " • Sep 11, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "유전자 클로닝(gene cloning)",
            "content": "&#50976;&#51204;&#44277;&#54617; . 유전공학이란 유전자 조작기술을 이용하여 세포 외부에서 핵산 분자를 바이러스 또는 박테리아의 플라스미드에 삽입하여 숙주 세포에 도입, 숙주 세포의 시스템(증식, 단백질 생산 등)을 통해 새롭게 재조합 된 유전 물질을 생성하는 것에 관한 학문을 말한다. . 새롭게 재조합 된 유전물질을 생성하기 위한 방법에는 돌연변이, 유전자 재조합 등이 있다. 돌연변이는 세포의 유전정보 자체에 돌연변이를 일으켜, 돌연변이된 세포를 얻는 것을 말하며, 유전자 재조합은 서로 다른 지놈을 가진 두 세포를 접합시켜 돌연변이 없이도 재조합 된 유전형을 얻는 것을 말한다. . &#46028;&#50672;&#48320;&#51060; . 돌연변이란 세포의 DNA가 다양한 원인(화학약품, 자외선 등)에 의해 원래의 정보와는 다른 정보를 지니는 DNA로 복제되는 현상을 말한다. 돌연변이는 대부분 DNA를 합성할 때 발생한다. 세포는 자연상태에서 10^6회 분열 시 한 유전자에서 1회 정도의 돌연변이가 발생할 확률을 가진다. . &#50976;&#51204;&#54805;&#44284; &#54364;&#54788;&#54805; . 유전형은 DNA 염기서열 자체에 생기는 돌연변이를 말한다. 표현형은 DNA 염기서열의 변화로 인한 결과가 표면적으로 드러나는 것을 말한다. . &#46028;&#50672;&#48320;&#51060;&#51032; &#51333;&#47448; . mutation에는 다섯 가지의 종류가 있다. . &#51216; &#46028;&#50672;&#48320;&#51060;(point mutation) . 점 돌연변이란 DNA 상의 염기서열 중 한 개의 염기가 다른 염기로 변한 것을 말한다. 만약 활성 부위의 아미노산 서열이 점 돌연변이에 의해 바뀌게 되면 무의미(non-sense) 또는 정지(stop) 코돈을 형성할 수도 있고, 시작 코돈이 비활성화 되는 등 여 단백질의 활성이 크게 변한다. . &#47924;&#51032;&#48120;(non-sense) &#46608;&#45716; &#51221;&#51648;(stop) &#53076;&#46024; . 어떤 아미노산에도 대응되지 않는 코돈으로써 UAG, UGA, UAA를 말한다. . &#52840;&#47925; &#46028;&#50672;&#48320;&#51060;(silent mutation) . 점 돌연변이에 의해 DNA 염기서열이 바뀌었지만 표면적으로는 생물체에 돌연변이가 발생하지 않은 것 같이 보이는 경우를 말한다. 즉, 유전형은 바뀌었으나 표현형은 그대로인 경우이다. 이런 경우 중 대부분은 하나의 아미노산에 해당하는 코돈이 한 개가 아닌 여러 개인 케이스이다. . &#49325;&#51228; &#46028;&#50672;&#48320;&#51060;(deletion mutation) . DNA 염기서열 중 하나 또는 그 이상의 염기가 제거된 것을 말한다. 이로 인해 판독틀(reading frame)에 변화가 생기며, 단백질의 전체 조성에 변화를 일으킨다. . &#50669; &#46028;&#50672;&#48320;&#51060;(reverse mutation) . 역 돌연변이 또는 복귀(reversion)는 돌연변이가 발생한 곳에 다시 돌연변이가 발생하여 원래의 표현형으로 돌아간 것을 말한다. . &#46028;&#50672;&#48320;&#51060;&#51452;(mutant) &#49440;&#48324;: mutation selection . 특정 돌연변이 된 세포만을 선별할 필요가 있다. 예를 들어, 항생제 내성 유전자가 도입된 세포들이 항생제가 첨가된 고체 배지 plate 상에서 콜로니(동일한 미생물끼리 모인 마을같은 개념)를 형성한다고 할 때, 같은 콜로니에 있는 세포들은 서로 같은 돌연변이에 의해 발현된 세포들인 반면, 같은 plate 상의 콜로니 A와 콜로니 B는 같은 plate 상이라 하더라도 서로 다른 유전자를 가진 채 발현된 것일 수도 있다. . . &#51649;&#51217;&#49440;&#48324; . 직접선별은 항생제 내성 돌연변이주를 찾기 위해 항생제가 들어간 고체배지에 미생물을 배양하여 해당 항생제에 내성을 가진 세포의 집합체(colony)를 얻는 것을 말한다. . &#44036;&#51217;&#49440;&#48324; . 간접선별 또는 판 복제법(replica plating)은 영양요구성 돌연변이의 분리에 사용된다. . auxotroph . 영양요구성 돌연변이(auxotroph)는 생장에 반드시 필요한 특정 성장 인자를 만드는 능력이 없거나 부족한 돌연변이를 말한다. 어떤 미생물이 포도당과 무기염, 그리고 트립토판 등을 이용하여 생장 가능하다고 할 때, 해당 미생물은 트립토판 요구주라고 불리우며, 트립토판 등의 영양을 제공/보충해주지 않는 한 성장할 수 없다. . protoproph . auxotroph와는 다르게 최소한의 영양분이 첨가된 배지에서도 생장 가능한 세포주를 말한다. . &#50976;&#51204;&#51088; &#51116;&#51312;&#54633;(genetic recombination) . 유전자 재조합은 서로 다른 두 개의 지놈(genome)으로부터 취한 유전요소(genetic element)들을 하나로 접합시켜, 돌연변이 없이도 새로운 유전형을 만드는 것을 말한다. 이때 필요한 것은 공여체(donor) DNA와 수령체(recipient) DNA인데, 이 두 DNA는 상호동종성(homologous)이거나 매우 유사한 관계여야 유전자 재조합이 가능하다. 유전자 재조합 기술에는 다음의 세 가지가 있다. . . &#54805;&#51656;&#48320;&#54872;(transformation) . 형질변환은 한 균주의 DNA 추출물(target gene 등)을 다른 균주(의 plasmid 등)에 인공적으로 집어넣어 해당 균주의 형질을 바꾸는 방법이다. 쉽게 말해, plasmid에 target gene을 추가하는 것이다. 이를 위해 균주에 대한 제한효소 처리, Ligation, Competent Cell 제조 등이 필요하다. . . 이 실험 노트에서는 형질변환을 다룬다. 대장균은 일반적으로 형질변환 능력이 없다. 그러나 대장균에 CaCl_2 처리를 하면 (-)전하인 cell membrane이 중화되어, (-)전하를 띄는 plasmid DNA가 cell membrance에 쉽게 들러붙을 수 있게 된다. . plasmid . chromosome과는 별도로 존재하는 autonomous(자율적인) DNA이다. plasmid는 self-replication이 가능하고, double stranded structure이다. 형질을 변환시키려는 대상 균주의 plasmid가 다른 균주의 DNA 추출물의 삽입 대상이 되는데 plasmid는 세포 내에서 DNA처럼 스스로 복제되고 다음 세대의 딸세포에도 그대로 전달되므로 주로 쓰인다. 따라서 형질변환을 할 땐 보통 plasmid 등의 vector(운반체)를 이용한다. . &#54805;&#51656;&#46020;&#51077;(transduction) . 형질도입은 박테리오 파지의 유전형질을 숙주 세포에 전달하는 방법이다. 형질 도입에는 일반 형질도입과 특수 형질도입이 있다. . . &#51068;&#48152; &#54805;&#51656;&#46020;&#51077; . 일반 형질도입은 바이러스 DNA가 세포 내부로 들어오면(즉 숙주세포가 감염되면), 바이러스 DNA가 복제되고 숙주 세포의 DNA는 잘린 후, 숙주 세포 DNA의 일부가 파지 입자 안으로 들어가게 되는 방식이다. . &#53945;&#49688; &#54805;&#51656;&#46020;&#51077; . 특수 형질도입은 세포 내로 침투한 바이러스가 숙주 세포내의 DNA의 특정 위치에 편입한 채로 지내다가, 세포가 용혈 될 때 부정확한 절단이 발생하면 바이러스가 숙주 세포 DNA의 일부를 지닌 채로 세포 밖으로 나가게 되어 다른 세포와 재조합되는 방식이다. . &#48149;&#53580;&#47532;&#50724; &#54028;&#51648; . 박테리오 파지는 숙주 세포를 공격하는 바이러스의 한 종류다. 숙주 세포는 박테리오 파지가 숙주로 삼을 수 있는 특정 유전자를 가지고 있는 세균이기 때문에 박테리오 파지에게 공격 당한다. . &#51217;&#54633;(conjugation) . 접합이란 세포 간 직접 접촉에 의해 세포끼리 DNA가 교환되는 것을 말한다. . . 접합이 일어나기 위해서는 F plasmid를 갖춘 세포(F+ 세포)와 F plasmid를 갖추지 못한 세포(F- 세포) 사이에 성모(sex pilus)가 형성되어야 한다. . &#50976;&#51204;&#51088; &#51116;&#51312;&#54633; . 앞서 언급한 세 가지 방법 중 어떤 방법을 쓰든 일단 DNA가 세포 내부로 들어오면 대부분 재조합 과정을 거치게 된다. . . 외부의 DNA가 세포 내부로 들어오면, 세포 내의 제한효소들이 target gene확보를 위해 donor DNA를, 그리고 target gene을 삽입하기 위해 recipient DNA(plasmid 등)의 동종 부위를 잘라낸다. 잘려진 DNA의 특정 부위에 대하여 donor DNA가 recipient DNA에 삽입되고, Ligase 효소(Ligase 효소는 sugar와 phosphate 사이의 phospho-diester결합을 만든다.)를 이용하여 잘려진 donor DNA의 끝을 recipient DNA와 연결한다. . &#51228;&#54620;&#54952;&#49548;(restriction enzyme) . 제한효소는 특정 염기 서열을 인식하여, phospho-diester 결합을 끊는다. target gene을 확보할 때에 사용되며, vector로 사용될 plasmid DNA의 특정 부위를 끊어 낼 때에도 사용된다. 제한효소는 회문구조(palindrome)을 인식하여 이중가닥을 모두 인식하여 끊어낸다. . 제한효소에 대하여 고려할 사항은 두 가지다. . 제한효소에 따라 sticky end가 될 수도 있고, blunt end가 될 수도 있다. 일반적으로 sticky end가 두 DNA끼리 잘 붙게 한다. | 두 개의 효소를 쓸 때, 두 효소의 효소 반응 조건(buffer 조성, 온도 등)이 제각각이면 효소처리를 할 때마다 효소 반응 조건을 맞춰줘야 한다. 따라서 효소 반응 조건이 비슷한 효소들을 쓰는 게 편할 수 있다. | 이 실험 노트에서는 target gene 확보 시에 사용한 제한효소와 plasmid DNA를 자를 때 사용하는 제한효소를 동일하게 NheI, XhoI을 사용한다. . &#50672;&#44208;&#54952;&#49548;(Ligase) . DNA 사슬 A의 3&#39; term과 DNA 사슬 B의 5&#39; term 사이에 sugar와 phosphate 간 phospho-diester결합을 형성시킨다. 보조적으로 ATP(또는 NAD)등이 필요하다. . &#50868;&#48152;&#52404;(vector) . 벡터는 DNA단편을 숙주 세포의 내부까지 운반하는 운반체다. . &#50976;&#51204;&#51088; &#53364;&#47196;&#45789;(gene cloning)&#51060;&#46976;? . 유전자 클로닝 또는 유전자 재조합 기술이란, 관심 있는 유전자(target gene)를 plasmid 등의 vector에 삽입한 후, 해당 vector를 대장균 등의 세포에 주입하여 발현시키는 기술을 말한다. 해당 세포는 형질전환되었다고 부르며, 형질전환된 세포를 이용하여 특정 유전자에 의해 발현된 여러 유용한 단백질을 얻어낼 수 있다. 대표적으로 인슐린이 이런 류의 단백질이라고 할 수 있다. . &#50976;&#51204;&#51088; &#53364;&#47196;&#45789; &#44284;&#51221; . 1. recombinant DNA . target gene을 PCR로 증폭한 후, 제한효소를 이용하여 plasmid DNA(vector)의 MCS(Multi Cloning Site)를 잘라낸다. 그 후 해당 부위에 target gene을 Ligase로 이어 붙인다. . target gene . 항생제(Kanamycin 또는 Ampicillin) 내성을 갖는다. . vector . 추후 단백질 발현 및 정제에 활용할 수 있도록, His이 발현될 수 있게 되어 있다. 이를 위해 T7 promoter가 있는 vector인 DH5α/pET28(+)를 사용한다. . 2. transformation . recombinant DNA를 E.coli에 주입한다. 이를 위하여, Competent Cell 처리 된 E.coli가 필요하다. . 3. colony screening . 항생제(Kanamycin 또는 Ampicillin)가 들어간 고체 배지에서 자란, 즉 형질전환된 콜로니들을 선별하는 과정이다. . colony screening . Ligation 후 transformation을 통해 원하는 유전자가 삽입되었는지를 알기 위해서는 screening이 필요하다. 이를 위해 먼저 고체 배지에 도말하여 colony가 뜨는지를 살피는데, colony A와 colony B는 서로 다른 형질일 가능성이 있다. 이를 확인하기 위해서는 PCR을 이용하여 다시 확인하는 과정이 필요하다. 이를 위해서는 콜로니를 떠야 하는데, 해당 콜로니가 우리가 원하는 유전자가 발현된 콜로니일 경우 PCR 확인을 위해 쓰이는 관계로 유실될 수 있다. 따라서 PCR 이전 단계에서 각 콜로니에 대해 master plate를 제작하여 균주를 보존한다. . . 4. &#45800;&#48177;&#51656; &#48156;&#54788; &#48143; &#51221;&#51228;(&#52628;&#54980; &#49892;&#54744; &#45432;&#53944;&#50640;&#49436; &#45796;&#47352;) . &#49892;&#54744; &#44284;&#51221; . &#50976;&#51204;&#51088; &#53364;&#47196;&#45789; &#47196;&#46300;&#47605; . 1-1. recombinant DNA-target gene . gDNA prep. . genomic DNA를 추출하기 위한 과정이다. . DH5α culture 1.5mL → EP tube → centrifuge 5min → 상등액 discard | GT1 180μL → EP tube → vortexing | GT2 200μL → EP tube → vortexing | pretenase K 20μL → EP tube → brief pipetting . | → protenase 냉장보관 . | → dry oven 60℃, 20min → 5분마다 brief pipetting . | 99% EtOH 200μL → EP tube → pipetting . | total vol. 600μL → spin column&amp;new EP tube → centrifuge 1min → 침전액 discard | W1 500μL → spin column → centrifuge 1min → 침전액 discard | W2 700μL → spin column → centrifuge 1min → 침전액 discard | centrifuge 5min → 침전액 discard: drying 과정 | Elution buffer 50μL → new EP tube&amp;spin column: EB 투입 시 spin column이 충분히 적셔지도록 유의할 것 | EP tube 뚜껑 닫지 않은 채로 10min waiting: 알코올이 날아가도록 하기 위함 | centrifuge 13000rpm, 5min → spin column discard . | → 3μL → Nano Drop → [전기영동]: gDNA prep.이 제대로 되었는지 확인하는 절차 . Nano Drop: D.W. 3μL → Elution Buffer 3μL → gDNA prep. 3μL | . | → 냉동 보관 . | . &#44208;&#44284; . gDNA PCR . 추출된 gDNA를 증폭하기 위하여 PCR을 수행하는 과정이다. . power PCR 조건: template 희석 X &amp; Taq pol. 2배로 투입 | PCR 용액 제조 (EP tube) | . . vortexing: mix | EP tube → centrifuge 13000rpm, 1min → strip tube 8개에 50μL씩 분주 → spin down → PCR | PCR 옵션 | . . → 전기영동 → ChemiDoc . | → Nano Drop, 전기영동 등에 쓰이고 남은 용액은 전부 EP tube에 모으기 → 냉동 보관 . | . &#44208;&#44284; . template을 희석하지 않아 밴드가 진하게 나온 것으로 보인다. size marker는 100bp(base pair)짜리를 쓰는 실수를 했다. . gDNA purification . PCR 증폭에 사용된 약품을 제거하기 위한 과정이다. . PCR 처리 된 추출물 80μL → EP tube | GB solution 250μL → EP tube → vortexing | EP tube 300μL → spin column&amp;new EP tube → centrifuge 13000rpm, 1min → 침전액 discard 농축이 필요할 경우 반복 | . | GW solution 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 5min → 침전액 discard: drying 과정 | Elution buffer 50μL → new EP tube&amp;spin column: EB 투입 시 spin column이 충분히 적셔지도록 유의할 것 | EP tube 뚜껑 닫지 않은 채로 10min waiting: 알코올이 날아가도록 하기 위함 | centrifuge 13000rpm, 5min → spin column discard . | → 3μL → Nano Drop: gDNA prep.이 제대로 되었는지 확인하는 절차 . Nano Drop: D.W. 3μL → Elution Buffer 3μL → gDNA prep. 3μL | . | → 냉동 보관 . | . &#44208;&#44284; . conc. = 32.600 | 남은 vol. = 47μL | conc. * vol = 1532.2 ≥ 1000 이므로 다음 과정 진행 가능 | . gDNA &#51228;&#54620;&#54952;&#49548;&#52376;&#47532; . 정제된 gDNA는 매우 길다. 이 gDNA 중 특정 부위(target gene)를 추출해 내기 위하여 제한효소처리 후 GOI(Gene of Interest; 즉, target gene) 추출한다. 제한효소처리 된 후에는 DH5α/pET28(+) vector와 Ligation(PCR) 과정을 거치게 된다. . PCR 용액 제조 (EP tube) | . Nano Drop을 통해 측정한 gDNA의 농도를 이용하여 gDNA solution과 D.W.의 용량이 유동적으로 조정된다. . . vortexing: mix | EP tube → centrifuge 13000rpm, 1min → incubator 37℃, 2hr . | → 냉동 보관 . | → 1-3. Ligation(PCR) 단계 . | . &#51228;&#54620;&#54952;&#49548;&#52376;&#47532; &#46108; gDNA purification . 제한효소처리를 위해 사용된 약품을 제거하기 위한 과정이다. . Elution Buffer → dry oven 65℃ 보관 | 정제된&amp;제한효소처리 된 gDNA 80μL → EP tube | GB solution 250μL → EP tube → vortexing | EP tube 300μL → spin column&amp;new EP tube → centrifuge 13000rpm, 1min → 침전액 discard 농축이 필요할 경우 반복 | . | GW solution 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 5min → 침전액 discard: drying 과정 | Elution buffer 50μL → new EP tube&amp;spin column: EB 투입 시 spin column이 충분히 적셔지도록 유의할 것 | EP tube 뚜껑 닫지 않은 채로 10min waiting: 알코올이 날아가도록 하기 위함 | centrifuge 13000rpm, 5min → spin column discard . | → 3μL → Nano Drop: gDNA prep.이 제대로 되었는지 확인하는 절차 . Nano Drop: D.W. 3μL → Elution Buffer 3μL → gDNA prep. 3μL | . | → 냉동 보관 . | . 1-2.recombinant DNA-plasmid DNA . plasmid DNA prep. . plasmid DNA를 추출하기 위한 과정이다. . DH5α/pET28(+) culture 1.5mL → EP tube → centrifuge 13000rpm, 5min → 상등액 discard | PD1 200μL → EP tube → vortexing → 5min waiting | PD2 200μL → EP tube → vortexing → 2min waiting | PD3 300μL → EP tube → vortexing → 1min waiting | centrifuge 13000rpm, 10min → 상등액 700μL → spin column&amp;EP tube | centrifuge 13000rpm, 1min → 침전액 discard | washing solution1 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | washing solution2 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 2min → 침전액 discard: drying 과정 | Elution buffer 50μL → new EP tube&amp;spin column: EB 투입 시 spin column이 충분히 적셔지도록 유의할 것 | EP tube 뚜껑 닫지 않은 채로 10min waiting: 알코올이 날아가도록 하기 위함 | centrifuge 13000rpm, 1min → spin column discard . | → 3μL → Nano Drop: gDNA prep.이 제대로 되었는지 확인하는 절차 . Nano Drop: D.W. 3μL → Elution Buffer 3μL → plasmid DNA prep. 3μL | . | → 냉동 보관 . | . &#44208;&#44284; . plasmid DNA PCR . 추출된 plasmid DNA를 증폭하기 위하여 PCR을 수행하는 과정이다. . PCR 용액 제조 (EP tube) | . . PCR 옵션 | . . vortexing: mix | PCR 옵션 | 전기영동 → ChemiDoc | . plasmid DNA purification . Elution Buffer → dry oven 65℃ 보관 | plasmid DNA 1 Volume(50μL) → EP tube | GB 5 Volume(250μL) → EP tube | Isopropanol 1 Volumn(50μL) → EP tube | vortexing → spin column&amp;new EP tube → centrifuge 13000rpm, 1min → 침전액 discard | GW 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | GW 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 6min → 침전액 discard | Elution Buffer 1 Volume(50μL) → spin column&amp;new EP tube → 10min waiting → centrifuge 13000rpm, 5min . | → Nano Drop(D.W. 3μL → E.B. 3μL → solution 3μL) . | → 냉동 보관 . | . plsmid DNA &#51228;&#54620;&#54952;&#49548;&#52376;&#47532; . DH5α/pET28(+)의 크기는 5369bp나 된다. 이중 gDNA를 제한효소로 잘라낸 것과 동일한 효소로 특정 부위를 잘라내어 GOI(Gene of Interest; 즉, target gene)가 들어갈 곳을 만든다. 제한효소처리 된 후에는 target gene과 Ligation(PCR) 과정을 거치게 된다. . PCR 용액 제조 (EP tube) | . . PCR 옵션 . | 추가 필요 . | vortexing: mix . | EP tube → centrifuge 13000rpm, 1min → incubator 37℃, 2hr . | → 냉동 보관 . | → 1-3. Ligation(PCR) 단계 | . &#51228;&#54620;&#54952;&#49548;&#52376;&#47532; &#46108; plsmid DNA PCR . 제한효소처리 된 plasmid DNA를 증폭시키기 위해 추가적으로 PCR을 수행한다. . PCR 용액 제조 (EP tube) | . . vortexing: mix | EP tube → centrifuge 13000rpm, 3min → EP tube 50μL → strip tube → spin down → PCR | PCR 옵션 | . . → 전기영동 → ChemiDoc | → 냉동 보관 | . &#51228;&#54620;&#54952;&#49548;&#52376;&#47532; &amp; PCR &#46108; plasmid DNA purification . PCR을 위해 사용된 약품을 제거하기 위한 과정이다. . vortexing &amp; Elution Buffer → dry oven 65℃ 보관 | plasmid DNA 1 Volume(70μL) → EP tube | GB solution 5 Volume(350μL) → EP tube → vortexing | Isopropanol 1 Volumn(70μL) → EP tube | vortexing → spin column&amp;new EP tube → centrifuge 13000rpm, 1min → 침전액 discard | GW 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | GW 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 6min → 침전액 discard | Elution Buffer 1 Volume(30μL) → spin column&amp;new EP tube → 5min waiting → centrifuge 13000rpm, 5min . | → Nano Drop(D.W. 3μL → E.B. 3μL → solution 3μL) → 전기영동 → ChemiDoc . | → 냉동 보관 . | . &#44208;&#44284; . Nano Drop의 사진이 흐릿하여 별도로 작성하였다. . 1-3. Ligation . Ligation (gDNA-DH5&#945; plasmid DNA) . 제한효소처리 된 target gene과 DH5α/pET28(+)을 Ligase로 결합시키는 과정이다. . solution 제작(EP tube) | . . parafilm → strip tube → water bath 16℃, 1hr → dry oven 65℃, 20min . | → 1μL → [Ligation 후 PCR] 단계로 이동 . | → -20℃ 보관 . | . Ligation &#54980; PCR . PCR을 통해 Ligation이 잘 되었는지 확인하는 과정이다. . solution 제작(strip tube) | . . strip tube → spin down 5sec → ICE → PCR | PCR 옵션 | . . → 전기영동 → ChemiDoc | → 냉동 보관 | → [2. transformation - transformation] 단계로 인동 | . &#44208;&#44284; . 2. transformation . DH5&#945; Competent Cell &#51228;&#51312; . DH5α 100μL → LB-broth 100mL (균주 접종은 1/100 비율) → shaking incubator 250rpm, 37℃, 1hr → 10분마다 O.D.(600nm) 값 측정 → O.D. ~= 0.4직전까지 incubating DH5α 액체 배양 → Exp. phase의 cell을 이용하기 위해 배양 중 10분마다 흡광도 체크 | . | O.D. ~= 0.4 상태의 DH5α 100mL → ICE about 30min~1hr 30min 사이 | . | DH5α 50mL 씩 → conical tube n개 → centrifuge 3500rpm, 20min → 상등액 discard | MgCl_2 + CaCl_2 30mL → pellet → pipetting → centrifuge 3500rpm, 20min → 상등액 discard | 0.1M CaCl_2 1mL → pellet → pipetting . | → competent cell은 ICE에 보관/냉동 보관 . | → CaCl_2 → 냉장 보관 . | . transformation . LB-broth 300mL + Kanamycin 300μL(항생제 접종은 1/1000비율) → 고체 배지 → incubator | [1-3. Ligation - Ligation 후 PCR] 단계에서 만든 target gene+vector가 들어있는 strip tube&lt;줄여서 solution A라고 부르겠음&gt; 1μL + DH5α competent cell 200μL → EP tube → softly pipetting → ICE 30min → parafilm처리&amp;float → water bath 42℃, 90sec(heat shock) → ICE 5min 열을 가함으로써 cell에 손상을 준다. 즉, lipid bilayer에 손상을 주지만 그 특성으로 인해 바로 복구되며, 동시에 vector가 들어갈 수 있게 된다. | . | LB-broth 800μL → EP tube → pipetting → shaking incubator 250rpm, 37℃, 1hr → vortexing or toughly pipetting → incubated 고체 배지에 1mL distribution → spreading(도말) → incubator 37℃ → overnight → [colony screening 단계]로 이동 | . 3. colony screening . streaking . [2. transformation - transformation] 단계 이후 colony가 뜨는지 확인 이 과정에서 뜨는 colony는 target gene이 삽입된 colony에 해당한다. | . | . . 세 개의 콜로니가 관찰된다. Kanamycin 항생제 내성 target gene이 들어간 대장균이 LB-kan 배지에서 잘 발현된 것으로 보인다. . LB-kan → 고체 배지 → 각 콜로니에 대해 master plate 제작 → incubator | . colony screening(PCR) . master plate의 split 개수만큼 EP tube와 strip tube 준비 | 멸균 D.W. 30μL 씩 → 각 EP tube | master plate 각 split → 각 EP tube에 접종 → pipetting | 반응액(Reaction Mixture;Rx mix) 제조 loss가 발생할 것을 대비해 +1개 만큼을 더 계산하여 제조한다. | . | . . PCR 옵션 | . . → 전기영동 → colony 선별 → [colony plasmid DNA prep.] 단계로 이동 | . &#44208;&#44284; . colony plasmid DNA prep. . colony로부터 recombinant된 plasmid DNA prep. 하는 과정이다. . 선별한 colony → LB-broth 액체 배양: 이하 solution B | solution B culture 1.5mL → EP tube → centrifuge 13000rpm, 5min → 상등액 discard | PD1 200μL → EP tube → vortexing → 5min waiting | PD2 200μL → EP tube → vortexing → 2min waiting | PD3 300μL → EP tube → vortexing → 1min waiting | centrifuge 13000rpm, 10min → 상등액 700μL → spin column&amp;EP tube | centrifuge 13000rpm, 1min → 침전액 discard | washing solution1 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | washing solution2 600μL → spin column → centrifuge 13000rpm, 1min → 침전액 discard | centrifuge 13000rpm, 2min → 침전액 discard: drying 과정 | Elution buffer 50μL → new EP tube&amp;spin column: EB 투입 시 spin column이 충분히 적셔지도록 유의할 것 | EP tube 뚜껑 닫지 않은 채로 10min waiting: 알코올이 날아가도록 하기 위함 | centrifuge 13000rpm, 1min → spin column discard . | → 3μL → Nano Drop: gDNA prep.이 제대로 되었는지 확인하는 절차 . Nano Drop: D.W. 3μL → Elution Buffer 3μL → plasmid DNA prep. 3μL | . | → 냉동 보관 . | . prepared colony plasmid DNA PCR . prep.한 plasmid DNA를 증폭하기 위한 PCR 과정이다. . solution 제작(strip tube) | . . strip tube → spin down 5sec → ICE → PCR | PCR 옵션 | . . → Nano Drop | → 전기영동 → ChemiDoc | → 냉동 보관 | → [4. 균주 이동 - DH5α/BL21 transformation] 단계로 인동 | . &#44208;&#44284; . Nano Drop | . . ChemiDoc | . . 4. &#44512;&#51452; &#51060;&#46041; . DH5&#945;/BL21 Competent Cell &#51228;&#51312; . DH5α/BL21로 competent cell을 제조하는 과정이다. DH5α가 아닌 DH5α/BL21에서 다시 도입하여 키우려는 이유는 DH5α/BL21의 growth rate이 DH5α보다 상대적으로 더 빠르기 때문에, 앞으로의 실험(단백질 발현, 정제 등)에서 시간을 절약할 수 있기 때문이다. . DH5α/BL21 100μL → LB-broth 100mL (균주 접종은 1/100 비율) → shaking incubator 250rpm, 37℃, 1hr → 10분마다 O.D.(600nm) 값 측정 → O.D. ~= 0.4직전까지 incubating Exp. phase의 cell을 이용하기 위해 배양 중 10분마다 흡광도 체크 | . | O.D. ~= 0.4 상태의 DH5α/BL21 100mL → ICE about 30min~1hr 30min 사이 | . | DH5α/BL21 50mL 씩 → conical tube n개 → centrifuge 3500rpm, 20min → 상등액 discard | MgCl_2 + CaCl_2 30mL → pellet → pipetting → centrifuge 3500rpm, 20min → 상등액 discard | 0.1M CaCl_2 1mL → pellet → pipetting . | → competent cell은 ICE에 보관/냉동 보관 . | → CaCl_2 → 냉장 보관 . | . DH5&#945;/BL21 transformation . DH5α/BL21 competent cell에 [3. colony screening - prepared colony plasmid DNA PCR] 단계에서 선별한 colony의 plasmid DNA(이하 solution C)를 도입하는 과정이다. . LB-broth 300mL + Kanamycin 300μL(항생제 접종은 1/1000비율) → 고체 배지 → incubator | solution C 1μL + DH5α/BL21 competent cell 200μL → EP tube → softly pipetting → ICE 30min → parafilm처리&amp;float → water bath 42℃, 90sec(heat shock) → ICE 5min → LB-broth 800μL → EP tube → pipetting → shaking incubator 250rpm, 37℃, 1hr → vortexing or toughly pipetting → incubated 고체 배지에 1mL distribution → spreading(도말) → incubator 37℃ → overnight 열을 가함으로써 cell에 손상을 준다. 즉, lipid bilayer에 손상을 주지만 그 특성으로 인해 바로 복구되며, 동시에 vector가 들어갈 수 있게 된다. | . | [5. 보관 - glycerol stock 처리] 단계로 이동 | . 5. &#48372;&#44288; . glycerol stock &#52376;&#47532; . 균주를 오랫동안 보관할 수 있도록 글리세롤과 균주를 섞어, 냉동 보관하는 과정이다. 글리세롤 처리를 하면 몇 년 이상의 보관이 가능하다. . [4. 균주 이동 - DH5α/BL21 transformation] 단계에서 나온 콜로니 → LB-kan 액체 culture: 접종 | shaking incubator 350rpm, 37℃, 1hr~1hr 30min | glycerol : DH5α/BL21 = 1 : 1 → Cryovial → pipetting | -20℃ 냉동 보관 | . Reference . https://www.cheric.org/files/education/cyberlecture/d200202/d200202-701.pdf | https://namu.wiki/w/박테리오파지 | https://www.axios.com/dna-test-results-privacy-genetic-data-sharing-4687b1a0-f527-425c-ac51-b5288b0c0293.html | https://www.youtube.com/watch?v=JxxTp7WsV3Q | https://bioinformaticsandme.tistory.com/244 | .",
            "url": "https://tfedohk.github.io/dohk/gene-cloning/",
            "relUrl": "/gene-cloning/",
            "date": " • Jul 25, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://tfedohk.github.io/dohk/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "저는 대전 소재의 한국과학기술정보연구원(KISTI)의 과학데이터분석연구실에서 기상 데이터를 분석하는 연구에 참여연구원으로 일한 경력이 있습니다. 이때 처음으로 인공지능의 기술 분야 중 하나인 머신러닝을 접하였고 머신러닝을 혼자 공부해 나가면서 재미있는 분야라 생각하였습니다. 특히, 이때 얻은 귀중한 점 두 가지는 첫째로 머신러닝에서 핵심적으로 쓰이는 gradient descent를 수학적인 배경지식 이해부터 알고리즘 구현까지 스스로 해내었다는 점, 둘째로 학부에서 배웠던 수학이 실제로 눈앞에서 활용되는 모습을 통해 수학의 중요성과 수학 공부의 즐거움을 느꼈다는 점입니다. 이후 저는 관련 공부를 더 이어가고자 하였고, 모교의 대학원에 진학하여 딥러닝과 강화학습을 이용하여 다양한 프로젝트를 진행했습니다. (제가 진행했던 프로젝트에 대한 결과물은 이력의 첨부영역에 있습니다.) . 제가 인공지능 분야를 공부하면서 느낀 점은 인공지능은 결국 도구에 불과하다는 점입니다. 즉, 어떤 도메인에 인공지능을 적용하여 가치를 창출할지에 대한, 일종의 가치 판단의 문제가 생기게 됩니다. 저는 석사 수료 상태로 잠시 진로를 돌아보는 와중에 바이오인포매틱스 분야를 접하게 되었고, BT에 IT를 접목하고 싶다는 생각을 가지게 되었습니다. . 관심분야 . 인공지능(Artificial Intelligence; 머신러닝(ML), 딥러닝(DL), 강화학습(RL)) 생명정보학(Bioinformatics) . 이력 . 2012.03 ~ 2017.08 &gt; 한국기술교육대학교 컴퓨터공학부 학사 과정 | 2016.01 ~ 2016.06 &gt; 한국과학기술정보연구원(KISTI) 대전 본원 참여연구원 | 2017.09 ~ 2019.08 &gt; 한국기술교육대학교 창의융합공학협동과정 ICT융합 석사 과정 | 2018.07 ~ 2020.08 &gt; 한국기술교육대학교 능력교육개발원 보조강사 | 2019.09 ~ 2019.12 &gt; 대한상공회의소 충북인력개발원 시간강사 | 2020.03 ~ &gt; 성남 폴리텍대학 하이테크 생명정보시스템 과정 | . 학력사항 . 2012.03 ~ 2017.08 &gt; 한국기술교육대학교 컴퓨터공학부(CSE) 학사 졸업 총 이수 학점: 156 | 총 학점: 3.4 / 4.5 | 전공 학점: 3.32 / 4.5 | . | 2017.09 ~ 2019.08 &gt; 한국기술교육대학교 창의융합공학협동과정 ICT융합 석사 수료 총 이수 학점: 30 | 총 학점: 4.5 / 4.5 | 작성 논문: [첨부1] | . | . 경력 및 대외활동 . 2020.03.01 ~ &gt; 성남 폴리텍대학 하이테크 생명정보시스템 과정 | 2019.09.23 ~ 2019.12.17 &gt; 대한상공회의소 충북인력개발원 시간강사 | 부서: 전기시스템제어 | 과정명: PLC전문가과정 | 교과목명: 펌웨어프로그래밍실무 | . | 2018.07 ~ 2020.08 &gt; 한국기술교육대학교 능력교육개발원 보조강사 (Assistant Instructor) | 담당 과목: [첨부2] | . | 2016.01.01 ~ 2016.06.30 &gt; 한국과학기술정보연구원(KISTI) 대전 본원 참여연구원/학생연구원 (Graduate Student Research Assistant) | 부서: 과학데이터분석연구실 | 주요업무: 데이터 분석 | . | . 자격증 . 워드프로세서 1급 / 대한상공회의소 / 2005.10.21 | 운전면허 1종 / 대전지방경찰청 / 2016.08.05 | 정보처리기사 / 한국산업인력공단 / 2017.05.26 | 훈련교사자격증 3급 1호 / 고용노동부 / 2019.07.26 정보기술개발 | 통신서비스 | 전자기기개발 | 전자기기일반 | . | . [첨부1] . 한국기술교육대학교 창의융합공학협동과정 석사 과정 작성 논문 . “Time Series Classification of Cryptocurrency Price Trend Based on a Recurrent LSTM Neural Network, “ JIPS(Journal of Information Processing Systems), Volume: 15, No: 3, Page: 694 ~ 706, Year: 2019, 10.3745/JIPS.03.0120 / 1저자 | “Unity 3D 기반 다중 에이전트 강화학습 환경 구현, “ 2019.06, 한국통신학회 | “분산 A3C를 활용한 회전식 도립 진자 시스템 설계, “ 한국정보처리학회, VOL 26 NO. 01 PP. 0493 ~ 0495 2019. 05 / 1저자 | “Deep Q-Network Based Rotary Inverted Pendulum System and Its Monitoring on the EdgeX Platform, “, IEEE Access, 2019.02 / https://ieeexplore.ieee.org/document/8668979 / 2저자 | “A3C를 활용한 블록체인 기반 금융 자산 포트폴리오 관리, “ 2019.01, 한국정보처리학회 | “EdgeX Foundry 기반의 IoT 제어 시스템 구현, “ 한국정보처리학회, VOL 25 NO. 02 PP. 0995 ~ 0997 2018.11 / 1저자 | “강화학습을 이용한 회전식 도립전자 시스템 설계, “, 한국정보처리학회, VOL 25 NO. 02 PP. 0705 ~ 0707 2018. 11 / 2저자 | “그래디언트 부스팅을 활용한 암호화폐 가격동향 예측, “ 정보처리학회논문지, 2018.10 / 2저자 | “암호화폐 가격 정보 데이터에 대한 상관관계분석 및 회귀테스트, “ 한국정보처리학회, VOL 25 NO. 01 PP. 0346 ~ 0349 2018. 05 / 1저자 / 우수논문상 수상 | “Recurrent Neural Network을 이용한 플로우 기반 네트워크 트래픽 분류, “, 2017.07, 한국정보처리학회 | . [첨부2] . 한국기술교육대학교 능력교육개발원 보조강사 담당 과목 . 20.08.10 - 20.08.14 &gt; 데이터 마이닝과 빅데이터 분석 기초 및 응용 | 20.08.03 - 20.08.07 &gt; PyTorch와 Azure로 함께 도전하는 인공지능 입문 | 20.06.06 - 20.06.07 &gt; 엑셀을 활용한 빅데이터 분석 기초 | 20.05.23 - 20.05.24 &gt; 융합기술 기반 SW개발자를 위한 웹 프로그래밍 1 | 20.01.20 - 20.01.21 &gt; Python 프로그래밍 기초 | 20.01.13 - 20.01.17 &gt; Keras 코딩 하며 배우는 생성적 적대 신경망(GAN) 입문 | 19.12.30 - 20.01.03 &gt; Azure와 Keras로 함께 풀어보는 인공지능 실전 프로젝트 | 19.12.21 - 19.12.22 &gt; Excel BI를 이용한 빅데이터 가공 기초 | 19.11.30 - 19.12.01 &gt; IT시스템 통합운영 및 시스템 유지보수 관리 | 19.11.23 - 19.11.24 &gt; Excel BI를 이용한 빅데이터 가공 기초 | 19.08.12 - 19.08.16 &gt; Power BI를 활용한 빅데이터 분석과 시각화 | 19.08.05 - 19.08.09 &gt; 텐서플로우로 풀어보는 6가지 중급 인공지능 프로젝트 | 19.07.29 - 19.08.02 &gt; 사물인터넷 구현을 위한 아두이노 기초 실습 | 19.07.22 - 19.07.26 &gt; 엑셀로 배우는 빅데이터 분석 이론 및 실습 | 19.06.29 - 19.06.30 &gt; 딥러닝을 활용한 자연어 처리 | 19.06.08 - 19.06.09 &gt; Linux 기초와 Apache Hadoop설치 | 19.05.25 - 19.05.26 &gt; PYTHON 프로그래밍 기본 | 19.01.14 - 19.01.18 &gt; 텐서플로우로 익히는 딥러닝 이론과 구현 | 18.07.23 - 18.07.27 &gt; 머신 러닝 기술의 이해 및 실습 | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://tfedohk.github.io/dohk/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://tfedohk.github.io/dohk/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}