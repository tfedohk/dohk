<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>RNA sequencing 기초 이론 및 실습 | dohk’s AI &amp; bioinformatics</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="RNA sequencing 기초 이론 및 실습" />
<meta name="author" content="Kwon DoHyung" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="contact on gwondohyung@gmail.com" />
<meta property="og:description" content="contact on gwondohyung@gmail.com" />
<link rel="canonical" href="https://tfedohk.github.io/dohk/rna-seq-basic/" />
<meta property="og:url" content="https://tfedohk.github.io/dohk/rna-seq-basic/" />
<meta property="og:site_name" content="dohk’s AI &amp; bioinformatics" />
<meta property="og:image" content="https://tfedohk.github.io/dohk/images/2020-11-16-rna-seq/Untitled38.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-16T00:00:00-06:00" />
<script type="application/ld+json">
{"url":"https://tfedohk.github.io/dohk/rna-seq-basic/","@type":"BlogPosting","headline":"RNA sequencing 기초 이론 및 실습","dateModified":"2020-11-16T00:00:00-06:00","datePublished":"2020-11-16T00:00:00-06:00","image":"https://tfedohk.github.io/dohk/images/2020-11-16-rna-seq/Untitled38.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://tfedohk.github.io/dohk/rna-seq-basic/"},"author":{"@type":"Person","name":"Kwon DoHyung"},"description":"contact on gwondohyung@gmail.com","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/dohk/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://tfedohk.github.io/dohk/feed.xml" title="dohk's AI &amp; bioinformatics" /><link rel="shortcut icon" type="image/x-icon" href="/dohk/images/favicon.ico"><link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css">

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/dohk/">dohk&#39;s AI &amp; bioinformatics</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/dohk/about/">About Me</a><a class="page-link" href="/dohk/search/">Search</a><a class="page-link" href="/dohk/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">RNA sequencing 기초 이론 및 실습</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-11-16T00:00:00-06:00" itemprop="datePublished">
        Nov 16, 2020
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Kwon DoHyung</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      27 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/dohk/categories/#bio">bio</a>
        &nbsp;
      
        <a class="category-tags-link" href="/dohk/categories/#NGS">NGS</a>
        &nbsp;
      
        <a class="category-tags-link" href="/dohk/categories/#bioinformatics">bioinformatics</a>
        &nbsp;
      
        <a class="category-tags-link" href="/dohk/categories/#experiment">experiment</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          
          
          
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#1.-Basics-of-RNA-seq">1. Basics of RNA-seq </a>
<ul>
<li class="toc-entry toc-h2"><a href="#1-1.-What-is-RNA-seq?">1-1. What is RNA-seq? </a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-1-1.-RNA-seq의-개략적인-과정">1-1-1. RNA-seq의 개략적인 과정 </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#1-2.-The-Purpose-of-RNA-seq">1-2. The Purpose of RNA-seq </a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-2-1.-유전자-발현에-대한-정보-획득">1-2-1. 유전자 발현에 대한 정보 획득 </a></li>
<li class="toc-entry toc-h3"><a href="#1-2-2.-isoform에-대한-정보-획득">1-2-2. isoform에 대한 정보 획득 </a></li>
<li class="toc-entry toc-h3"><a href="#1-2-3.-Assembling-and-Annotating-a-transcriptome(전사체)">1-2-3. Assembling and Annotating a transcriptome(전사체) </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-2-3-1.-transcriptome(전사체)">1-2-3-1. transcriptome(전사체) </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#1-3.-RNA-seq-외-RNA-sequencing-분석-기법들">1-3. RNA-seq 외 RNA sequencing 분석 기법들 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-3-1.-Alternative-splicing-분석">1-3-1. Alternative splicing 분석 </a></li>
<li class="toc-entry toc-h3"><a href="#1-3-2.-ncRNA-분석-(non-coding-RNA)">1-3-2. ncRNA 분석 (non-coding RNA) </a></li>
<li class="toc-entry toc-h3"><a href="#1-3-3.-scRNA-분석">1-3-3. scRNA 분석 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-3-3-1.-Bulk-RNA-seq과-비교해서-scRNA-seq을-성공적으로-하기-위한-두-가지-이슈">1-3-3-1. Bulk RNA-seq과 비교해서 scRNA-seq을 성공적으로 하기 위한 두 가지 이슈 </a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#1-3-3.-targeted-approaches">1-3-3. targeted approaches </a></li>
<li class="toc-entry toc-h3"><a href="#1-3-4.-direct-RNA-sequencing">1-3-4. direct RNA sequencing </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#1-3.-Why-is-RNA-seq-difficult?">1-3. Why is RNA-seq difficult? </a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-3-1.-bias란?">1-3-1. bias란? </a></li>
<li class="toc-entry toc-h3"><a href="#1-3-2.-bias를-유발하는-문제들">1-3-2. bias를 유발하는 문제들 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-3-2-1.-PCR에-의한-bias">1-3-2-1. PCR에 의한 bias </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-2.-degradation된-RNA에-의한-bias">1-3-2-2. degradation된 RNA에 의한 bias </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-3.-splicing에-의한-bias">1-3-2-3. splicing에 의한 bias </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-4.-gene-level과-exon-level에서의-발현량-계산에서의-혼동">1-3-2-4. gene level과 exon level에서의 발현량 계산에서의 혼동 </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-5.-multiple-mapping에-의한-bias">1-3-2-5. multiple mapping에 의한 bias </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-6.-partial-mapping에-의한-bias">1-3-2-6. partial mapping에 의한 bias </a></li>
<li class="toc-entry toc-h4"><a href="#1-3-2-7.-Normalization">1-3-2-7. Normalization </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#1-4.-NGS-데이터-분석-과정">1-4. NGS 데이터 분석 과정 </a></li>
<li class="toc-entry toc-h2"><a href="#1-5.-RNA-seq-상세-과정">1-5. RNA-seq 상세 과정 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-5-1.-RNA-분리">1-5-1. RNA 분리 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-5-1-1.-Capturing-of-Single-Cell">1-5-1-1. Capturing of Single Cell </a>
<ul>
<li class="toc-entry toc-h5"><a href="#1-5-1-1-1.-하나하나-분리">1-5-1-1-1. 하나하나 분리 </a></li>
<li class="toc-entry toc-h5"><a href="#1-5-1-1-2.-한꺼번에-분리">1-5-1-1-2. 한꺼번에 분리 </a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#1-5-1-2.-RNA-분리:-rRNA-depletion-vs.-Poly-A-selection">1-5-1-2. RNA 분리: rRNA depletion vs. Poly-A selection </a>
<ul>
<li class="toc-entry toc-h5"><a href="#1-5-1-2-1.-rRNA-depletion">1-5-1-2-1. rRNA depletion </a></li>
<li class="toc-entry toc-h5"><a href="#1-5-1-2-2.-Poly-A-selection">1-5-1-2-2. Poly-A selection </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#1-5-2.-cDNA-제작:-Poly-A-priming-vs.-Random-priming">1-5-2. cDNA 제작: Poly-A priming vs. Random priming </a></li>
<li class="toc-entry toc-h3"><a href="#1-5-3.-Library-제작:-RNA-ligation-method-vs.-dUTP-method">1-5-3. Library 제작: RNA ligation method vs. dUTP method </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-5-3-1.-RNA-ligation-method">1-5-3-1. RNA ligation method </a></li>
<li class="toc-entry toc-h4"><a href="#1-5-3-2.-dUTP-method">1-5-3-2. dUTP method </a></li>
<li class="toc-entry toc-h4"><a href="#1-5-3-3.-RT-method">1-5-3-3. RT method </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#1-6.-QC">1-6. QC </a></li>
<li class="toc-entry toc-h2"><a href="#1-7.-preprocessing">1-7. preprocessing </a></li>
<li class="toc-entry toc-h2"><a href="#1-8.-mapping(또는-alignment)">1-8. mapping(또는 alignment) </a></li>
<li class="toc-entry toc-h2"><a href="#1-9.-post-alignment-processing">1-9. post-alignment processing </a></li>
<li class="toc-entry toc-h2"><a href="#1-10.-variant-calling">1-10. variant calling </a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#2.-Methods-in-RNA-seq">2. Methods in RNA-seq </a>
<ul>
<li class="toc-entry toc-h2"><a href="#2-1.-short-read-RNA-seq-장비">2-1. short read RNA-seq 장비 </a></li>
<li class="toc-entry toc-h2"><a href="#2-2.-long-read-RNA-seq-장비">2-2. long read RNA-seq 장비 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#2-2-1.-long-read-sequencing의-장점">2-2-1. long read sequencing의 장점 </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#2-3.-short-vs.-long-read-RNA-sequencing-장비-비교">2-3. short vs. long read RNA sequencing 장비 비교 </a></li>
<li class="toc-entry toc-h2"><a href="#2-4.-RNA-seq-이-외의-sequencing-기법들">2-4. RNA-seq 이 외의 sequencing 기법들 </a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#3.-RNA-seq-Analysis-Pipeline">3. RNA-seq Analysis Pipeline </a>
<ul>
<li class="toc-entry toc-h2"><a href="#3-1.-RNA-seq-분석-시-사용되는-프로그램(tool)">3-1. RNA-seq 분석 시 사용되는 프로그램(tool) </a></li>
<li class="toc-entry toc-h2"><a href="#3-2.-How-to-analyze-RNA-seq-data?">3-2. How to analyze RNA-seq data? </a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#4.-Quantification-of-Gene-Expression-from-RNA-seq">4. Quantification of Gene Expression from RNA-seq </a>
<ul>
<li class="toc-entry toc-h2"><a href="#4-1.-FPKM,-RPKM">4-1. FPKM, RPKM </a>
<ul>
<li class="toc-entry toc-h3"><a href="#4-1-1.-계산식">4-1-1. 계산식 </a></li>
<li class="toc-entry toc-h3"><a href="#4-1-2.-실제-계산:-세로-→-가로">4-1-2. 실제 계산: 세로 → 가로 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#4-1-2-1.-Normalization-for-read-depth">4-1-2-1. Normalization for read depth </a></li>
<li class="toc-entry toc-h4"><a href="#4-1-2-2.-Normalization-for-gene-length">4-1-2-2. Normalization for gene length </a></li>
<li class="toc-entry toc-h4"><a href="#4-1-2-3.-계산-결과">4-1-2-3. 계산 결과 </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#4-2.-TPM">4-2. TPM </a>
<ul>
<li class="toc-entry toc-h3"><a href="#4-2-1.-계산식">4-2-1. 계산식 </a></li>
<li class="toc-entry toc-h3"><a href="#4-2-2.-실제-계산:-가로-→-세로">4-2-2. 실제 계산: 가로 → 세로 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#4-2-2-1.-Normalization-for-gene-length">4-2-2-1. Normalization for gene length </a></li>
<li class="toc-entry toc-h4"><a href="#4-2-2-2.-Normalization-for-read-depth">4-2-2-2. Normalization for read depth </a></li>
<li class="toc-entry toc-h4"><a href="#4-2-2-3.-계산-결과">4-2-2-3. 계산 결과 </a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#4-3.-RPKM과-TPM의-결과-비교">4-3. RPKM과 TPM의 결과 비교 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#4-3-1.-comparison-among-TPMs">4-3-1. comparison among TPMs </a></li>
<li class="toc-entry toc-h3"><a href="#4-3-2.-comparison-among-RPKMs">4-3-2. comparison among RPKMs </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#4-3.-bias에-주의">4-3. bias에 주의 </a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#5.-실습">5. 실습 </a>
<ul>
<li class="toc-entry toc-h2"><a href="#5-1.-환경-설정-및-데이터-다운로드">5-1. 환경 설정 및 데이터 다운로드 </a></li>
<li class="toc-entry toc-h2"><a href="#5-2.-프로그램(tool)-다운로드">5-2. 프로그램(tool) 다운로드 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#fastqc">fastqc </a></li>
<li class="toc-entry toc-h3"><a href="#trimmomatic">trimmomatic </a></li>
<li class="toc-entry toc-h3"><a href="#STAR">STAR </a></li>
<li class="toc-entry toc-h3"><a href="#RSEM">RSEM </a></li>
<li class="toc-entry toc-h3"><a href="#samtools">samtools </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#5-3.-QC">5-3. QC </a></li>
<li class="toc-entry toc-h2"><a href="#5-4.-Trimming">5-4. Trimming </a></li>
</ul>
</li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-11-16-RNA-sequencing-basic.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Basics-of-RNA-seq">
<a class="anchor" href="#1.-Basics-of-RNA-seq" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Basics of RNA-seq<a class="anchor-link" href="#1.-Basics-of-RNA-seq"> </a>
</h1>
<p>RNA sequencing을 활용하여 알아낼 수 있는 정보들은 매우 많다. 최근 굉장히 유행하고 있는 single cell RNA sequencing 기술, 각종 RNA sequencing Library를 만드는 Chemistry 분야 등에서 쓰이는 것이 대표적이다. 이 섹션에서는 이 중 일부를 다루고자 한다. 가장 기본적으로 RNA sequencing이 무엇인지, RNA sequencing Library를 만드는 방법에는 어떤 것들이 있는지, RNA sequencing을 통해 유전자 발현량을 어떻게 측정하는지 등을 다룬다. 기본적으로 유전자의 발현량은 RNA sequencing 이후에 해당 유전자의 read가 몇 개나 mapping이 되느냐를 바탕으로 그 양을 추정하게 된다.</p>
<h2 id="1-1.-What-is-RNA-seq?">
<a class="anchor" href="#1-1.-What-is-RNA-seq?" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-1. What is RNA-seq?<a class="anchor-link" href="#1-1.-What-is-RNA-seq?"> </a>
</h2>
<ul>
<li>일반적으로, RNA-seq이라고 하면 Bulk RNA-seq을 말한다. RNA sequencing은 NGS 방법으로 RNA 분자를 sequencing하는 방법이다. 특히, RNA-seq이라고 하면 주로 mRNA 분석을 의미한다. mRNA가 단백질로 번역되기 때문에 mRNA의 양을 조사하면 발현 정도를 분석할 수 있다. RNA Sequencing기술은 sanger sequencing 및 microarray 기반 방식으로 사용할 수 있는 것보다 훨씬 높은 해상도로 Genome을 분석할 수 있다.</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled.png" alt=""></p>
<ul>
<li>NGS를 이용한 RNA 분석 이전의 기존의 임상영역에서(oncology) 시행되고 있는 RNA 검사는 qRT-PCR, Microarray를 이용하여 일부 시행되고 있었다. 그러나 연속적으로 probe의 강도를 측정하는 microarray와는 달리, NGS를 활용한 RNA-seq는 reference sequence에 할당되는 각각의 sequence read를 정량화하여 read count를 생성한다. 따라서 NGS를 이용한 RNA-seq을 통한 유전자 발현량의 계산이 중요하다. 또한 sequence read (coverage level이나 coverage depth)를 늘이거나 줄여서 민감도를 조정할 수 있다.</li>
</ul>
<h3 id="1-1-1.-RNA-seq의-개략적인-과정">
<a class="anchor" href="#1-1-1.-RNA-seq%EC%9D%98-%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B3%BC%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-1-1. RNA-seq의 개략적인 과정<a class="anchor-link" href="#1-1-1.-RNA-seq%EC%9D%98-%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B3%BC%EC%A0%95"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled1.png" alt=""></p>
<ul>
<li>샘플에서 먼저 mRNA를 추출한다. 위 그림에서와 같이 특정 condition에 놓인 샘플들을 얻게 된다고 해보자. 이 샘플은 우리 조직에서 나오는 샘플일 수도 있고, cell culture 과정에서 나온 샘플일 수도 있다. 어쨌든 RNA가 있다면 sequencing이 가능하므로 RNA의 출처가 동물인지, 식물인지, 혹은 사람으로부터 나온 샘플인지 실험실에서 배양하여 나온 샘플인지는 중요하지 않다.</li>
<li>샘플로부터 RNA를 얻고 난 후엔 cDNA로 합성한다. 요즘에는 nanopore 기술로 RNA를 곧바로 sequencing할 수 있으나, 여전히 대부분의 RNA sequencing은 cDNA를 만들어야 sequencing이 가능하다. 그 이유는, Illumina의 sequencing기법인 bridge PCR 기법이 DNA 수준에서 이루어지는 PCR이기 때문이기도 하고, PacBio사에서의 sequencing 기법도 DNA로 sequencing을 수행하는 방법이기 때문이다. 따라서 cDNA로 변환하는 단계를 거친다.</li>
<li>cDNA가 만들어진 후에는 sequencing 기기에 넣기 위해 sequencing Library를 제작한다. RNA 상태에서 조각을 낸 뒤 fragment 양 끝단에 adapter라는 molecule을 붙이는 등(PolyA tailing), 시퀀싱에 필요한 서열들을 붙여 라이브러리를 만든다.</li>
<li>필요하다면 PCR amplification을 수행하여 RNA를 증폭시킨다.</li>
<li>sequencing Library를 만들면 sequencing 기기에 넣어 대용량의 read를 얻는다. 즉, RNA에 대한 sequence를 획득하기 위해 sequencing을 진행한다. 이 과정에서 RNA에 붙어있는 poly A tail이나 Library를 만들 때 사용된 adapter는 제거되고 read(sequencing 데이터)가 생성된다.</li>
<li>해당 샘플이 유래된 생물종의 서열을 reference로 하여 read를 reference 서열에 붙인다. 이를 mapping이라고 한다.</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled2.png" alt=""></p>
<h2 id="1-2.-The-Purpose-of-RNA-seq">
<a class="anchor" href="#1-2.-The-Purpose-of-RNA-seq" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-2. The Purpose of RNA-seq<a class="anchor-link" href="#1-2.-The-Purpose-of-RNA-seq"> </a>
</h2>
<h3 id="1-2-1.-유전자-발현에-대한-정보-획득">
<a class="anchor" href="#1-2-1.-%EC%9C%A0%EC%A0%84%EC%9E%90-%EB%B0%9C%ED%98%84%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%9A%8D%EB%93%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-2-1. 유전자 발현에 대한 정보 획득<a class="anchor-link" href="#1-2-1.-%EC%9C%A0%EC%A0%84%EC%9E%90-%EB%B0%9C%ED%98%84%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%9A%8D%EB%93%9D"> </a>
</h3>
<p>기본적으로 RNA sequencing을 통해 transcriptome을 분석하여 유전자 발현량의 차이를 확인 하는 것이 목적이다. Transcript에서 translation을 통해 단백질이 된다는 central dogma에 입각하여 transcript 수가 많을수록 발현이 많이 된다고 판단하여 계산하는 방법이다. Transcriptome 대용량 시퀀싱 후 분석을 하는 RNA-seq을 통하여 새로운 것을 발견할 수도 있으며, 발현 값을 정량 할 수도 있다. RNA sequencing 기술의 발전에 따라 RNA sequencing으로 할 수 있는 일들이 많아졌다. RNA sequencing은 central dogma(DNA→mRNA→protein) 단계의 중간 단계인 mRNA를 sequencing하여 mRNA의 서열을 알게 됨으로써, 기본적으로 어떤 tissue에 어떤 유전자가 발현되는지, 세포 종류에 따라 발현되는 유전자의 양, 발달 과정에서 특이하게 발현되는 RNA 유전자의 발현량, 암 세포에서의 RNA sequencing, 시간에 따른 유전자 발현량 등을 알 수 있다.</p>
<h3 id="1-2-2.-isoform에-대한-정보-획득">
<a class="anchor" href="#1-2-2.-isoform%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%9A%8D%EB%93%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-2-2. isoform에 대한 정보 획득<a class="anchor-link" href="#1-2-2.-isoform%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%9A%8D%EB%93%9D"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled3.png" alt=""></p>
<p>RNA sequencing이 많이 쓰이는 또 다른 분야는 isoform을 찾아내는 영역이다. isoform은 DNA에서 mRNA가 만들어질 때, 무작위적인 exon의 짜집기 과정에 의해 여러 형태의 mRNA가 발생하는 과정에서 나오는 RNA들을 말한다. RNA sequencing 기술을 이용하면 isoform들에 대한 sequencing을 수행함으로써 어떤 종류의 isoform이 만들어졌는지 알 수 있게 된다.</p>
<h3 id="1-2-3.-Assembling-and-Annotating-a-transcriptome(전사체)">
<a class="anchor" href="#1-2-3.-Assembling-and-Annotating-a-transcriptome(%EC%A0%84%EC%82%AC%EC%B2%B4)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-2-3. Assembling and Annotating a transcriptome(전사체)<a class="anchor-link" href="#1-2-3.-Assembling-and-Annotating-a-transcriptome(%EC%A0%84%EC%82%AC%EC%B2%B4)"> </a>
</h3>
<p>단순히 RNA 유전자의 발현량을 보는 것 뿐만 아니라, RNA sequencing을 통해 sequencing read를 assembling하는 방식으로 새로운 RNA를 찾는 것, 그리고 non-coding RNA를 찾는 것 등, RNA를 annotation하기 위한 목적으로 RNA-seq이 사용된다.</p>
<h4 id="1-2-3-1.-transcriptome(전사체)">
<a class="anchor" href="#1-2-3-1.-transcriptome(%EC%A0%84%EC%82%AC%EC%B2%B4)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-2-3-1. transcriptome(전사체)<a class="anchor-link" href="#1-2-3-1.-transcriptome(%EC%A0%84%EC%82%AC%EC%B2%B4)"> </a>
</h4>
<ul>
<li>전사물(transcript)의 총체(-ome)의 합성어로 전사체를 의미하는 용어이다. 즉, 전사체는 모든 mRNA의 집합을 의미한다. Transcript 중 하나인 mRNA는 단백질을 합성하는 데 사용되므로 transcriptome은 genome의 기능적 요소를 해석하고 세포와 조직의 분자 구성 요소를 밝혀내고 발달과 질병을 이해하는 데 필수적이다. Transcript의 범위는 단백질 합성에 필요한 mRNA부터 아미노산 운반을 담당하는 tRNA, 코딩에 관여되지 않는 non-coding RNA 등에 이르기까지 RNA 전반을 포함한다.</li>
<li>전사체학(transcriptomics)이란 mRNA 수준에서 생명 현상을 전체적으로 다루는 학문이라고 정의 할 수 있다.</li>
<li>전사체 수준에서의 유전자 발현(gene expression)에 대한 연구는 DNA 마이크로어레이(microarray)와 같은 고 처리량의 분석 기술 발달과 더불어 활발하게 진행되어 왔다. 유전자의 발현을 전사 수준에서 다루는 것은 단백질 활성의 직접 정량보다 분석이 쉬우며 간접적 지표로서의 가치가 있다.</li>
<li>NGS기술 기반의 RNA sequencing (RNA-seq)은 기존의 전사체학을 위한 방법의 한계를 넘어 현대의학의 가장 강력한 tool로 여겨지고 있다. RNA-seq는 Gene Expression 분석을 위한 정확하고 민감한 방법으로, 이전에 검출되지 않았던 gene expression에서의 변화뿐만 아니라 noncoding RNA의 다양한 형태의 특성들을 알 수 있게 한다. RNA-seq를 통해 동형 전사물(transcript isoforms), gene fusions, single nucleotide variants(SNV) 등과 같은 전사체 구조에 대한 분석을 제한 없이 할 수 있게 되었다.</li>
</ul>
<h2 id="1-3.-RNA-seq-외-RNA-sequencing-분석-기법들">
<a class="anchor" href="#1-3.-RNA-seq-%EC%99%B8-RNA-sequencing-%EB%B6%84%EC%84%9D-%EA%B8%B0%EB%B2%95%EB%93%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3. RNA-seq 외 RNA sequencing 분석 기법들<a class="anchor-link" href="#1-3.-RNA-seq-%EC%99%B8-RNA-sequencing-%EB%B6%84%EC%84%9D-%EA%B8%B0%EB%B2%95%EB%93%A4"> </a>
</h2>
<p>mRNA를 분석하는 RNA-seq 이외에 Alternative splicing 분석과 ncRNA 분석 (non-coding RNA)이 있다.</p>
<h3 id="1-3-1.-Alternative-splicing-분석">
<a class="anchor" href="#1-3-1.-Alternative-splicing-%EB%B6%84%EC%84%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-1. Alternative splicing 분석<a class="anchor-link" href="#1-3-1.-Alternative-splicing-%EB%B6%84%EC%84%9D"> </a>
</h3>
<ul>
<li>유전자는 Splicing을 통해 다양한 조합의 mRNA를 생성해낸다. 이렇게 발생한 isoform에 대하여, 전체 유전자 구조에 RNA를 시퀀싱한 데이터를 대응해보면 splicing이 일어난 부분을 확인할 수 있다.</li>
<li>또한, 세포 내에서는 gene이 fusion되는 현상이 발생할 수 있다. RNA sequencing을 통해 어떤 유전자가 fusion이 되는지 알아낼 수 있다.</li>
</ul>
<h3 id="1-3-2.-ncRNA-분석-(non-coding-RNA)">
<a class="anchor" href="#1-3-2.-ncRNA-%EB%B6%84%EC%84%9D-(non-coding-RNA)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2. ncRNA 분석 (non-coding RNA)<a class="anchor-link" href="#1-3-2.-ncRNA-%EB%B6%84%EC%84%9D-(non-coding-RNA)"> </a>
</h3>
<ul>
<li>small RNA profiling이라고도 한다.</li>
<li>miRNA와 같은 짧은 RNA나 lncRNA 등에 대한 sequencing 분석에 해당한다. 실제로 번역이 되는 부분은 아니지만, 발현을 조절한다고 알려진 부위로 최근 활발한 연구가 이루어지고 있다.</li>
<li>피에는 DNA가 주로  떠돌아다니는데, 아주 짧게 degradation되어 있는 RNA들을 small RNA sequencing 방법으로 sequencing할 수도 있다.</li>
</ul>
<h3 id="1-3-3.-scRNA-분석">
<a class="anchor" href="#1-3-3.-scRNA-%EB%B6%84%EC%84%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-3. scRNA 분석<a class="anchor-link" href="#1-3-3.-scRNA-%EB%B6%84%EC%84%9D"> </a>
</h3>
<p>Bulk RNA-seq은 적어도 나노 그램의 RNA가 필요하다. 그러나 일반적인 포유류의 세포는 pg의 RNA를 가지고 있기 때문에 충분히 많은 수의 세포를 얻을 수 없을 경우, bulk RNA-seq을 수행할 수 없다. 반면, scRNA-seq은 단일 세포로도 시퀀싱이 가능하다.</p>
<h4 id="1-3-3-1.-Bulk-RNA-seq과-비교해서-scRNA-seq을-성공적으로-하기-위한-두-가지-이슈">
<a class="anchor" href="#1-3-3-1.-Bulk-RNA-seq%EA%B3%BC-%EB%B9%84%EA%B5%90%ED%95%B4%EC%84%9C-scRNA-seq%EC%9D%84-%EC%84%B1%EA%B3%B5%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%8A%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-3-1. Bulk RNA-seq과 비교해서 scRNA-seq을 성공적으로 하기 위한 두 가지 이슈<a class="anchor-link" href="#1-3-3-1.-Bulk-RNA-seq%EA%B3%BC-%EB%B9%84%EA%B5%90%ED%95%B4%EC%84%9C-scRNA-seq%EC%9D%84-%EC%84%B1%EA%B3%B5%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%8A%88"> </a>
</h4>
<ol>
<li>조직에서 세포를 하나씩 캡처할 수 있는 기술이 필요하다. 이를 위해 최근 cell 별로 바코드를 도입하는 기술이 적용되고 있다.</li>
<li>ng단위의 RNA양이 필요하므로 pg단위일 경우 RNA의 양을 늘리기 위한 증폭 과정이 필요하다. 이 과정에서 노이즈가 발생할 수 있다.</li>
</ol>
<h3 id="1-3-3.-targeted-approaches">
<a class="anchor" href="#1-3-3.-targeted-approaches" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-3. targeted approaches<a class="anchor-link" href="#1-3-3.-targeted-approaches"> </a>
</h3>
<p>exom sequencing처럼 특정 probe를 짜서 원하는 RNA만 capture하는 targeted RNA sequencing을 말한다.</p>
<h3 id="1-3-4.-direct-RNA-sequencing">
<a class="anchor" href="#1-3-4.-direct-RNA-sequencing" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-4. direct RNA sequencing<a class="anchor-link" href="#1-3-4.-direct-RNA-sequencing"> </a>
</h3>
<p>nanopore를 이용하여 cDNA를 합성하지 않은 채 RNA 상태 그 자체로 RNA를 바로 sequencing하는 기술을 말한다.</p>
<h2 id="1-3.-Why-is-RNA-seq-difficult?">
<a class="anchor" href="#1-3.-Why-is-RNA-seq-difficult?" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3. Why is RNA-seq difficult?<a class="anchor-link" href="#1-3.-Why-is-RNA-seq-difficult?"> </a>
</h2>
<p>RNA sequencing은 매우 유용하며, 흔하게 쓰이는 기술이다. 하지만 여전히 분석에 있어서 bias의 문제가 발생한다.</p>
<h3 id="1-3-1.-bias란?">
<a class="anchor" href="#1-3-1.-bias%EB%9E%80?" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-1. bias란?<a class="anchor-link" href="#1-3-1.-bias%EB%9E%80?"> </a>
</h3>
<p>bias란, 우리가 데이터를 통해 살펴본 내용이 실제 상황(true state)을 반영하지 않는 것을 말한다. bias는 Bulk RNA-seq은 어떤 조직(샘플)에 2가지 이상의 세포가 섞여 있을 때, 각 세포에서 나온 전사체들이 섞여 결과에 편향성(bias)을 만들기 때문에 발생한다. (scRNA-seq은 세포끼리 섞여있지 않기 때문에 편향성이 발생하지 않는다.)</p>
<h3 id="1-3-2.-bias를-유발하는-문제들">
<a class="anchor" href="#1-3-2.-bias%EB%A5%BC-%EC%9C%A0%EB%B0%9C%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2. bias를 유발하는 문제들<a class="anchor-link" href="#1-3-2.-bias%EB%A5%BC-%EC%9C%A0%EB%B0%9C%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4"> </a>
</h3>
<h4 id="1-3-2-1.-PCR에-의한-bias">
<a class="anchor" href="#1-3-2-1.-PCR%EC%97%90-%EC%9D%98%ED%95%9C-bias" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-1. PCR에 의한 bias<a class="anchor-link" href="#1-3-2-1.-PCR%EC%97%90-%EC%9D%98%ED%95%9C-bias"> </a>
</h4>
<p>예를 들어 굉장히 작은 cell number를 가진 샘플로부터 RNA를 뽑았을 때에는 당연히 RNA 양을 증폭시키기 위해 PCR 과정을 거치게 될 것이다. 이 때, PCR에 의한 bias가 생길 수 있다.</p>
<h4 id="1-3-2-2.-degradation된-RNA에-의한-bias">
<a class="anchor" href="#1-3-2-2.-degradation%EB%90%9C-RNA%EC%97%90-%EC%9D%98%ED%95%9C-bias" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-2. degradation된 RNA에 의한 bias<a class="anchor-link" href="#1-3-2-2.-degradation%EB%90%9C-RNA%EC%97%90-%EC%9D%98%ED%95%9C-bias"> </a>
</h4>
<p>혹은, RNA quality 자체가 좋지 않은 경우(RNA가 많이 degradation된 경우 등)에서, sequencing 이후에 read들이 일관되게 mapping되지 않는 문제가 발생하기도 한다. 이로 인해 bias가 생긴다.</p>
<h4 id="1-3-2-3.-splicing에-의한-bias">
<a class="anchor" href="#1-3-2-3.-splicing%EC%97%90-%EC%9D%98%ED%95%9C-bias" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-3. splicing에 의한 bias<a class="anchor-link" href="#1-3-2-3.-splicing%EC%97%90-%EC%9D%98%ED%95%9C-bias"> </a>
</h4>
<p>또다른 RNA sequencing 데이터 해석에서 어려움을 유발하는 부분은 splicing에 의한 문제다. sequencing을 통해 read를 mapping(exon을 mapping)했을 때 실질적으로 어떤 isoform에서 나온 read(exon)인지 명확하지 않다. splicing은 다양한 방식으로 이루어지는데, read의 길이가 짧은 short read의 경우, 정확하게 어떤 조합으로 exon이 이어 붙여졌는지 알 수 없다. 이로 인해 최근에는 isoform만 특별히 잘 sequencing할 수 있는 Iso-Seq이라는 기술이 나와있다.</p>
<h4 id="1-3-2-4.-gene-level과-exon-level에서의-발현량-계산에서의-혼동">
<a class="anchor" href="#1-3-2-4.-gene-level%EA%B3%BC-exon-level%EC%97%90%EC%84%9C%EC%9D%98-%EB%B0%9C%ED%98%84%EB%9F%89-%EA%B3%84%EC%82%B0%EC%97%90%EC%84%9C%EC%9D%98-%ED%98%BC%EB%8F%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-4. gene level과 exon level에서의 발현량 계산에서의 혼동<a class="anchor-link" href="#1-3-2-4.-gene-level%EA%B3%BC-exon-level%EC%97%90%EC%84%9C%EC%9D%98-%EB%B0%9C%ED%98%84%EB%9F%89-%EA%B3%84%EC%82%B0%EC%97%90%EC%84%9C%EC%9D%98-%ED%98%BC%EB%8F%99"> </a>
</h4>
<p>sequencing 분석 시, 유전자 발현량을 계산할 때 gene level에서 유전자 발현량을 계산하는 것인지, exon level에서 발현량을 계산하는 것인지 유념할 필요가 있다.</p>
<h4 id="1-3-2-5.-multiple-mapping에-의한-bias">
<a class="anchor" href="#1-3-2-5.-multiple-mapping%EC%97%90-%EC%9D%98%ED%95%9C-bias" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-5. multiple mapping에 의한 bias<a class="anchor-link" href="#1-3-2-5.-multiple-mapping%EC%97%90-%EC%9D%98%ED%95%9C-bias"> </a>
</h4>
<p>특정 read가 한 군데 이상에 mapping이 되는 경우를 multiple mapping이라고 한다. 특정한 read가 한 군데 이상에 mapping이 되어 있는 경우를 말한다.</p>
<h4 id="1-3-2-6.-partial-mapping에-의한-bias">
<a class="anchor" href="#1-3-2-6.-partial-mapping%EC%97%90-%EC%9D%98%ED%95%9C-bias" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-6. partial mapping에 의한 bias<a class="anchor-link" href="#1-3-2-6.-partial-mapping%EC%97%90-%EC%9D%98%ED%95%9C-bias"> </a>
</h4>
<p>partial mapping은 exon에 해당하는 두 개 이상의 read가 겹쳐져 있을 때 발생되는 문제를 말한다. 이러한 read를 chimeric read(또는 fusion transcript)라고도 한다. 예를 들어, 굉장히 짧은 RNA인 miRNA 등의 경우에서 우리가 원하는 miRNA 길이 이상의 read의 길이를 얻는 경우가 발생할 수 있다. 이럴 경우엔 trimming 등의 과정을 거쳐야 한다.</p>
<h4 id="1-3-2-7.-Normalization">
<a class="anchor" href="#1-3-2-7.-Normalization" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-3-2-7. Normalization<a class="anchor-link" href="#1-3-2-7.-Normalization"> </a>
</h4>
<p>RNA sequencing에서 흔히 일어나는 이슈는 Normalization 이슈다. RNA sequencing을 통해 우리가 얻고자 하는 주된 정보 중에 하나가 유전자의 발현량이다. 기본적으로 유전자의 발현량은 RNA sequencing 이후에 해당 유전자의 read가 몇 개나 mapping이 되느냐를 바탕으로 그 양을 추정하게 된다. sequencing 과정에서 동일한 샘플로부터 어떤 경우엔 30M read를 얻고, 어떤 경우엔 60M read의 샘플을 얻을 때, 60M 짜리 read에 해당하는 데이터가 훨씬 많은 정보를 담고 있기 때문에 어쩔 수 없이 특정한 유전자에 mapping될 수 있는 read의 개수가 30M 데이터보다 훨씬 많아 질 수 밖에 없다. 따라서 이를 어떻게 Normalization할지에 대한 고민이 필요하다.</p>
<h2 id="1-4.-NGS-데이터-분석-과정">
<a class="anchor" href="#1-4.-NGS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B3%BC%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-4. NGS 데이터 분석 과정<a class="anchor-link" href="#1-4.-NGS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B3%BC%EC%A0%95"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled4.png" alt=""></p>
<p>raw reads quality control → preprocessing → mapping(aligning) → post-alignment processing → variant calling → annotation → prioritization 과정으로 이루어진다.</p>
<h2 id="1-5.-RNA-seq-상세-과정">
<a class="anchor" href="#1-5.-RNA-seq-%EC%83%81%EC%84%B8-%EA%B3%BC%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5. RNA-seq 상세 과정<a class="anchor-link" href="#1-5.-RNA-seq-%EC%83%81%EC%84%B8-%EA%B3%BC%EC%A0%95"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled5.png" alt=""></p>
<p>이미 살펴 보았듯이 NGS 분석을 위해 위의 그림과 같은 과정을 거치게 된다.</p>
<h3 id="1-5-1.-RNA-분리">
<a class="anchor" href="#1-5-1.-RNA-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1. RNA 분리<a class="anchor-link" href="#1-5-1.-RNA-%EB%B6%84%EB%A6%AC"> </a>
</h3>
<p>Isolate RNA 단계에서 고려할 사항은 어떤 RNA를 sequencing할지를 결정하는 것이다. 정상적인 조직이라면 RNA를 비롯한 유전 물질이 세포 안에 잘 포장돼 있기 때문에 RNA를 분리해내기 위해서는 세포를 갈아버리는 (Lysis) 과정도 필요하고, RNA들만 골라내는 과정도 필요하다. 아래의 cell 분리에 관한 섹션(1-5-1-1은 scRNA-seq에 해당되는 내용이며, 본 노트 전체에서 주제로 다루는 RNA-seq과는 관련성이 떨어진다.)</p>
<h4 id="1-5-1-1.-Capturing-of-Single-Cell">
<a class="anchor" href="#1-5-1-1.-Capturing-of-Single-Cell" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-1. Capturing of Single Cell<a class="anchor-link" href="#1-5-1-1.-Capturing-of-Single-Cell"> </a>
</h4>
<p>Single Cell 단위로 분류하기 위해서는 크게 두 가지 방식을 시도할 수 있다.</p>
<h5 id="1-5-1-1-1.-하나하나-분리">
<a class="anchor" href="#1-5-1-1-1.-%ED%95%98%EB%82%98%ED%95%98%EB%82%98-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-1-1. 하나하나 분리<a class="anchor-link" href="#1-5-1-1-1.-%ED%95%98%EB%82%98%ED%95%98%EB%82%98-%EB%B6%84%EB%A6%AC"> </a>
</h5>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled6.png" alt=""></p>
<p>실험량이 매우 적은(Low-throughput) 경우에 적용 가능한 방식이다. 피펫 등으로 직접 하나씩 집는 방식(Micromanipulation)과 레이저로 얇은 필름에 세포를 하나씩 붙여가며 떼어내는 방식(Laser Capture Microdissection) 등이 있다. 초기 배아세포(Early Embryo) 등 세포 개수가 적은 경우에 이용할 수 있는 방식이다.</p>
<h5 id="1-5-1-1-2.-한꺼번에-분리">
<a class="anchor" href="#1-5-1-1-2.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-1-2. 한꺼번에 분리<a class="anchor-link" href="#1-5-1-1-2.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EB%B6%84%EB%A6%AC"> </a>
</h5>
<ul>
<li>좀 더 많은 세포를 한꺼번에 분석하기 위해서는 세포를 조직으로부터 분리한 후 완충용액에 섞는다. 하지만 대부분의 동물 세포들은 다당류 (Polysaccharide), 당화단백질 (Proteoglycan) 등 다양한 세포외 기질 (Extracellular Matrix, ECM) 로 둘러싸여 있다. 세포를 하나씩 떼어내려면 각종 효소(trypsin, collagenase)를 쳐서 이 구조를 모두 깨야한다. 이러한 효소들은 세포의 생존 능력(Cell Viability) 에 영향을 준다. 이로 인해 세포의 전사체 발현 경향(Transcriptional Profile)이 변할 수 있기 때문에 분석량을 늘리는 대가로 감수해야 할 부분이라고 할 수 있다.</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled7.png" alt=""></p>
<ul>
<li>이 방식에 해당하는 기법으로는 FACS, Microfluicis, Microdoplets 등이 있다. FACS는 세포를 면역형광 (Immunofluorescence) 방식으로 염색한 후, 이를 이용해 세포를 구분하는 방식이다. 예를 들어, FSC와 SSC 두 가지 물질을 이용해 살아있는 세포만을 추출하는 식이다.<ul>
<li>Microfluidics는 칩 안의 미세한 공간으로 세포를 하나씩 집어넣고, 그 안에서 역전사와 증폭이 이뤄지는 방식으로 동작한다. 마지막으로 Microdroplets은 가장 많은 실험량 (High-throughput) 을 가능케 하며, 세포를 특정 방울 (Droplet) 에 가두고 그 안에서 세포의 용해가 이뤄진다.</li>
</ul>
</li>
</ul>
<h4 id="1-5-1-2.-RNA-분리:-rRNA-depletion-vs.-Poly-A-selection">
<a class="anchor" href="#1-5-1-2.-RNA-%EB%B6%84%EB%A6%AC:-rRNA-depletion-vs.-Poly-A-selection" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-2. RNA 분리: rRNA depletion vs. Poly-A selection<a class="anchor-link" href="#1-5-1-2.-RNA-%EB%B6%84%EB%A6%AC:-rRNA-depletion-vs.-Poly-A-selection"> </a>
</h4>
<p>사람이나 쥐 등의 mammalian cell로부터 RNA를 추출했다고 가정해본다면, 해당 RNA에는 rRNA(ribosomal RNA)가 80%, tRNA(transfer RNA)가 15% 정도 들어있다. 따라서 RNA 전체(total RNA)를 그대로 sequencing하면 mRNA가 아닌 rRNA나 tRNA를 sequencing하는 셈이 된다. 즉, rRNA와 tRNA에 의한 data contamination이 발생한다. 이를 해결하기 위해 다음의 두 가지 선택지 중 하나를 고려해야 한다.</p>
<h5 id="1-5-1-2-1.-rRNA-depletion">
<a class="anchor" href="#1-5-1-2-1.-rRNA-depletion" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-2-1. rRNA depletion<a class="anchor-link" href="#1-5-1-2-1.-rRNA-depletion"> </a>
</h5>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled8.png" alt=""></p>
<p>rRNA depletion은 mRNA에 대한 sequencing을 수행하기 위해 rRNA를 depletion(크게 감소시키는)하는 과정이다. 이와 같이 rRNA를 없애고 sequencing하는 방법을 total RNA sequencing이라고 표현한다. 이 방법의 장점은 rRNA, tRNA, small RNA 처럼 풍부(abundant)하면서도, 굳이 읽지 않아도 되는 서열들을 제거함으로써 많은 non-coding RNA에 대한 정보를 얻을 수 있다는 점이다. 반면, 단점도 이다. RNA 유전자에는 exon보다 intron이 훨씬 더 많고, 길다. 즉, Poly-Adenylation 되기 전에 intron이 다수 껴있는 RNA들을 대거 sequencing하게 되기 때문에, total RNA sequencing을 수행하면 intron을 끼고 있는 RNA들이 sequencing된다는 단점이 있다. 따라서 ribosome을 depletion한 후, 그대로 total RNA sequencing을 할지, mRNA sequencing을 할지 결정해야 한다.</p>
<h5 id="1-5-1-2-2.-Poly-A-selection">
<a class="anchor" href="#1-5-1-2-2.-Poly-A-selection" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-1-2-2. Poly-A selection<a class="anchor-link" href="#1-5-1-2-2.-Poly-A-selection"> </a>
</h5>
<p>rRNA, tRNA는 그대로 둔 채, mRNA의 3'-end에 붙어 있는 Poly-A를 capture할 수 있는 oligo dt 서열이 있는 bead를 이용하여 RNA를 capture하는 방법이다. 이를 mRNA sequencing이라고 표현한다.</p>
<h3 id="1-5-2.-cDNA-제작:-Poly-A-priming-vs.-Random-priming">
<a class="anchor" href="#1-5-2.-cDNA-%EC%A0%9C%EC%9E%91:-Poly-A-priming-vs.-Random-priming" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-2. cDNA 제작: Poly-A priming vs. Random priming<a class="anchor-link" href="#1-5-2.-cDNA-%EC%A0%9C%EC%9E%91:-Poly-A-priming-vs.-Random-priming"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled9.png" alt=""></p>
<ul>
<li>세포를 분리했다면, 이번에는 RNA를 cDNA로 바꿔줄 단계다. 이 단계는 RNA를 역전사(Reverse Transcription) 하여 cDNA(Complementary DNA, 주어진 RNA에 상보적으로 생긴 DNA)를 만들어내는 과정이다. (scRNA-seq이라면 PCR을 이용해 샘플 양을 충분히 증가시켜 줄 필요가 있다.) 따라서 cDNA를 만들기 위해서는 reverse transcription 단계에서 쓰일 primer가 필요하다.</li>
<li>mRNA의 경우 폴리-A 꼬리 (Poly-A Tail)을 함유하고 있다. 따라서, mRNA에 대한 분석을 위해 폴리-T 시퀀스에 프로모터를 융합한 프라이머인 Poly-A priming을 이용하여 cDNA를 만들 수 있다.<ul>
<li>Poly-A를 priming하게 되면 oligo dt로 priming을 수행하여 cDNA를 합성하게 된다. 이 방법의 단점은, 만약 RNA를 뽑는 과정에서 degradation된 RNA에 대해 Poly-A 쪽을 priming 했을 때, cDNA가 3'부터 5'까지 합성되어 가는 과정에서 더이상 5'-end까지 가지 못하고 중간에서 멈추는 일이 발생한다는 점이다.</li>
<li>따라서 Poly-A만 priming해서 cDNA를 만들 경우, RNA quality가 완벽하지 않으면 sequencing 이후의 NGS read를 mapping 하게 되면, read가 전체 gene에 균일하게 mapping되는 것이 아니라 유독 3'-end 쪽에만 mapping되는 bias가 발생할 수 있다.</li>
<li>따라서 priming을 하는데에 있어서도 반드시 Poly-A를 priming을 하는 것보다는 random primer로 priming하면서 cDNA를 만들 필요가 있다.</li>
</ul>
</li>
</ul>
<h3 id="1-5-3.-Library-제작:-RNA-ligation-method-vs.-dUTP-method">
<a class="anchor" href="#1-5-3.-Library-%EC%A0%9C%EC%9E%91:-RNA-ligation-method-vs.-dUTP-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-3. Library 제작: RNA ligation method vs. dUTP method<a class="anchor-link" href="#1-5-3.-Library-%EC%A0%9C%EC%9E%91:-RNA-ligation-method-vs.-dUTP-method"> </a>
</h3>
<ul>
<li>현재 대부분의 Sequencing은 전체 시퀀스를 한 번에 읽지 않고 여러 조각으로 쪼개어 읽는 샷건 방식을 이용한다. 세부 방식은 매우 다양하지만, 일반적으로 작은 어댑터(Adaptor) 시퀀스를 더해준 후 라이브러리(Library)를 완성한다. 이를 통해, 결과적으로는 작은 RNA 시퀀스 조각들인 리드(reads)를 얻게 된다.</li>
<li>cDNA를 만든 후, Library를 만드는 방식에 있어서도 방법을 선택할 필요가 있다. 라이브러리를 만드는 과정 중, 꼭 읽을 필요가 없는 정보가 있는데 그 정보는 바로 strand 정보다. 알다시피 DNA는 이중나선인데, 이중나선 중 watson strand 또는 crick strand 각각에서 RNA가 만들어진다. 즉, 둘 중 어느 strand에서 RNA가 만들어졌는지 파악하기 힘들다는 문제가 발생한다. 이를 해결하기 위한 원리엔 DNA와 RNA의 방향성 유무에 있다. DNA는 방향성이 없지만 RNA는 방향성이 있다. 따라서 RNA sequencing을 했을 때 우리가 얻은 read가 과연 watson strand에서 transcription이 일어났는지 crick strand에서 transcription이 일어났는지에 대하여, 그 정보를 계속 유지하면 RNA sequencing의 결과를 믿을 수 있게 된다. 그럼 어떻게 RNA의 방향성 정보를 유지할까?</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled10.png" alt=""></p>
<h4 id="1-5-3-1.-RNA-ligation-method">
<a class="anchor" href="#1-5-3-1.-RNA-ligation-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-3-1. RNA ligation method<a class="anchor-link" href="#1-5-3-1.-RNA-ligation-method"> </a>
</h4>
<p>DNA의 이중나선의 방향성을 파악하기 위해서는 각 ss nucleic acid의 왼쪽과 오른쪽에 다른 종류의 adaptor를 붙인다. 우리가 알고 있는 다른 종류의 adaptor를 양 끝단에 붙이면 왼쪽 끝과 오른쪽 끝 서열이 다르기 때문에 primer를 다르게 쓸 수 있다. 가장 쉬운 아이디어는 cDNA가 만들어지기 전 RNA에서 5'-end, 3'-end에 direct로 RNA adaptor를 ligation 시키는 방법이다.</p>
<h4 id="1-5-3-2.-dUTP-method">
<a class="anchor" href="#1-5-3-2.-dUTP-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-3-2. dUTP method<a class="anchor-link" href="#1-5-3-2.-dUTP-method"> </a>
</h4>
<p>dUTP 방식은 cDNA를 만들 때 한 쪽 strand에 dUTP가 들어가게 만드는 방식이다. 그 다음 ds 양 끝 단에 Y shape adaptor를 붙인다. dUTP가 들어간 strand는 degradation되도록 효소가 들어가게 되어 한 쪽 가닥을 없앨 수 있다. Y shape이 되도록 만드는 방법은 Y shape이 되도록 서열을 만드는 것이다. 즉, DNA는 서로 상보적으로 A-T, G-C로 수소결합을 이루는 상태인데, 이를 서로 상보적인지 않은(not reverse complementary) 상태로 만든다. 즉 Y shape을 이루는 마주보는 두 서열은 서로 다른 서열을 갖게 된다.</p>
<h4 id="1-5-3-3.-RT-method">
<a class="anchor" href="#1-5-3-3.-RT-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-5-3-3. RT method<a class="anchor-link" href="#1-5-3-3.-RT-method"> </a>
</h4>
<p>이 외에 RT method 방식도 있다.</p>
<h2 id="1-6.-QC">
<a class="anchor" href="#1-6.-QC" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-6. QC<a class="anchor-link" href="#1-6.-QC"> </a>
</h2>
<p>1-5 과정을 통해 sequencing 데이터가 만들어지면 대부분의 시퀀싱 데이터들은 QC(Quality Control; 품질 관리) 과정을 거쳐야 한다. 이 과정을 통해 read의 길이와 수를 체크하고, contaminating 시퀀스나 낮은 quality의 시퀀스가 있는지 찾아야한다. 즉 이 데이터가 깔끔한 데이터인지, 얼마만큼 깔끔한지, base quality가 좋은지, adaptor contamination은 없는지 여부 등을 살피게 된다.</p>
<h2 id="1-7.-preprocessing">
<a class="anchor" href="#1-7.-preprocessing" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-7. preprocessing<a class="anchor-link" href="#1-7.-preprocessing"> </a>
</h2>
<p>이 과정은 시퀀스의 퀄리티를 증가시키기 위한 과정이다. QC와 preprocessing 과정은 매우 중요하며, 이 과정이 제대로 되어야 이후의 분석 결과를 신뢰할 수 있게 된다.</p>
<h2 id="1-8.-mapping(또는-alignment)">
<a class="anchor" href="#1-8.-mapping(%EB%98%90%EB%8A%94-alignment)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-8. mapping(또는 alignment)<a class="anchor-link" href="#1-8.-mapping(%EB%98%90%EB%8A%94-alignment)"> </a>
</h2>
<ul>
<li>QC 과정과 preprocessing 과정을 거친 이후에 가장 첫째로 하는 분석은 mapping 또는 alignment다. 각 리드를 레퍼런스 유전체(Reference Genome)에 배열(Mapping)하거나, 참조하는 유전체 없이 직접 새로운 (De novo) 배열을 조립하는 것을 말한다. RNA sequencing을 통해 sequencing read들이 발생하는데, 각 read들을 genome에 alignment하는 것이다. 즉, reads를 reference genome이나 reference transcriptome에 정렬하는 것을 뜻한다. (reference genome은 표준게놈 또는 참조게놈 또는 참조 서열 등으로 불리며, HG19, HG38 등을 예로 들 수 있다.) 예를 들어 WES 데이터의 경우 WES 데이터의 read를 reference genome에 mapping 한다면, reference와 WES 데이터의 시퀀스 간의 다른 부분(variant)을 알아낼 수 있게 되고, 이 variant의 정확도는mapping accuracy에 의존적이다.</li>
<li>따라서 그 다음에 해야할 일은 바로 mapping quality를 체크하는 일이다. 데이터의 특정 종류의 bias는 mapping step 이후 나타난다. mapping quality가 만족스럽지 않으면 이를 processing하는 과정을 거쳐야 한다. 다음 섹션에서 언급할 post-alignment processing이 그것이다.</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled11.png" alt=""></p>
<ul>
<li>a: read가 exon 부위에만 쌓이는 것이 아니라 intron 부위에도 쌓인다. 가장 이상적인 read의 모습은 read 하나하나가 조금씩 어긋나면서 쌓이는 형태(a-1)이다. 만약 동일한 위치에 read가 계속 쌓인다면(a-2) PCR에 의한 duplication을 의심해야 한다. 이러한 류의 read의 문제는 해당 read들이 여러 molecule에 의해 나온 read가 아닌 PCR에 의해 bias가 생긴 것이므로 유전자 발현량을 정량화 하는데에 있어서도 bias가 생길 수 밖에 없다는 점이다.</li>
<li>b: RNA는 방향성이 있다. 따라서 read도 RNA의 방향대로 mapping이 된다. 이는 Library 제작 부분에서 다루었듯이 방향성을 부여하는 adaptor를 부착하는 등의 처리를 했기 때문이다. 그러나 antisense orientation(역방향)으로 mapping되어 있는 read들이 낮지 않은 확률로 발생한다. 이는 과학적으로 발생 가능한 현상이기도 하지만, DNA contamination에 의해 DNA도 함께 sequencing된 현상으로도 볼 수 있다. 이를 구분해야 한다.</li>
<li>c: read들이 정상적으로 mapping되지 않고 특정 구조를 이루면서 mapping이 된다면 RNA가 실제로 그러한 구조적인 모양을 띄고 있을 수도 있고, RNA가 심하게 degradation된 것으로 해석할 수 있다.</li>
</ul>
<p>read자체가 ambiguous하게 mapping되는 경우도 있다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled12.png" alt=""></p>
<ul>
<li>첫 번째 케이스는 가장 이상적이다.</li>
<li>두 번째 케이스는 read가 유전자 바깥으로 빠져나갔다. 해당 read가 유전자의 일부라고 볼 수 있을까? 애매하다.</li>
<li>세 번째 케이스는 중간에 intron을 걸쳐서 mapping된 경우다. 애매한 경우다.</li>
<li>네 번째 케이스는 이상적인 케이스다.</li>
<li>다섯번째 케이스는 유전자가 overlap되어 annotation되었으나 read가 A 유전자에 mapping된 경우다. 이상적이다. 따라서 A 유전자의 발현량으로 계산하면 된다.</li>
<li>여섯번째와 케이스는 read의 일부가 두 유전자 모두에 mapping 되어 있는 것이다. 애매한 경우다.</li>
<li>일곱번째 케이스는 유전자 모두에 mapping 되어 있다. 애매한 경우다.</li>
</ul>
<p>HT-Seq이라는 RNA sequencing read들을 mapping하고 counting하는 python프로그램을 이용하면, 위의 케이스들을 고려하여 자동적으로 read counting을 해준다.</p>
<h2 id="1-9.-post-alignment-processing">
<a class="anchor" href="#1-9.-post-alignment-processing" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-9. post-alignment processing<a class="anchor-link" href="#1-9.-post-alignment-processing"> </a>
</h2>
<p>post-alignment processing은 예를 들어, 중복된 mapped read를 제거하는 것을 의미한다. 중요한 과정이며 다음 분석에 큰 영향을 미친다.</p>
<h2 id="1-10.-variant-calling">
<a class="anchor" href="#1-10.-variant-calling" aria-hidden="true"><span class="octicon octicon-link"></span></a>1-10. variant calling<a class="anchor-link" href="#1-10.-variant-calling"> </a>
</h2>
<ul>
<li>시퀀스가 참조 서열에 align 되었다면, 데이터를 experiment-specific한 방법으로 분석을 해야할 필요가 있다. 따라서 WES 데이터를 참조 서열에 mapping한 후에, variant 분석을 수행한다. 즉, variant calling과 그 variant가 gene에 미치는 영향 (단백질의 변화, frame shift 등)을 알아본다. 이 과정에서 시퀀스를 참조 서열과 비교하고, 차이를 확인하여 이 차이가 유전자에 얼마나 큰 영향을 미칠지에 대해 분석해야 한다.</li>
<li>예를 들어, 이것이 snynonymous variant(mRNA가 생성하는 아미노산에 변화가 없는 변이)인 경우에는 이 영향이 미미할 것이다. 하지만 그 variant가 사이즈가 큰 deletion 이라면, 해당 시퀀스를 포함하는 유전자에 큰 영향을 줄 것이라고 예측해볼 수 있다. 분석과는 별개로 데이터를 visualization 해볼 수도 있다. mapped read 데이터를 visualising 함에 있어 가장 표준적인 tool 중 하나는 Genome Browser다.</li>
</ul>
<h1 id="2.-Methods-in-RNA-seq">
<a class="anchor" href="#2.-Methods-in-RNA-seq" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Methods in RNA-seq<a class="anchor-link" href="#2.-Methods-in-RNA-seq"> </a>
</h1>
<p>RNA sequencing에서 Library를 만드는 다양한 방법들이 있다. 그 중 단백질에 붙는 RNA를 찾아낼 수도 있고, 리보솜에서 Translation되는 RNA를 찾는 방법 등 여러 방법들이 있다. 이 섹션에서는 각종 sequencing 방법들에 대해 다루고자 한다.</p>
<h2 id="2-1.-short-read-RNA-seq-장비">
<a class="anchor" href="#2-1.-short-read-RNA-seq-%EC%9E%A5%EB%B9%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-1. short read RNA-seq 장비<a class="anchor-link" href="#2-1.-short-read-RNA-seq-%EC%9E%A5%EB%B9%84"> </a>
</h2>
<p>어떤 기계, 어떤 플랫폼을 쓸 것인가.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled13.png" alt=""></p>
<p>일루미나는 시장 점유율 90%에 육박하며, short read sequencing 데이터를 high-quality로 생산해낸다. 위 기기의 왼쪽의 세 개의 기기는 적은 량의 데이터를 생산한다. 그렇기 때문에 전사체의 sequencing 분석 결과를 보기엔 부적절하다. miRNA는 데이터가 많이 필요하지 않으므로 적합하다. 일루미나 장비 중 가장 긴 시퀀스를 얻을 수 있는 장비는 MiSeq이다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled14.png" alt=""></p>
<p>NovaSeq은 엄청난 데이터를 생산해낸다. 시퀀싱 샘플이 있을 때, 어느 정도의 read 길이가 필요한지, 데이터량은 얼만큼 필요한지 등을 고려하여 적절한 플랫폼을 정해야 한다.</p>
<h2 id="2-2.-long-read-RNA-seq-장비">
<a class="anchor" href="#2-2.-long-read-RNA-seq-%EC%9E%A5%EB%B9%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-2. long read RNA-seq 장비<a class="anchor-link" href="#2-2.-long-read-RNA-seq-%EC%9E%A5%EB%B9%84"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled15.png" alt=""></p>
<p>일루미나만이 시퀀싱의 전부가 아니다. long read sequencing 장비 중 대표적인 것은 PacBio와 Oxford Nanopore가 있다. 둘 중 Oxford Nanopore가 더 긴 sequencing이 가능하다. 이 장비들의 단점은 base quality가 낮다는 것이다. 즉, 일루미나는 read의 길이가 짧지만 높은 퀄리티를, PacBio와 Nanopore는 긴 read를 읽지만 퀄리티가 낮다. 퀄리티가 낮은 이유는 single molecule 기반의 sequencing이기 때문이다. PacBio사의 장비는 IsoFrom을 볼 수 있다는 점이 장점이다. Oxford Nanopore사의 장비의 최대 장점은 direct RNA sequencing이다. RNA를 그냥 그대로 집어넣어 전류의 변화로만 알아내는, cDNA 방식을 쓰지 않는 것이다.</p>
<h3 id="2-2-1.-long-read-sequencing의-장점">
<a class="anchor" href="#2-2-1.-long-read-sequencing%EC%9D%98-%EC%9E%A5%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-2-1. long read sequencing의 장점<a class="anchor-link" href="#2-2-1.-long-read-sequencing%EC%9D%98-%EC%9E%A5%EC%A0%90"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled16.png" alt=""></p>
<p>두 개의 transcript가 있을 때, short read로 읽게 되면 둘 중 어느 transcript에 해당하는 read인지 알 수 없다는 점이 문제다. 그러나 PacBio나 Oxford Nanopore사의 long read 기술을 이용하면 두 transcript를 구분할 수 있다. 특히, Nanopore와 같은 direct RNA sequencing 기술을 이용하면 추가적으로 메틸화 된, 즉 변이된 유전자를 발견할 수도 있다. 이는 전류의 변화로 메틸레이션을 감지하기 때문에 가능하다. 그러나 long read sequencing은 RNA sequencing에서 반드시 좋다고만은 할 수 없다. 주어진 throghput은 일루미나보다는 낮다는 단점 등이 있다.</p>
<h2 id="2-3.-short-vs.-long-read-RNA-sequencing-장비-비교">
<a class="anchor" href="#2-3.-short-vs.-long-read-RNA-sequencing-%EC%9E%A5%EB%B9%84-%EB%B9%84%EA%B5%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-3. short vs. long read RNA sequencing 장비 비교<a class="anchor-link" href="#2-3.-short-vs.-long-read-RNA-sequencing-%EC%9E%A5%EB%B9%84-%EB%B9%84%EA%B5%90"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled17.png" alt=""></p>
<ul>
<li>일루미나 장비는 주어진 비용 대비 100배~1000배 정도의 시퀀싱 데이터를 얻을 수 있다. 데이터가 풍부하므로 작은 양의 RNA로부터도 많은 데이터를 얻을 수 있다는 장점이 있다. 또한, 분석법이 잘 정립되어 있다. 쉽게 따라할 수 있다는 것이다. degraded RNA도 시퀀싱 가능하다. 그러나 reverse transcription 등 여러가지 sample prep. 과정에서 bias가 발생 가능하다는 점이다. 또한 isoform을 정확하게 detection할 수 없다. short read의 단점은 고스란히 long read의 장점이 된다.</li>
<li>PacBio는 run 한 번 당 적은 read를 얻는다. IsoSeq도 적은 throughput을 보인다. 엄청나게 많은 read수를 얻을 수는 없다. degradation RNA를 시퀀싱 할 수도 없다. PacBio도 나름의 라이브러리 prep 과정을 거치기 때문에 나름의 bias가 발생할 수 있다. 또한 cDNA로 만들어지는 과정에서 modification 정보가 사라지므로 modification을 detection할 수 없다.</li>
<li>ONT(Oxford Nanopore)는 direct RNA 시퀀싱이 가능하다. RNA modification을 detection 할 수 있다는 점이 가장 큰 장점이다. PacBio사가 가지지 못한 장점이다. 또한 throughput은 여전히 낮다.</li>
</ul>
<h2 id="2-4.-RNA-seq-이-외의-sequencing-기법들">
<a class="anchor" href="#2-4.-RNA-seq-%EC%9D%B4-%EC%99%B8%EC%9D%98-sequencing-%EA%B8%B0%EB%B2%95%EB%93%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-4. RNA-seq 이 외의 sequencing 기법들<a class="anchor-link" href="#2-4.-RNA-seq-%EC%9D%B4-%EC%99%B8%EC%9D%98-sequencing-%EA%B8%B0%EB%B2%95%EB%93%A4"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled18.png" alt=""></p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled19.png" alt=""></p>
<p>RNA-seq 이외에 sequencing 기법들은 굉장히 다양하다.</p>
<h1 id="3.-RNA-seq-Analysis-Pipeline">
<a class="anchor" href="#3.-RNA-seq-Analysis-Pipeline" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. RNA-seq Analysis Pipeline<a class="anchor-link" href="#3.-RNA-seq-Analysis-Pipeline"> </a>
</h1>
<p>RNA sequencing을 분석하는 computational 방법도 매우 다양하다. 이 섹션에서는 RNA sequencing을 수행하기 위해서 어떤 파이프라인이 있는지, 어떤 순서대로 분석을 하면 되는지를 다룬다. 배운 내용을 바탕으로 실습 또한 해보고자 한다.</p>
<h2 id="3-1.-RNA-seq-분석-시-사용되는-프로그램(tool)">
<a class="anchor" href="#3-1.-RNA-seq-%EB%B6%84%EC%84%9D-%EC%8B%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8(tool)" aria-hidden="true"><span class="octicon octicon-link"></span></a>3-1. RNA-seq 분석 시 사용되는 프로그램(tool)<a class="anchor-link" href="#3-1.-RNA-seq-%EB%B6%84%EC%84%9D-%EC%8B%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8(tool)"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled20.png" alt=""></p>
<p>RNA 데이터를 sequencing할 수 있는 다양한 tool들이 있다. sequencing 데이터를 분석 하다보면 자주 쓰이는 tool들이 있다. 대표적으로 STAR, HISAT, TopHat 등이 있는데, 각 tool의 이름을 들었을 때 무엇을 하는 tool인지 정도는 알고 있어야 한다.</p>
<ul>
<li>alignment: STAR, HISAT, TopHat</li>
<li>De novo assembly: StringTie, Cufflinks</li>
<li>alignment 없이 유전자 발현량을 RNA sequencing 데이터에서 얻게 하는 tool: Kallisto</li>
<li>FPKM, TPM값 구해주는 tool: RSEM</li>
<li>read counting: HTSeq, featureCounts</li>
<li>depressed expression된 gene을 찾아주는 tool: limma+voom, DESeq2 등</li>
</ul>
<h2 id="3-2.-How-to-analyze-RNA-seq-data?">
<a class="anchor" href="#3-2.-How-to-analyze-RNA-seq-data?" aria-hidden="true"><span class="octicon octicon-link"></span></a>3-2. How to analyze RNA-seq data?<a class="anchor-link" href="#3-2.-How-to-analyze-RNA-seq-data?"> </a>
</h2>
<p>tool은 항상 새로운 게 나오거나 업데이트 되지만 전체적인 분석 step은 변하지 않는다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled21.png" alt=""></p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled22.png" alt=""></p>
<ul>
<li>
<strong>STEP 1</strong>. Evaluate and Manipulate raw data.<ul>
<li>raw data인 fastq 데이터가 나오면 QC 작업을 통해 안 좋은 데이터를 버리는 작업이 필요하다. → <code>FastQC</code>
</li>
<li>read 내에서 버릴 base 등이 있으면 trimming등을 통해 버려야 한다. → <code>trimmomatic</code>
</li>
</ul>
</li>
<li>
<strong>STEP 2</strong>. Map to reference. assess results<ul>
<li>mapping 작업. STAR too이 대중적이지만, 원하는 것을 고를 수 있다. → <code>BWA</code> or <code>STAR</code> or <code>TopHat</code>
</li>
</ul>
</li>
<li>
<strong>STEP 3</strong>. Assemble transcripts<ul>
<li>optional. 하고 싶으면 한다.</li>
</ul>
</li>
<li>
<strong>STEP 4</strong>. Quantify transcripts<ul>
<li>유전자 발현량을 측정하기 위해 Quantification이 필요하다. 즉, read counting 작업이다. 이 결과로 Expedted count, FPKM, TPM 등의 결과를 얻게 된다. 유전자 당 발현량 정보다.→ <code>RSEM</code>
</li>
</ul>
</li>
<li>
<strong>STEP 5</strong>. Test for differential expression<ul>
<li>differential expressed 된 gene에 대한 통계적 테스트 → <code>DEseq2</code><ul>
<li>DEseq2는 R 패키지다.</li>
</ul>
</li>
</ul>
</li>
<li>
<strong>STEP 6</strong>. Visualize and Perform other downstream analysis<ul>
<li>
<code>UCSC genome browser</code>나 <code>IGV</code>를 이용하여 시각적으로 나타낼 수 있다.</li>
<li>클러스터링을 위해 <code>hclust</code>라는 프로그램을 사용할 수 있다.</li>
<li>아래 그림은 IGV 프로그램에 의해 나온 시각화 결과의 예시다.</li>
</ul>
</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled23.png" alt=""></p>
<p>업계 내 업체마다 쓰이는 툴들이 조금씩 다를 수 있다. 만약 어떤 툴을 써야 할 지 감을 못 잡겠다면, TCGA, ENCODE, PCAWG같은 컨퍼런스나 학회 등에서 제시한 가이드라인을 따른다. TCGA에서는 다음과 같은 파이프라인을 제안하고 있다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled24.png" alt=""></p>
<h1 id="4.-Quantification-of-Gene-Expression-from-RNA-seq">
<a class="anchor" href="#4.-Quantification-of-Gene-Expression-from-RNA-seq" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Quantification of Gene Expression from RNA-seq<a class="anchor-link" href="#4.-Quantification-of-Gene-Expression-from-RNA-seq"> </a>
</h1>
<ul>
<li>생물정보학에서 굉장히 흔하게 접할 수 있는 용어 중 하나로 RPKM, FPKM, TPM이 있다. RNA sequencing은 유전자의 발현량을 측정하기 위해 쓰이는데, 이 섹션에서는 이론적인 측면에서 보았을 때 RNA sequencing을 통해 어떻게 유전자 발현량을 계산할 수 있는지를 보고자 한다.</li>
<li>RPKM, FPKM, TPM은 RNA-seq의 발현 분석에서 normalized gene expression을 의미하는 것으로서, 초창기에는 RPKM이 많이 쓰였으나 FPKM을 거쳐 현재에는 TPM을 주로 사용하고 있다. FPKM 또한 많이 사용 중이다.</li>
</ul>
<h2 id="4-1.-FPKM,-RPKM">
<a class="anchor" href="#4-1.-FPKM,-RPKM" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1. FPKM, RPKM<a class="anchor-link" href="#4-1.-FPKM,-RPKM"> </a>
</h2>
<ul>
<li>FPKM은 <strong>F</strong>ragments <strong>P</strong>er <strong>K</strong>ilobase per <strong>M</strong>illions mapped reads의 약자다.</li>
<li>RPKM은 <strong>R</strong>eads <strong>P</strong>er <strong>K</strong>ilobase per <strong>M</strong>illions mapped reads의 약자다. RPKM은 single-end RNA-seq용으로 제작되었다. 전체 유전자의 길이를 Kilobase(=1000 base pair)로 정규화했을 때 전체 reads 중에서 해당 gene에 mapping된 reads들을 말한다. 그런데 이 수는 너무 적기 때문에 10^6을 곱해준다.</li>
<li>따라서, FPKM, RPKM은 gene 단위의 expression이다.</li>
</ul>
<p>유전자 1Kb당 fragment의 개수를 의미한다고 보면 된다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled25.png" alt=""></p>
<p>유전자의 길이가 길 수록 더 많은 read가 쌓이는 것은 자명하다. 즉 유전자 길이에 따라 mapping될 수 있는 read의 개수에 차이가 있다. 따라서 mapping된 read의 개수를 유전자의 길이(주로 Kb 단위임)로 나눠준다.</p>
<h3 id="4-1-1.-계산식">
<a class="anchor" href="#4-1-1.-%EA%B3%84%EC%82%B0%EC%8B%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1-1. 계산식<a class="anchor-link" href="#4-1-1.-%EA%B3%84%EC%82%B0%EC%8B%9D"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled26.png" alt=""></p>
<h3 id="4-1-2.-실제-계산:-세로-→-가로">
<a class="anchor" href="#4-1-2.-%EC%8B%A4%EC%A0%9C-%EA%B3%84%EC%82%B0:-%EC%84%B8%EB%A1%9C-%E2%86%92-%EA%B0%80%EB%A1%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1-2. 실제 계산: 세로 → 가로<a class="anchor-link" href="#4-1-2.-%EC%8B%A4%EC%A0%9C-%EA%B3%84%EC%82%B0:-%EC%84%B8%EB%A1%9C-%E2%86%92-%EA%B0%80%EB%A1%9C"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled27.png" alt=""></p>
<p>Rep3를 보면 gene에 상관없이 다른 replicate들보다 많은 reads를 가진 것을 알 수 있다. 이는 sequencing depth가 다른 replicate들보다 높다는 걸 의미한다. 또한 gene B는 gene A에 2배에 해당하는 ‘길이’를 가지고 있다. 이것은 replicate에 상관없이 2배 많은 reads를 가지고 있다는 것을 설명하는 것일 수도 있다. 이 각각을 normalize(정규화) 하는데, FPKM 또는 RPKM에서는 세로로 먼저 정규화 한 다음, 가로로 정규화한다.</p>
<h4 id="4-1-2-1.-Normalization-for-read-depth">
<a class="anchor" href="#4-1-2-1.-Normalization-for-read-depth" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1-2-1. Normalization for read depth<a class="anchor-link" href="#4-1-2-1.-Normalization-for-read-depth"> </a>
</h4>
<p>첫 번째 단계는 read depth로 정규화하는 것이다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled28.png" alt=""></p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled29.png" alt=""></p>
<p>계산상의 편의를 위해 M(1,000,000)가 아닌 K(1,000)로 나누었다. 계산된 3.5, 4.5, 10.6은 각 replicate들에 대한 “per million” scaling factors가 된다. 이제 각 gene의 read counts을 이 값들로 나누어야 한다. 그러면 reads per million을 계산할 수 있는데 이를 RPM(FPM)이라고 한다.</p>
<h4 id="4-1-2-2.-Normalization-for-gene-length">
<a class="anchor" href="#4-1-2-2.-Normalization-for-gene-length" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1-2-2. Normalization for gene length<a class="anchor-link" href="#4-1-2-2.-Normalization-for-gene-length"> </a>
</h4>
<p>두 번째 단계는 gene length로 정규화하는 것이다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled30.png" alt=""></p>
<h4 id="4-1-2-3.-계산-결과">
<a class="anchor" href="#4-1-2-3.-%EA%B3%84%EC%82%B0-%EA%B2%B0%EA%B3%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-1-2-3. 계산 결과<a class="anchor-link" href="#4-1-2-3.-%EA%B3%84%EC%82%B0-%EA%B2%B0%EA%B3%BC"> </a>
</h4>
<p>그 결과, RPKM(FPKM) 데이터를 획득하게 된다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled31.png" alt=""></p>
<h2 id="4-2.-TPM">
<a class="anchor" href="#4-2.-TPM" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2. TPM<a class="anchor-link" href="#4-2.-TPM"> </a>
</h2>
<p>TPM은 Transcripts Per Million의 약자로 FPKM, RPKM과 유사한 개념이지만 transcript length의 분포까지 포함한 개념이다. 최근 많이 쓰이는 추세다.</p>
<h3 id="4-2-1.-계산식">
<a class="anchor" href="#4-2-1.-%EA%B3%84%EC%82%B0%EC%8B%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2-1. 계산식<a class="anchor-link" href="#4-2-1.-%EA%B3%84%EC%82%B0%EC%8B%9D"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled32.png" alt=""></p>
<h3 id="4-2-2.-실제-계산:-가로-→-세로">
<a class="anchor" href="#4-2-2.-%EC%8B%A4%EC%A0%9C-%EA%B3%84%EC%82%B0:-%EA%B0%80%EB%A1%9C-%E2%86%92-%EC%84%B8%EB%A1%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2-2. 실제 계산: 가로 → 세로<a class="anchor-link" href="#4-2-2.-%EC%8B%A4%EC%A0%9C-%EA%B3%84%EC%82%B0:-%EA%B0%80%EB%A1%9C-%E2%86%92-%EC%84%B8%EB%A1%9C"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled27.png" alt=""></p>
<p>4-1 섹션에서와 동일한 데이터를 가져왔다. TPM에서는 세로로 먼저 정규화 한 다음, 가로로 정규화한다. 마찬가지로 각 gene의 read counts을 이 값들로 나눈다. 그러면 reads per million을 계산할 수 있고 이를 이라고 한다.</p>
<h4 id="4-2-2-1.-Normalization-for-gene-length">
<a class="anchor" href="#4-2-2-1.-Normalization-for-gene-length" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2-2-1. Normalization for gene length<a class="anchor-link" href="#4-2-2-1.-Normalization-for-gene-length"> </a>
</h4>
<p>첫 번째 단계는 gene length로 정규화하는 것이다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled33.png" alt=""></p>
<h4 id="4-2-2-2.-Normalization-for-read-depth">
<a class="anchor" href="#4-2-2-2.-Normalization-for-read-depth" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2-2-2. Normalization for read depth<a class="anchor-link" href="#4-2-2-2.-Normalization-for-read-depth"> </a>
</h4>
<p>두 번째 단계는 read depth로 정규화하는 것이다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled34.png" alt=""></p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled35.png" alt=""></p>
<p>역시 계산상의 편의를 위해 M(1,000,000)가 아닌 K(1,000)로 나누었다. 계산된 1.5, 2.025, 4.51은 각 replicate들에 대한 “per million” scaling factors가 된다.</p>
<h4 id="4-2-2-3.-계산-결과">
<a class="anchor" href="#4-2-2-3.-%EA%B3%84%EC%82%B0-%EA%B2%B0%EA%B3%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-2-2-3. 계산 결과<a class="anchor-link" href="#4-2-2-3.-%EA%B3%84%EC%82%B0-%EA%B2%B0%EA%B3%BC"> </a>
</h4>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled36.png" alt=""></p>
<h2 id="4-3.-RPKM과-TPM의-결과-비교">
<a class="anchor" href="#4-3.-RPKM%EA%B3%BC-TPM%EC%9D%98-%EA%B2%B0%EA%B3%BC-%EB%B9%84%EA%B5%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-3. RPKM과 TPM의 결과 비교<a class="anchor-link" href="#4-3.-RPKM%EA%B3%BC-TPM%EC%9D%98-%EA%B2%B0%EA%B3%BC-%EB%B9%84%EA%B5%90"> </a>
</h2>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled37.png" alt=""></p>
<p>RPKM과 TPM의 결과와 그 의미는 서로 다르다. 동일한 데이터이므로 둘 다 gene length와 sequencing depth의 편향(bias)이 일치하지만, 각 column에 대한 정규화된 총 reads는 매우 다르다. RPKM은 각 sample마다 다른 값을 얻었다면, TPM은 같은 값을 얻었다.</p>
<h3 id="4-3-1.-comparison-among-TPMs">
<a class="anchor" href="#4-3-1.-comparison-among-TPMs" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-3-1. comparison among TPMs<a class="anchor-link" href="#4-3-1.-comparison-among-TPMs"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled38.png" alt=""></p>
<p>TPM은 모든 replicate에 대하여 총 count 수가 동일하도록 보정되었기 때문에 각 gene에 어떤 비율로 reads가 있는지 알 수 있다. 예를 들어, Rep1의 gene A는 33%라는 정보를 알 수 있고, 이를 통해 Rep2의 gene A와 비교하였을 때 Rep1의 gene A가 Rep2의 gene A 보다 약간 크다는 것을 알 수 있다.</p>
<h3 id="4-3-2.-comparison-among-RPKMs">
<a class="anchor" href="#4-3-2.-comparison-among-RPKMs" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-3-2. comparison among RPKMs<a class="anchor-link" href="#4-3-2.-comparison-among-RPKMs"> </a>
</h3>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled39.png" alt=""></p>
<p>RPKM은 각각의 replicate가 다른 total reads를 가지기 때문에 각각의 replicate의 gene을 비교하기 어렵다. 이 말은 각각의 gene의 reads 수를 비교하기 어렵다는 말이 된다. 그렇기 때문에 여러 sample들 내에서 mapping되는 reads의 비율을 보다 명확하게 말해주는 TPM이 자주 사용되는 추세다.</p>
<h2 id="4-3.-bias에-주의">
<a class="anchor" href="#4-3.-bias%EC%97%90-%EC%A3%BC%EC%9D%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>4-3. bias에 주의<a class="anchor-link" href="#4-3.-bias%EC%97%90-%EC%A3%BC%EC%9D%98"> </a>
</h2>
<p>RNA sequencing을 통해 유전자 발현량을 계산하는 것은 read가 얼마만큼 counting되었는가, 쌓인 read가 몇 개인지 그 개수를 측정하여 유전자의 발현량을 계산하는 것이다. 그러나 단순히 유전자 발현량을 계산하여 나온 값에서 만족하는 것이 아니라, 늘 bias에 의해 나온 것은 아닌지를 의심해야 한다. 실제로 심각한 bias가 있는지 없는지를 확인해야 한다. 어쨌든 유전자 발현량을 계산하기 위해선 read가 유전자에 잘 mapping되어야 한다.</p>
<h1 id="5.-실습">
<a class="anchor" href="#5.-%EC%8B%A4%EC%8A%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. 실습<a class="anchor-link" href="#5.-%EC%8B%A4%EC%8A%B5"> </a>
</h1>
<p>본 실습에서 다루는 pipeline은 다음과 같다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled40.png" alt=""></p>
<h2 id="5-1.-환경-설정-및-데이터-다운로드">
<a class="anchor" href="#5-1.-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>5-1. 환경 설정 및 데이터 다운로드<a class="anchor-link" href="#5-1.-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C"> </a>
</h2>
<div class="highlight"><pre><span></span><span class="nb">cd</span> kgenome/
mkdir toy_data
mkdir ref
<span class="nb">cd</span> toy_data/
</pre></div>
<p>데이터를 다운로드 받기 위한 폴더를 만든다. 데이터를 다운로드 받기 위해 다음의 url로 접근한다. 이 노트에서는 ERCC ExFold RNA Spike-In Control Mixes를 다운로드 한다. Spike in RNA는 RNA의 종류와 양을 알려져 있다. 따라서 이를 시퀀싱하여 원래 나와야 할 정답이 나오는지를 확인할 수 있다.</p>
<p><a href="https://github.com/griffithlab/rnaseq_tutorial/wiki/RNAseq-Data">https://github.com/griffithlab/rnaseq_tutorial/wiki/RNAseq-Data</a></p>
<div class="highlight"><pre><span></span>wget http://genomedata.org/rnaseq-tutorial/HBR_UHR_ERCC_ds_5pc.tar
</pre></div>
<p>실제 RNA 데이터는 수십 MB~수 GB까지 간다. 해당 데이터는 112MB 정도 된다. 해당 파일은 압축 파일이므로 압축을 풀어준다.</p>
<div class="highlight"><pre><span></span>ls -lh
tar -xvf HBR_UHR_ERCC_ds_5pc.tar
</pre></div>
<p>fastqc 파일들이 나온다. 이제, human genome과 human gtf file을 다운로드 하기 위해 다음의 작업을 진행한다. 다운로드 받을 수 있는 곳은 많다. 앙상블이나 UCSC genome browser, NCBI 등이 있다. 이 노트에서는 gencode 홈페이지(<a href="https://www.gencodegenes.org/">https://www.gencodegenes.org/</a>)에서 다운받고자 한다. 홈페이지 접속 후, human 클릭한다. 들어가보면 다양한 파일들이 있다. 여러 가지 옵션이 있다.  gene annotation 파일은 유전자가 genome의 어느 곳에 위치해 있는지, 어떤 종류의 유전자인지에 대한 정보다. 이 노트에서는 Basic gene annotation의 GTT 형식의 파일을 다운로드 받고 압축을 푼다. 풀 때 pipe 옵션( <code>|</code> )을 주어 내부의 정보들을 볼 수 있지만 여기서는 그냥 진행한다. 더불어, Fasta 파일을 함께 받는다. 여기서는 을 받는다.</p>
<div class="highlight"><pre><span></span><span class="nb">cd</span> ref
wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_35/gencode.v35.basic.annotation.gtf.gz
gunzip -c gencode.v35.basic.annotation.gtf.gz
<span class="c1"># 또는 gzip -d gencode.v35.basic.annotation.gtf.gz</span>

wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_35/GRCh38.primary_assembly.genome.fa.gz
gunzip -c GRCh38.primary_assembly.genome.fa.gz
<span class="c1"># 또는 gzip -d GRCh38.primary_assembly.genome.fa.gz</span>
</pre></div>
<p>페이지 밑에 fasta 파일을 다운로드 받을 수 있다. genome 관련 파일이다. 여기서는 다운로드 받는다. 나중에 원하는 파일을 다운로드 받으면 된다.</p>
<h2 id="5-2.-프로그램(tool)-다운로드">
<a class="anchor" href="#5-2.-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8(tool)-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>5-2. 프로그램(tool) 다운로드<a class="anchor-link" href="#5-2.-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8(tool)-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C"> </a>
</h2>
<h3 id="fastqc">
<a class="anchor" href="#fastqc" aria-hidden="true"><span class="octicon octicon-link"></span></a>fastqc<a class="anchor-link" href="#fastqc"> </a>
</h3>
<p>fastqc를 다운로드 받기 위해 fastqc사이트(<a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/">https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</a>)에 접근하여 Download Now를 클릭한 후, "<strong>FastQC</strong> A quality control application for high throughput sequence data" 부분에서 리눅스용 프로그램의 url 주소를 알아낸 후, 다운로드를 받은 후, 압축을 푼다.</p>
<div class="highlight"><pre><span></span>wget https://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.9.zip
unzip fastqc_v0.11.9.zip
</pre></div>
<p>압축 푼 폴더로 들어가서 <code>ls -lh</code>로 파일을 확인해보면 fastqc의 권한이 <code>-rw-rw-r--</code>로 되어있는 것을 볼 수 있다. 즉 실행 가능하도록 권한 변경이 필요하다.</p>
<div class="highlight"><pre><span></span>chmod <span class="m">755</span> * <span class="c1">#모든 파일에 대해서 755, 즉 나에게는 모든 권한을 주겠다.</span>
</pre></div>
<p>이제, toy_data(가짜 시퀀싱 data) 폴더로 이동한 후, fastqc 작업을 위한 폴더를 만든다.</p>
<div class="highlight"><pre><span></span>mkdir fastqc
../sw_tool/FastQC/fastqc -h <span class="c1">#path를 등록하지 않았으므로 이렇게 사용한다.</span>
</pre></div>
<h3 id="trimmomatic">
<a class="anchor" href="#trimmomatic" aria-hidden="true"><span class="octicon octicon-link"></span></a>trimmomatic<a class="anchor-link" href="#trimmomatic"> </a>
</h3>
<p>trimmomatic을 다운로드 받기 위해 사이트(<a href="http://www.usadellab.org/cms/?page=trimmomatic">http://www.usadellab.org/cms/?page=trimmomatic</a>)로 접근한 후, binary 파일을 다운로드 한다.</p>
<div class="highlight"><pre><span></span><span class="nb">cd</span> sw_tool
wget http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/Trimmomatic-0.39.zip
unzip Trimmomatic-0.39.zip
chmod <span class="m">755</span> trimmomatic-0.39.jar
</pre></div>
<h3 id="STAR">
<a class="anchor" href="#STAR" aria-hidden="true"><span class="octicon octicon-link"></span></a>STAR<a class="anchor-link" href="#STAR"> </a>
</h3>
<p>STAR를 다운로드 받기 위해 (구글에서는 rna seq STAR download 후 github 페이지 접속), 사이트(<a href="https://github.com/alexdobin/STAR">https://github.com/alexdobin/STAR</a>)에 접근한 후, 메뉴얼대로 설치하면 된다.</p>
<div class="highlight"><pre><span></span>wget https://github.com/alexdobin/STAR/archive/2.7.6a.tar.gz <span class="o">&amp;&amp;</span> tar -xzf <span class="m">2</span>.7.6a.tar.gz
<span class="nb">cd</span> STAR-2.7.6a/
<span class="nb">cd</span> bin
<span class="nb">cd</span> Linux_x86_64
./STAR
</pre></div>
<p>노트를 작성하고 있는 현재, 버전은 2.7.6a이다. help 페이지는 <code>./START --help</code>를 치면 된다.</p>
<h3 id="RSEM">
<a class="anchor" href="#RSEM" aria-hidden="true"><span class="octicon octicon-link"></span></a>RSEM<a class="anchor-link" href="#RSEM"> </a>
</h3>
<p>RSEM은 다음과 같이 설치한다. 사이트(<a href="https://github.com/deweylab/RSEM">https://github.com/deweylab/RSEM</a>)에 접근 후 메뉴얼대로 설치한다. RSEM은 java 기반이 아닌 gcc 기반이다.</p>
<div class="highlight"><pre><span></span>wget https://github.com/deweylab/RSEM/archive/master.zip
mv master.zip RSEM.zip
unzip RSEM.zip
<span class="nb">cd</span> RSEM-master
sudo make 또는 sudo make install <span class="c1">#make install을 하기 위해서는 samtools 설치가 필요할 수도 있다.</span>
</pre></div>
<p>RSEM은 유전자 발현량을 quantification해주는 tool이다. 설치가 끝나고 나면 메뉴얼 대로 rsem을 실행시켜 볼 수 있다.</p>
<div class="highlight"><pre><span></span><span class="c1"># https://github.com/deweylab/RSEM</span>
rsem-prepare-reference --help
rsem-prepare-reference --help
rsem-sam-validator
convert-sam-for-rsem --help
</pre></div>
<h3 id="samtools">
<a class="anchor" href="#samtools" aria-hidden="true"><span class="octicon octicon-link"></span></a>samtools<a class="anchor-link" href="#samtools"> </a>
</h3>
<div class="highlight"><pre><span></span>wget https://github.com/samtools/samtools/releases/download/1.3/samtools-1.3.tar.bz2
</pre></div>
<h2 id="5-3.-QC">
<a class="anchor" href="#5-3.-QC" aria-hidden="true"><span class="octicon octicon-link"></span></a>5-3. QC<a class="anchor-link" href="#5-3.-QC"> </a>
</h2>
<p>fastqc를 사용하여 QC를 수행한다. fastqc 프로그램으로 QC 작업을 진행한다.</p>
<div class="highlight"><pre><span></span>../sw_tool/FastQC/fastqc -o fastqc/ UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz
</pre></div>
<ul>
<li>
<code>-o</code>: output의 결과를 어디에 놓을 것인지 path를 지정</li>
</ul>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled41.png" alt=""></p>
<p>QC 결과를 보기 위해 fastqc 폴더로 이동한다. html 파일을 통해 내용을 확인할 수 있다.</p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled42.png" alt=""></p>
<p><img src="/dohk/images/copied_from_nb/../images/2020-11-16-rna-seq/Untitled43.png" alt=""></p>
<p>x축이 길어짐에 따라 fred score가 30이상임을 보여주고 있다. 만약 base quality가 특정 위치에서 급격하게 떨어진다면 해당 부위를 trimming하거나 제거하여 분석작업을 진행하면 된다. 이 외에도 각종 시퀀싱 데이터의 QC 결과를 확인할 수 있다.</p>
<h2 id="5-4.-Trimming">
<a class="anchor" href="#5-4.-Trimming" aria-hidden="true"><span class="octicon octicon-link"></span></a>5-4. Trimming<a class="anchor-link" href="#5-4.-Trimming"> </a>
</h2>
<p>Trimmomatic을 이용하여 Trmming작업을 수행한다. 정확한 사용법은 사이트(<a href="http://www.usadellab.org/cms/?page=trimmomatic">http://www.usadellab.org/cms/?page=trimmomatic</a>)에 잘 나와있다. 그 예는 다음과 같다.</p>
<div class="highlight"><pre><span></span>java -jar <span class="o">(</span>달러표시<span class="o">)</span>trimmomatic-0.39.jar PE input_forward.fq.gz <span class="se">\ </span>
input_reverse.fq.gz output_forward_paired.fq.gz <span class="se">\ </span>
output_forward_unpaired.fq.gz output_reverse_paired.fq.gz <span class="se">\ </span>
output_reverse_unpaired.fq.gz <span class="se">\ </span>
ILLUMINACLIP:TruSeq3-PE.fa:2:30:10:2:keepBothReads LEADING:3 TRAILING:3 MINLEN:36
</pre></div>
<p>실제 코드에는 input 파일의 이름을 지정해주는 등의 작업이 필요하다. 다음과 같이 한다.</p>
<div class="highlight"><pre><span></span>java -jar <span class="o">(</span>달러표시<span class="o">)</span>Trimmomatic PE -threads <span class="m">4</span> -phred33 <span class="se">\ </span>
UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz <span class="se">\ </span>
UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz <span class="se">\ </span>
TestData_read1.trim.fastq.qz <span class="se">\ </span>
TestData_read1.unpaired.fastq.gz <span class="se">\ </span>
TestData_read2.trim.fastq.gz <span class="se">\ </span>
TestData_read2.unparied.fastq.gz <span class="se">\ </span>
ILLUMINACLIP:/home/dohk/Dropbox/bioinformatics_software/Trimmomatic-0.39/adapters/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:15 LEADING:10 TRAILING:10 MINLEN:50
</pre></div>
<div class="highlight"><pre><span></span><span class="c1"># 복붙용</span>
java -jar <span class="o">(</span>달러표시<span class="o">)</span>Trimmomatic PE -threads <span class="m">4</span> -phred33 UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz TestData_read1.trim.fastq.qz TestData_read1.unpaired.fastq.gz TestData_read2.trim.fastq.gz TestData_read2.unparied.fastq.gz ILLUMINACLIP:/home/dohk/Dropbox/bioinformatics_software/Trimmomatic-0.39/adapters/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:15 LEADING:10 TRAILING:10 MINLEN:50
</pre></div>
<ul>
<li>
<code>PE</code>: Paired End</li>
<li>
<code>-threads</code>: 쓰레드 개수 지정<ul>
<li>내 PC의 가용한 쓰레드 수를 알아보려면 <code>grep -c processor /proc/cpuinfo</code> 을 입력한다.</li>
</ul>
</li>
<li>
<code>-phread</code>: ASCII 코드로 base quality를 변환하는 과정에서 33을 빼고 계산하는 파일의 형식이 있었고, 33을 빼지 않고 계산하는 파일의 형식이 있다. 따라서 가지고 있는 fastq 파일의 형식에 대해 지정해 주어야 한다. 현재 만들어지는 fastq 파일은 33을 빼야 하는 형식이다.</li>
<li>분석하고자 하는 파일 1(<code>R1</code>), 분석하고자 하는 파일 2(<code>R2</code>): paired-end이므로 두 파일이 모두 필요하다.</li>
<li>Low quality 파일을 trimming한 이후의 파일의 명. 직접 정하면 된다.<ul>
<li>
<code>TestData_read1.trim.fast.qz</code>: 잘린 파일의 명</li>
<li>
<code>TestData_read1.unpaired.fastq.gz</code>: 데이터를 trimming하는 과정 중에 R1에 있는 특정 read의 quality가 안 좋아서 그 read를 탈락 시켜야 한다면, R2의 해당 read도 탈락시켜야 합리적이다. paired-end이기 때문이다. 따라서 한 쪽의 read가 탈락 했을 시 양쪽 모두를 탈락 시키게 되고, 해당 read에 대한 데이터를 집어넣는 파일의 명을 저렇게 정해준다.</li>
<li>
<code>TestData_read2.trim.fast.qz</code>, <code>TestData_read1.unpaired.fastq.gz</code>: paired-end이므로 두 번째 read 파일에 대한 trim 데이터와 탈락된 read 데이터를 저장하는 파일의 이름을 지정 해준다.</li>
</ul>
</li>
<li>
<code>ILLUMINACLIP:/home/dohk/Dropbox/bioinformatics_software/Trimmomatic-0.39/adapters/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:15 LEADING:10 TRAILING:10 MINLEN:50</code><ul>
<li>구체적인 세팅에 해당한다.</li>
<li>Trimmomatic의 주요 기능 중 base quality가 low quality일 경우 해당 부위를 자르거나 버리는 것, 그리고 adaptor contamination을 찾았을 때, 이것이 실제 human genome이라는 보장이 없으므로 이를 제거하는 것이다. 따라서 어떤 파라미터로 어떤 세팅으로 찾을 것인지에 대한 것이 필요하다. 이 때 필요한 window size, 이동은 어떻게 할지, read length가 어느 정도 짧아지면 버릴 것인지에 대한 것을 파라미터로 명시한다.</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="tfedohk/dohk"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/dohk/rna-seq-basic/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/dohk/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/dohk/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/dohk/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>contact on gwondohyung@gmail.com</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/tfedohk" title="tfedohk"><svg class="svg-icon grey"><use xlink:href="/dohk/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/fastdotai" title="fastdotai"><svg class="svg-icon grey"><use xlink:href="/dohk/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
